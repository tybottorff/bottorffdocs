---
title: "R Notebook"
output: html_notebook
---

# Load necessary libraries

```{r}

library(TAR)
library(Seurat)
library(Matrix)
library(patchwork)
library(ggplot2)

```
# Extract contents of the .tar file into the data directory

```{r}

tar_file <- "../data/GSE216329_RAW.tar"

# Extract the contents of the .tar file
output_dir <- "../data"

# Use the system command to extract the files
system(paste("tar -xf", tar_file, "-C", output_dir))

# manually renamed 2 files (.features. and .enes. to .genes.)

```
# Create a Seurat object for each sample

```{r}

# List of sample names, start small to not bloat workflow
sample_names <- c(
  "GSM6668925_P1_T", "GSM6668926_P1_TN", "GSM6668927_P2_T", "GSM6668928_P2_TN",
  "GSM6668929_P4_T", "GSM6668930_P4_TN", "GSM6668931_P5_T", "GSM6668932_P5_TN",
  "GSM6668933_P7_T", "GSM6668934_P7_TN", "GSM6668935_P17_T", "GSM6668936_P17_TN",
  "GSM6668937_P3_T", "GSM6668938_P3_TN", "GSM6668939_P8_T", "GSM6668940_P8_TN",
  "GSM6668941_P9_T", "GSM6668942_P9_TN", "GSM6668943_P10_T", "GSM6668944_P10_TN",
  "GSM6668945_P11_T", "GSM6668946_P11_TN", "GSM6668947_P18_T", "GSM6668948_P18_TN",
  "GSM6668949_P19_T", "GSM6668950_P19_TN", "GSM6668951_P6_T", "GSM6668952_P6_TN",
  "GSM6668953_P12_T", "GSM6668954_P12_TN", "GSM6668955_P13_T", "GSM6668956_P13_TN",
  "GSM6668957_P14_T", "GSM6668958_P14_TN", "GSM6668959_P15_T", "GSM6668960_P15_TN",
  "GSM6668961_P16_T", "GSM6668962_P16_TN", "GSM6668963_P20_T", "GSM6668964_P20_TN",
  "GSM6668965_P21_T", "GSM6668966_P21_TN", "GSM6668967_P22_T", "GSM6668968_P22_TN",
  "GSM6668969_P23_T", "GSM6668970_P23_TN", "GSM6668971_P24_T", "GSM6668972_P24_TN"
)

# Directory containing data files
data_dir <- "../data/"

# Create Seurat objects for each sample
seurat_objects <- list()

for (sample_name in sample_names) {
  # Construct file paths
  counts_file <- paste0(data_dir, sample_name, ".matrix.mtx.gz")
  barcodes_file <- paste0(data_dir, sample_name, ".barcodes.tsv.gz")
  genes_file <- paste0(data_dir, sample_name, ".genes.tsv.gz")
  
  # Read data files
  counts <- readMM(counts_file)
  barcodes <- read.table(barcodes_file, stringsAsFactors = FALSE)[, 1]
  features <- read.csv(genes_file, stringsAsFactors = FALSE, sep = "\t", header = FALSE)
  rownames(counts) <- make.unique(features[, 2])
  colnames(counts) <- barcodes
  
  # Create Seurat object
  seurat <- CreateSeuratObject(counts, project = sample_name)
  
  # Store Seurat object in the list
  seurat_objects[[sample_name]] <- seurat
}

```

# Merge Seurat objects from all samples

```{r}

merged_seurat <- Reduce(function(x, y) merge(x, y), seurat_objects[-1], init = seurat_objects[[1]])

```
# Perform quality control

```{r}

# take a look at initial quality, look at samples independently (colors/x-axis)

merged_seurat[["percent.mt"]] <- PercentageFeatureSet(merged_seurat, pattern = "^MT[-\\.]")
merged_seurat[["percent.rb"]] <- PercentageFeatureSet(merged_seurat, pattern = "^(RPL|RPS).*")
merged_seurat[["percent.hb"]] <- PercentageFeatureSet(merged_seurat, pattern = "HBA1|HBA2|HBB")

VlnPlot(merged_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.rb", "percent.hb"), ncol = 5, pt.size=0)

# could also do histograms if desired

# Convert Seurat object's metadata to a data frame
#metadata_df <- as.data.frame(merged_seurat@meta.data)

# Create a histogram with multiple variables as different colors
#ggplot(data = metadata_df, aes(x = nCount_RNA)) +
#  geom_histogram(aes(fill = "nCount_RNA"), alpha = 0.5, bins = 30) +
#  geom_histogram(data = metadata_df, aes(x = nFeature_RNA, fill = "nFeature_RNA"), alpha = 0.5, bins = 30) +
#  geom_histogram(data = metadata_df, aes(x = percent.mt, fill = "percent.mt"), alpha = 0.5, bins = 30) +
#  geom_histogram(data = metadata_df, aes(x = percent.mt, fill = "percent.rb"), alpha = 0.5, bins = 30) +
#  geom_histogram(data = metadata_df, aes(x = percent.mt, fill = "percent.hb"), alpha = 0.5, bins = 30) +
#  labs(x = "Values", y = "Frequency") +
#  facet_wrap(~ merged_seurat$orig.ident)

```

```{r}

# number of detected genes and number of detected transcripts are well correlated across cells (p2) while mitochondrial transcript percentage is less correlated (p1)

# Create the plots
plot1 <- FeatureScatter(merged_seurat, feature1 = "nCount_RNA", feature2 = "percent.mt") &
  theme(axis.text.x=element_text(angle=45, hjust=1, size=7),
        legend.text=element_text(size=7))
plot2 <- FeatureScatter(merged_seurat, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") &
  theme(axis.text.x=element_text(angle=45, hjust=1, size=7),
        legend.text=element_text(size=7))

plot1 + plot2

```

```{r}

# filter out cells with too few (not sequenced deep enough) or too many (doublets/multiplets sharing same cell barcode despite being multiple cells) cells
# gene number and transcript number correlate well, so we can set a cutoff for just one of these, perhaps gene number between 500 and 5000

# filter out cells with high mitochondrial transcript percentages (stressed cells)
# we will also set an upper threshold for mitochondrial transcript percentage (perhaps 5%)

merged_seurat <- subset(merged_seurat, subset = nFeature_RNA > 500 & nFeature_RNA < 5000 & percent.mt < 5)

# Convert Seurat object's metadata to a data frame
metadata_df <- as.data.frame(merged_seurat@meta.data)

# Create a histogram with multiple variables as different colors
ggplot(data = metadata_df, aes(x = nCount_RNA)) +
  geom_histogram(aes(fill = "nCount_RNA"), alpha = 0.5, bins = 30) +
  geom_histogram(data = metadata_df, aes(x = nFeature_RNA, fill = "nFeature_RNA"), alpha = 0.5, bins = 30) +
  geom_histogram(data = metadata_df, aes(x = percent.mt, fill = "percent.mt"), alpha = 0.5, bins = 30) +
  labs(x = "Values", y = "Frequency") +
  facet_wrap(~ merged_seurat$orig.ident)

# could also do a violin plot if desired
#VlnPlot(merged_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size=0)

```

# Normalization

```{r}

# amount of captured RNA varies cell to cell, so direct comparisons aren't ideal
# normalization aims to make gene expression levels between varied cells comparable
# normalization works similarly to TPM (transcripts per million reads) concept, normalize feature expression measurements for each cell to total expression, multiply by scale factor (perhaps default 10,000)
# add 1 pseudocount to every value so genes with 0 transcripts detected in a cell are still present after log transform
# log-transform expression levels so expression values better fit a normal distribution (log transform good for relative change investigations)

merged_seurat <- NormalizeData(merged_seurat)

```

# Feature selection for following heterogeneity analysis

```{r}

# not all genes are equally informative (some genes have low expression, some have similar expression across all cells), so we want to select the most variablly expressed features (genes)

# here, we select the top 3000 most variably expressed genes (2000-5000 usually ok)

merged_seurat <- FindVariableFeatures(merged_seurat, nfeatures = 3000)

```

```{r}

# visualize top features

top_features <- head(VariableFeatures(merged_seurat), 20)
plot1 <- VariableFeaturePlot(merged_seurat) &
  theme(axis.text.x=element_text(angle=45, hjust=1, size=10),
        axis.title.x=element_text(size=10),
        axis.title.y=element_text(size=10),
        legend.text=element_text(size=8))
plot2 <- LabelPoints(plot = plot1, points = top_features, repel = TRUE, size = 2)
plot1 + plot2

```

# Data scaling

```{r}

# different genes have different base expression levels and distributions, so they would contribute differently to analysis if no scaling was done (i.e. avoid highly expressed genes dominating analysis)

merged_seurat <- ScaleData(merged_seurat)

# here's a place to add batch effect corrections with the ScaleData args, perhaps regress out sample ID?
# seurat <- ScaleData(seurat, vars.to.regress = c("nFeature_RNA", "percent.mt"))
# good to try this later as it may not be necessary and may even be bad (nonlinear variation?)
# if an unwanted source of variation dominates heterogeneity, try later to regress it out

# SCTransform can take the place of the previous few steps (normalization, feature selection, data scaling) IF there's reason to suspect biases/artifacts from the above normalization
# seurat <- SCTransform(seurat, variable.features.n = 3000)

```

# Linear dimensionality reduction using principal component analysis (PCA)

```{r}

merged_seurat <- RunPCA(merged_seurat, features = VariableFeatures(object = merged_seurat), npcs = 50)

# can use elbow plot to decide how many PCs to use (i.e. up until the elbow bend)

ElbowPlot(merged_seurat, ndims = ncol(Embeddings(merged_seurat, "pca")))

```

```{r}

# can also see which genes are contributing most to each PC

PCHeatmap(merged_seurat, dims = 1:20, cells = 500, balanced = TRUE, ncol = 4)

```

```{r}

DimPlot(merged_seurat, reduction = "pca")

```

# Non-linear dimension reduction for visualization

```{r}

merged_seurat <- RunUMAP(merged_seurat, dims = 1:20)

```

```{r}

plot1 <- UMAPPlot(merged_seurat)
plot1

```

```{r}

plot1 <- FeaturePlot(merged_seurat, c("CD27.1", "CD8", "CD4.1", "CD45RA", "CD69", "HLA-DPB1", "HLA-A", "CD34"),
                     ncol=4, reduction = "umap")

plot1

```






# Check for batch effects in UMAP, color by variables in metadata (donor, sequencing date... confounders of gene expression, visually check want to see even mixing in each cluster vs. all of one person's/date's samples in one cluster would be bad)

Checkout different functions I'm using with ? for different args (vs. defaults I'm using)

After working through tutorial can checkout Erin Github for code comparison

# Steps/goals
 - align reads to reference genome, remove cells with very low numbers of mapping transcripts
 - quality control: calculate number of genes, UMIs, proportion of mitochondrial genes for each cell (filter out gene count < 500, mitochondrial genes > 0.2)
 - normalize matrix based on library size
 - general statistical test to calculate gene dispersion, base mean, cell coverage
 - obtain a normalized count matrix with gene expression values
 - use iCellR R package (v1.5.5, https://CRAN.R-project.org/package=iCellR) to take genes with high dispersion and coverage (2000 genes) to make PCA and batch alignment, also do UMAP and KNetL (zoom of 500), PhenoGraph cluster KNetL map results
 - visualize marker genes for each cluster on heatmaps, bar plots, boxplots, use marker genes to assign cell types
 - use Seurat package to combine protein (take into account differences between antibodies for ADT quantification) and RNA counts, perform clustering on both measurements, differential expression analysis between cell clusters of interest
 - filter to reduce noise at some point (also done in scRNAseq)
 - PCA/tSNE