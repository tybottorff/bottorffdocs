---
title: "Molecular Pathways of Colon Inflammation Induced by Cancer Immunotherapy"
output: pdf_document
---

 - data mining of https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7415717/
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)
library(Seurat)
library(purrr)
library(ComplexHeatmap)
library(UpSetR)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in TCRseq data

```{r}

tcrs <- read.csv("../saved_data/rna_tcr_no_na_good_cell_typing.csv") %>%
  mutate(predicted.celltype.l2 = if_else(seurat_clusters %in% c(25, 27), "CD4 Trm", if_else(seurat_clusters %in% c(3, 7, 9, 15, 16), "CD8 Trm", predicted.celltype.l2))) %>%
  select(patient, predicted.celltype.l1, predicted.celltype.l2, group, barcode, Chain, v_gene, j_gene, c_gene, cdr3, cdr3_nt)

tcrs

```

# Read in RNAseq data for UMAP coordinates

```{r}

seurat_obj <- readRDS("../saved_data/T_cells.rds")

```

# Extract UMAP coordinates

```{r}

umap_coords <- Embeddings(object = seurat_obj[["umap"]])[(colnames(seurat_obj)), c(1, 2)]
umap_coords <- as.data.frame(umap_coords)
umap_coords$celltype <- seurat_obj@meta.data$predicted.celltype.l2
umap_coords$cluster <- seurat_obj@meta.data$seurat_clusters

umap_coords$barcode <- rownames(umap_coords)

rownames(umap_coords) <- NULL

umap_coords <- umap_coords %>%
  left_join(tcrs %>% group_by(barcode) %>% slice(1) %>% ungroup() %>% select(barcode, group), by = "barcode") %>%
  mutate(celltype = if_else(cluster %in% c(25, 27), "CD4 Trm", if_else(cluster %in% c(3, 7, 9, 15, 16), "CD8 Trm", celltype)))

umap_coords

```

# Find TCR linkages

```{r}

alpha_tcrs_split <- tcrs %>%
  filter(Chain == "TRA") %>%
  group_by(cdr3) %>%
  filter(n() > 1) %>%
  ungroup() %>%
  split(.$cdr3)

alpha_linkages_list <- lapply(alpha_tcrs_split, function(df) {
  df %>%
    summarise(linkages = list(t(combn(barcode, 2, simplify = TRUE)))) %>%
    pull(linkages) %>%
    as.data.frame() %>%
    rename(barcode1 = X1, barcode2 = X2)
})

alpha_linkages <- bind_rows(alpha_linkages_list)

alpha_linkages

beta_tcrs_split <- tcrs %>%
  filter(Chain == "TRB") %>%
  group_by(cdr3) %>%
  filter(n() > 1) %>%
  ungroup() %>%
  split(.$cdr3)

beta_linkages_list <- lapply(beta_tcrs_split, function(df) {
  df %>%
    summarise(linkages = list(t(combn(barcode, 2, simplify = TRUE)))) %>%
    pull(linkages) %>%
    as.data.frame() %>%
    rename(barcode1 = X1, barcode2 = X2)
})

beta_linkages <- bind_rows(beta_linkages_list)

beta_linkages

```

# Get UMAP coordinates for barcodes in linkages

```{r}

barcode1 <- umap_coords %>%
  rename(barcode1 = barcode,
         celltype1 = celltype,
         group1 = group)

barcode2 <- umap_coords %>%
  rename(barcode2 = barcode,
         celltype2 = celltype,
         group2 = group)

alpha_links_with_coords <- alpha_linkages %>%
  left_join(barcode1, by = "barcode1") %>%
  rename(x_start = umap_1,
         y_start = umap_2) %>%
  left_join(barcode2, by = c("barcode2")) %>%
  rename(x_end = umap_1,
         y_end = umap_2)

alpha_links_with_coords

beta_links_with_coords <- beta_linkages %>%
  left_join(barcode1, by = "barcode1") %>%
  rename(x_start = umap_1,
         y_start = umap_2) %>%
  left_join(barcode2, by = c("barcode2")) %>%
  rename(x_end = umap_1,
         y_end = umap_2)

beta_links_with_coords

```

# Plot UMAP, add segments for linked TCRs (TRA, CD4 proliferating)

```{r}

coords <- alpha_links_with_coords %>%
  filter(celltype1 == "CD4 Proliferating" | celltype2 == "CD4 Proliferating",
         group1 != "no ICI",
         group2 != "no ICI")

p <- ggplot(umap_coords) +
  geom_point(aes(x=umap_1, y=umap_2, color=celltype), show.legend = TRUE, size = 0.01) +
  theme(legend.text = element_text(size = 10), legend.title = element_text(size = 12))

set.seed(123)
shuffled_indices <- sample(nrow(coords))
coords_shuffled <- coords[shuffled_indices, ]

coords_shuffled

# Plot the randomly selected rows
for (i in 1:1500) {
  
  if (coords_shuffled$group1[i] == "ICI colitis" && coords_shuffled$group2[i] == "ICI colitis") {
    line_color <- "red"
  } else {
    if (coords_shuffled$group1[i] == "ICI no colitis" && coords_shuffled$group2[i] == "ICI no colitis") {
      line_color <- "blue"
    } else {
      line_color <- "black"
    }
  }
  
  p <- p + annotate(
    "segment",
    x = coords_shuffled$x_start[i],
    y = coords_shuffled$y_start[i],
    xend = coords_shuffled$x_end[i],
    yend = coords_shuffled$y_end[i],
    color = line_color,
    size = 0.025
  )
}

p + guides(color = guide_legend(override.aes = list(size = 4)))

```

# Plot UMAP, add segments for linked TCRs (TRB, CD4 proliferating)

```{r}

coords <- beta_links_with_coords %>%
  filter(celltype1 == "CD4 Proliferating" | celltype2 == "CD4 Proliferating",
         group1 != "no ICI",
         group2 != "no ICI")

p <- ggplot(umap_coords) +
  geom_point(aes(x=umap_1, y=umap_2, color=celltype), show.legend = TRUE, size = 0.01) +
  theme(legend.text = element_text(size = 10), legend.title = element_text(size = 12))

set.seed(123)
shuffled_indices <- sample(nrow(coords))
coords_shuffled <- coords[shuffled_indices, ]

# Plot the randomly selected rows
for (i in 1:1500) {
  
  if (coords_shuffled$group1[i] == "ICI colitis" && coords_shuffled$group2[i] == "ICI colitis") {
    line_color <- "red"
  } else {
    if (coords_shuffled$group1[i] == "ICI no colitis" && coords_shuffled$group2[i] == "ICI no colitis") {
      line_color <- "blue"
    } else {
      line_color <- "black"
    }
  }
  
  p <- p + annotate(
    "segment",
    x = coords_shuffled$x_start[i],
    y = coords_shuffled$y_start[i],
    xend = coords_shuffled$x_end[i],
    yend = coords_shuffled$y_end[i],
    color = line_color,
    size = 0.025
  )
}

p + guides(color = guide_legend(override.aes = list(size = 4)))

```

# Plot UMAP, add segments for linked TCRs (TRA, CD8 naive)

```{r}

coords <- alpha_links_with_coords %>%
  filter(celltype1 == "CD8 Naive" | celltype2 == "CD8 Naive",
         group1 != "no ICI",
         group2 != "no ICI")

p <- ggplot(umap_coords) +
  geom_point(aes(x=umap_1, y=umap_2, color=celltype), show.legend = TRUE, size = 0.01) +
  theme(legend.text = element_text(size = 10), legend.title = element_text(size = 12))

set.seed(123)
shuffled_indices <- sample(nrow(coords))
coords_shuffled <- coords[shuffled_indices, ]

# Plot the randomly selected rows
for (i in 1:1500) {
  
  if (coords_shuffled$group1[i] == "ICI colitis" && coords_shuffled$group2[i] == "ICI colitis") {
    line_color <- "red"
  } else {
    if (coords_shuffled$group1[i] == "ICI no colitis" && coords_shuffled$group2[i] == "ICI no colitis") {
      line_color <- "blue"
    } else {
      line_color <- "black"
    }
  }
  
  p <- p + annotate(
    "segment",
    x = coords_shuffled$x_start[i],
    y = coords_shuffled$y_start[i],
    xend = coords_shuffled$x_end[i],
    yend = coords_shuffled$y_end[i],
    color = line_color,
    size = 0.025
  )
}

p + guides(color = guide_legend(override.aes = list(size = 4)))

```

# Plot UMAP, add segments for linked TCRs (TRB, CD8 naive)

```{r}

coords <- beta_links_with_coords %>%
  filter(celltype1 == "CD8 Naive" | celltype2 == "CD8 Naive",
         group1 != "no ICI",
         group2 != "no ICI")

p <- ggplot(umap_coords) +
  geom_point(aes(x=umap_1, y=umap_2, color=celltype), show.legend = TRUE, size = 0.01) +
  theme(legend.text = element_text(size = 10), legend.title = element_text(size = 12))

set.seed(123)
shuffled_indices <- sample(nrow(coords))
coords_shuffled <- coords[shuffled_indices, ]

# Plot the randomly selected rows
for (i in 1:1500) {
  
  if (coords_shuffled$group1[i] == "ICI colitis" && coords_shuffled$group2[i] == "ICI colitis") {
    line_color <- "red"
  } else {
    if (coords_shuffled$group1[i] == "ICI no colitis" && coords_shuffled$group2[i] == "ICI no colitis") {
      line_color <- "blue"
    } else {
      line_color <- "black"
    }
  }
  
  p <- p + annotate(
    "segment",
    x = coords_shuffled$x_start[i],
    y = coords_shuffled$y_start[i],
    xend = coords_shuffled$x_end[i],
    yend = coords_shuffled$y_end[i],
    color = line_color,
    size = 0.025
  )
}

p + guides(color = guide_legend(override.aes = list(size = 4)))

```

# Summarize degree of cell type junction crossover sharing for all cell types to make heatmap (TRA, ICI colitis)

```{r}

heatmap_prep_tra_colitis <- alpha_links_with_coords %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, group1, group2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(group1, group2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo == "ICI colitis_ICI colitis") %>%
  group_by(celltype_combo) %>%
  summarize(count = n()) %>%
  mutate(
    cell_type1 = map_chr(strsplit(celltype_combo, "_"), 1),
    cell_type2 = map_chr(strsplit(celltype_combo, "_"), 2)
  ) %>%
  select(-celltype_combo)

print(sum(heatmap_prep_tra_colitis$count))

# Create a matrix with all possible combinations of cell types for rows and cols
all_combinations <- expand.grid(
  cell_type1 = unique(c(heatmap_prep_tra_colitis$cell_type1, heatmap_prep_tra_colitis$cell_type2)),
  cell_type2 = unique(c(heatmap_prep_tra_colitis$cell_type1, heatmap_prep_tra_colitis$cell_type2))
)

# Merge the actual data with all combinations and fill missing counts with 1 (for cell type combos with 0 linkages, 1 because doing log transform)
df_merged <- merge(all_combinations, heatmap_prep_tra_colitis, by = c("cell_type1", "cell_type2"), all.x = TRUE)
df_merged[is.na(df_merged$count), "count"] <- 1

df_merged <- df_merged %>%
  mutate(count = log10(count))

# Sorting levels for ordered display in the heatmap to keep row and col orders same
df_merged$cell_type1 <- factor(df_merged$cell_type1, levels = sort(unique(df_merged$cell_type1)))
df_merged$cell_type2 <- factor(df_merged$cell_type2, levels = sort(unique(df_merged$cell_type2)))

# Creat a matrix with counts
heatmap_matrix <- matrix(df_merged$count, nrow = length(unique(df_merged$cell_type1)), 
                         ncol = length(unique(df_merged$cell_type2)),
                         byrow = TRUE)

# Set the lower triangle to 0
heatmap_matrix[lower.tri(heatmap_matrix)] <- NA

# Setting row and column names
rownames(heatmap_matrix) <- sort(unique(df_merged$cell_type1))
colnames(heatmap_matrix) <- sort(unique(df_merged$cell_type2))

# Plotting the heatmap
Heatmap(heatmap_matrix, 
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        heatmap_legend_param = list(title = "TRA CDR3 AA linkage\ncount (log10) within\nirAE colitis group"),
        na_col = "white"
)

```

# Summarize degree of cell type junction crossover sharing for all cell types to make heatmap (TRA, ICI no colitis)

```{r}

heatmap_prep_tra_no_colitis <- alpha_links_with_coords %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, group1, group2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(group1, group2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo == "ICI no colitis_ICI no colitis") %>%
  group_by(celltype_combo) %>%
  summarize(count = n()) %>%
  mutate(
    cell_type1 = map_chr(strsplit(celltype_combo, "_"), 1),
    cell_type2 = map_chr(strsplit(celltype_combo, "_"), 2)
  ) %>%
  select(-celltype_combo)

print(sum(heatmap_prep_tra_no_colitis$count))

# Create a matrix with all possible combinations of cell types for rows and cols
all_combinations <- expand.grid(
  cell_type1 = unique(c(heatmap_prep_tra_no_colitis$cell_type1, heatmap_prep_tra_no_colitis$cell_type2)),
  cell_type2 = unique(c(heatmap_prep_tra_no_colitis$cell_type1, heatmap_prep_tra_no_colitis$cell_type2))
)

# Merge the actual data with all combinations and fill missing counts with 1 (for cell type combos with 0 linkages, 1 because doing log transform)
df_merged <- merge(all_combinations, heatmap_prep_tra_no_colitis, by = c("cell_type1", "cell_type2"), all.x = TRUE)
df_merged[is.na(df_merged$count), "count"] <- 1

df_merged <- df_merged %>%
  mutate(count = log10(count))

# Sorting levels for ordered display in the heatmap to keep row and col orders same
df_merged$cell_type1 <- factor(df_merged$cell_type1, levels = sort(unique(df_merged$cell_type1)))
df_merged$cell_type2 <- factor(df_merged$cell_type2, levels = sort(unique(df_merged$cell_type2)))

# Creat a matrix with counts
heatmap_matrix <- matrix(df_merged$count, nrow = length(unique(df_merged$cell_type1)), 
                         ncol = length(unique(df_merged$cell_type2)),
                         byrow = TRUE)

# Set the lower triangle to 0
heatmap_matrix[lower.tri(heatmap_matrix)] <- NA

# Setting row and column names
rownames(heatmap_matrix) <- sort(unique(df_merged$cell_type1))
colnames(heatmap_matrix) <- sort(unique(df_merged$cell_type2))

# Plotting the heatmap
Heatmap(heatmap_matrix, 
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        heatmap_legend_param = list(title = "TRA CDR3 AA linkage\ncount (log10) within\nno irAE colitis group"),
        na_col = "white"
)

```

# Statistically compare TRA colitis vs. no colitis

```{r}

tra_stats <- alpha_links_with_coords %>%
  filter(celltype1 == "CD8 TEM") %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, group1, group2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(group1, group2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo %in% c("ICI colitis_ICI colitis", "ICI no colitis_ICI no colitis")) %>%
  select(-celltype1, -celltype2, -group1, -group2) %>%
  group_by(celltype_combo, group_combo) %>%
  summarize(count = n()) %>%
  ungroup() %>%
  group_by(celltype_combo) %>%
  summarise(
    celltype_combo = first(celltype_combo),
    p_val = fisher.test(matrix(c(sum(count[group_combo == "ICI colitis_ICI colitis"]), 
                                 sum(count[group_combo == "ICI no colitis_ICI no colitis"])), 
                               ncol = 2), 
                        simulate.p.value = TRUE)$p.value
  )

tra_stats

> # Create a contingency table
> #data <- matrix(c(14, 56, 2, 1), nrow = 2)
> #colnames(data) <- c("Not converged", "Converged")
> #rownames(data) <- c("ICI colitis", "ICI no colitis")
> 
> #print(data)
> 
> # Perform Fisher's exact test
> #print(fisher.test(data))

```

# Summarize degree of cell type junction crossover sharing for all cell types to make heatmap (TRB, ICI colitis)

```{r}

heatmap_prep_trb <- beta_links_with_coords %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, group1, group2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(group1, group2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo == "ICI colitis_ICI colitis") %>%
  group_by(celltype_combo) %>%
  summarize(count = n()) %>%
  mutate(
    cell_type1 = map_chr(strsplit(celltype_combo, "_"), 1),
    cell_type2 = map_chr(strsplit(celltype_combo, "_"), 2)
  ) %>%
  select(-celltype_combo)

print(sum(heatmap_prep_trb$count))

# Create a matrix with all possible combinations of cell types for rows and cols
all_combinations <- expand.grid(
  cell_type1 = unique(c(heatmap_prep_trb$cell_type1, heatmap_prep_trb$cell_type2)),
  cell_type2 = unique(c(heatmap_prep_trb$cell_type1, heatmap_prep_trb$cell_type2))
)

# Merge the actual data with all combinations and fill missing counts with 1 (for cell type combos with 0 linkages, 1 because doing log transform)
df_merged <- merge(all_combinations, heatmap_prep_trb, by = c("cell_type1", "cell_type2"), all.x = TRUE)
df_merged[is.na(df_merged$count), "count"] <- 1

df_merged <- df_merged %>%
  mutate(count = log10(count))

# Sorting levels for ordered display in the heatmap to keep row and col orders same
df_merged$cell_type1 <- factor(df_merged$cell_type1, levels = sort(unique(df_merged$cell_type1)))
df_merged$cell_type2 <- factor(df_merged$cell_type2, levels = sort(unique(df_merged$cell_type2)))

# Creat a matrix with counts
heatmap_matrix <- matrix(df_merged$count, nrow = length(unique(df_merged$cell_type1)), 
                         ncol = length(unique(df_merged$cell_type2)),
                         byrow = TRUE)

# Set the lower triangle to 0
heatmap_matrix[lower.tri(heatmap_matrix)] <- NA

# Setting row and column names
rownames(heatmap_matrix) <- sort(unique(df_merged$cell_type1))
colnames(heatmap_matrix) <- sort(unique(df_merged$cell_type2))

# Plotting the heatmap
Heatmap(heatmap_matrix, 
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        heatmap_legend_param = list(title = "TRB CDR3 AA linkage\ncount (log10) within\nirAE colitis group"),
        na_col = "white"
)

```

# Summarize degree of cell type junction crossover sharing for all cell types to make heatmap (TRB, ICI no colitis)

```{r}

heatmap_prep_trb <- beta_links_with_coords %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, group1, group2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(group1, group2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo == "ICI no colitis_ICI no colitis") %>%
  group_by(celltype_combo) %>%
  summarize(count = n()) %>%
  mutate(
    cell_type1 = map_chr(strsplit(celltype_combo, "_"), 1),
    cell_type2 = map_chr(strsplit(celltype_combo, "_"), 2)
  ) %>%
  select(-celltype_combo)

print(sum(heatmap_prep_trb$count))

# Create a matrix with all possible combinations of cell types for rows and cols
all_combinations <- expand.grid(
  cell_type1 = unique(c(heatmap_prep_trb$cell_type1, heatmap_prep_trb$cell_type2)),
  cell_type2 = unique(c(heatmap_prep_trb$cell_type1, heatmap_prep_trb$cell_type2))
)

# Merge the actual data with all combinations and fill missing counts with 1 (for cell type combos with 0 linkages, 1 because doing log transform)
df_merged <- merge(all_combinations, heatmap_prep_trb, by = c("cell_type1", "cell_type2"), all.x = TRUE)
df_merged[is.na(df_merged$count), "count"] <- 1

df_merged <- df_merged %>%
  mutate(count = log10(count))

# Sorting levels for ordered display in the heatmap to keep row and col orders same
df_merged$cell_type1 <- factor(df_merged$cell_type1, levels = sort(unique(df_merged$cell_type1)))
df_merged$cell_type2 <- factor(df_merged$cell_type2, levels = sort(unique(df_merged$cell_type2)))

# Creat a matrix with counts
heatmap_matrix <- matrix(df_merged$count, nrow = length(unique(df_merged$cell_type1)), 
                         ncol = length(unique(df_merged$cell_type2)),
                         byrow = TRUE)

# Set the lower triangle to 0
heatmap_matrix[lower.tri(heatmap_matrix)] <- NA

# Setting row and column names
rownames(heatmap_matrix) <- sort(unique(df_merged$cell_type1))
colnames(heatmap_matrix) <- sort(unique(df_merged$cell_type2))

# Plotting the heatmap
Heatmap(heatmap_matrix, 
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        heatmap_legend_param = list(title = "TRB CDR3 AA linkage\ncount (log10) within\nno irAE colitis group"),
        na_col = "white"
)

```

# Prepare df for upset plots

```{r}

alpha_upset_yes_irae <- tcrs %>%
  filter(Chain == "TRA",
         group == "ICI colitis") %>%
  mutate(present = 1) %>%
  spread(key = 'predicted.celltype.l2', value = 'present', fill = 0) %>%
  select(-patient, -predicted.celltype.l1, -group, -barcode, -Chain, -v_gene, -j_gene, -c_gene, -cdr3_nt) %>%
  group_by(cdr3) %>%
  summarize(across(everything(), sum)) %>%
  ungroup() %>%
  mutate(across(-cdr3, ~ifelse(. > 0, 1, 0)))

alpha_upset_yes_irae

alpha_upset_no_irae <- tcrs %>%
  filter(Chain == "TRA",
         group == "ICI no colitis") %>%
  mutate(present = 1) %>%
  spread(key = 'predicted.celltype.l2', value = 'present', fill = 0) %>%
  select(-patient, -predicted.celltype.l1, -group, -barcode, -Chain, -v_gene, -j_gene, -c_gene, -cdr3_nt) %>%
  group_by(cdr3) %>%
  summarize(across(everything(), sum)) %>%
  ungroup() %>%
  mutate(across(-cdr3, ~ifelse(. > 0, 1, 0)))

alpha_upset_no_irae

beta_upset_yes_irae <- tcrs %>%
  filter(Chain == "TRB",
         group == "ICI colitis") %>%
  mutate(present = 1) %>%
  spread(key = 'predicted.celltype.l2', value = 'present', fill = 0) %>%
  select(-patient, -predicted.celltype.l1, -group, -barcode, -Chain, -v_gene, -j_gene, -c_gene, -cdr3_nt) %>%
  group_by(cdr3) %>%
  summarize(across(everything(), sum)) %>%
  ungroup() %>%
  mutate(across(-cdr3, ~ifelse(. > 0, 1, 0)))

beta_upset_yes_irae

beta_upset_no_irae <- tcrs %>%
  filter(Chain == "TRB",
         group == "ICI no colitis") %>%
  mutate(present = 1) %>%
  spread(key = 'predicted.celltype.l2', value = 'present', fill = 0) %>%
  select(-patient, -predicted.celltype.l1, -group, -barcode, -Chain, -v_gene, -j_gene, -c_gene, -cdr3_nt) %>%
  group_by(cdr3) %>%
  summarize(across(everything(), sum)) %>%
  ungroup() %>%
  mutate(across(-cdr3, ~ifelse(. > 0, 1, 0)))

beta_upset_no_irae

```

# Create upset plots

```{r}

upset(as.data.frame(alpha_upset_yes_irae), sets = setdiff(colnames(alpha_upset_yes_irae), "cdr3"), sets.bar.color = "#56B4E9", sets.x.label = "TRA CDR3AAs per cell type in irAE colitis", mainbar.y.label = "TRA CDR3AA linkages (log10) within cell type (combos) in irAE colitis", point.size = 1.5, show.numbers = FALSE, scale.intersections = "log10", text.scale = 0.75)

upset(as.data.frame(alpha_upset_no_irae), sets = setdiff(colnames(alpha_upset_no_irae), "cdr3"), sets.bar.color = "#56B4E9", sets.x.label = "TRA CDR3AAs per cell type in no irAE colitis", mainbar.y.label = "TRA CDR3AA linkages (log10) within cell type (combos) in irAE no colitis", point.size = 1.5, show.numbers = FALSE, scale.intersections = "log10", text.scale = 0.75)

upset(as.data.frame(beta_upset_yes_irae), sets = setdiff(colnames(beta_upset_yes_irae), "cdr3"), sets.bar.color = "#56B4E9", sets.x.label = "TRB CDR3AAs per cell type in irAE colitis", mainbar.y.label = "TRB CDR3AA linkages (log10) within cell type (combos) in irAE colitis", point.size = 1.5, show.numbers = FALSE, scale.intersections = "log10", text.scale = 0.75)

upset(as.data.frame(beta_upset_no_irae), sets = setdiff(colnames(beta_upset_no_irae), "cdr3"), sets.bar.color = "#56B4E9", sets.x.label = "TRB CDR3AAs per cell type in no irAE colitis", mainbar.y.label = "TRB CDR3AA linkages (log10) within cell type (combos) in irAE no colitis", point.size = 1.5, show.numbers = FALSE, scale.intersections = "log10", text.scale = 0.75)

```