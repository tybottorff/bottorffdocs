---
title: "Identification of Pathogenic Immune Cell Subsets Associated with Checkpoint Inhibitor-induced Myocarditis"
output: pdf_document
---

 - data reproduction of https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9397491/
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(Seurat)
library(Matrix)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
library(circlize)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in data

```{r}

dehashed_combined_tcr_seq <- read.csv("../saved_data/dehashed_tcr_seq.csv")

```

# Prep public dfs

```{r}

alpha_public_df <- dehashed_combined_tcr_seq %>%
  select(barcode, cdr3, chain, Patient_ID) %>%
  filter(cdr3 != "None",
         chain == "TRA") %>%
  group_by(cdr3, Patient_ID) %>%
  summarize(count = n()) %>%
  ungroup() %>%
  mutate(presence = if_else(count > 0, 1, 0)) %>%
  # 1 for yes, 0 for no for presence, then later filter for sum across rows > 1 look for public TCRs
  select(-count) %>%
  pivot_wider(names_from = c(Patient_ID), values_from = presence, values_fill = 0) %>%
  rowwise() %>%
  filter(sum(c_across(-cdr3)) > 1)

alpha_public_df

beta_public_df <- dehashed_combined_tcr_seq %>%
  select(barcode, cdr3, chain, Patient_ID) %>%
  filter(cdr3 != "None",
         chain == "TRB") %>%
  group_by(cdr3, Patient_ID) %>%
  summarize(count = n()) %>%
  ungroup() %>%
  mutate(presence = if_else(count > 0, 1, 0)) %>%
  # 1 for yes, 0 for no for presence, then later filter for sum across rows > 1 look for public TCRs
  select(-count) %>%
  pivot_wider(names_from = c(Patient_ID), values_from = presence, values_fill = 0) %>%
  rowwise() %>%
  filter(sum(c_across(-cdr3)) > 1)

beta_public_df

```

# Prep dfs for circle plot of TCR CDR3 AA matches across patients

```{r}

circle_df <- dehashed_combined_tcr_seq %>%
  select(barcode, chain, cdr3, Patient_ID) %>%
  mutate(identifier = paste(barcode, chain, Patient_ID, cdr3, sep = "_")) %>%
  mutate(public = case_when(
    chain == "TRA" & cdr3 %in% alpha_public_df$cdr3 ~ "yes",
    chain == "TRB" & cdr3 %in% beta_public_df$cdr3 ~ "yes",
    TRUE ~ "no"
  ))

tcr_cells <- circle_df %>%
  rename(tcr1 = identifier) %>%
  distinct() %>%
  head(5000)

tcr_cells

tcr_links_raw <- circle_df %>%
  filter(public == "yes") %>%
  head(1000)
  
tcr_links <- data.frame(tcr1 = character(0), tcr2 = character(0))

for (i in 1:(nrow(tcr_links_raw) - 1)) {
  for (j in (i + 1):nrow(tcr_links_raw)) {
    if (tcr_links_raw$cdr3[i] == tcr_links_raw$cdr3[j] && tcr_links_raw$Patient_ID[i] != tcr_links_raw$Patient_ID[j]) {
      tcr_links <- rbind(tcr_links, data.frame(tcr1 = tcr_links_raw$identifier[i], tcr2 = tcr_links_raw$identifier[j]))
    }
  }
}

tcr_links


# alternative approach?
#tcr_links_raw %>%
#  filter(public == "yes") %>%
#  slice(1:1000) %>%
#  group_by(cdr3) %>%
#  filter(n() > 1) %>%
#  distinct(Patient_ID, .keep_all = TRUE) %>%
#  ungroup() %>%
#  select(tcr1 = identifier, tcr2 = identifier) %>%
#  distinct()

# want tcr_links df with 2 cols named tcr1 and tcr2, each row is a linkages (values are barcodes)

```

# Define function to create circle plot of TCR CDR3 AA seqs

```{r}

# @param tcr_cells data frame containing information at the cell level. Should include identifiers at minimum, as column "tcr1", plus optional columns for coloring the cells around the circos plot. Cells will be plotted in the order in which they are listed in this data frame.
# tcr_links data frame with links to draw between cells. Should include identifiers for the two cells, as columns "tcr1" and "tcr2", plus optional columns for color and/or width of the links to be drawn. Often the output of \code{tabulate_shared_TCR_chains}. If an empty data frame, or set to \code{NULL}, no links will be drawn.

plot_TCR_circos <-
  function(
    tcr_cells, tcr_links,
    ring_colors=NULL,
    link_colors=NULL, link_width=NULL,
    filename=NULL, plottype="pdf", plotdims=c(12,12)) {

    check_unique_tcr1 <-
      function(x) if (any(duplicated(x$tcr1)))
        "Column 'tcr1' must not contain duplicate values" else TRUE

    checkmate::assert(
      checkmate::check_data_frame(tcr_cells),
      checkmate::check_numeric(plotdims, lower=0, len=2),
      check_unique_tcr1(tcr_cells),
      combine="and")

    if (!requireNamespace("circlize", quietly = TRUE))
      stop("Package \"circlize\" needed for this function to work. Please install it.",
           call. = FALSE)

    if (!is.null(filename)) plottype <- match.arg(plottype, choices=c("pdf", "png"))

    # define limits for plotting
    n_cells <- nrow(tcr_cells)
    tcr_cells$xmin <- 0
    tcr_cells$xmax = n_cells

    if (!is.null(filename)) {
      if (plottype == "pdf") {
        pdf(file=filename, width=plotdims[1], height=plotdims[2])
      } else if (plottype == "png")
        png(filename=filename, width=plotdims[1], height=plotdims[2], units="in")
      on.exit(dev.off(), add=TRUE) # close plotting device on exit
    } # SRP - want it to render into the current evironment/device, so don't open a new device.  Useful in Rmd documents.
    #else dev.new(width=plotdims[1], height=plotdims[2])  ### open plotting window

    par(mar=rep(0,4))
    circlize::circos.clear()

    # basic circos graphic parameters
    circlize::circos.par(
      cell.padding=c(0,0,0,0), track.margin=c(0,0.15), start.degree = 90, gap.degree = 0)

    # sector details
    circlize::circos.initialize(
      factors = tcr_cells$tcr1, xlim = cbind(tcr_cells$xmin, tcr_cells$xmax))

    if (is.null(ring_colors)) {
      ring_colors <- "default"
      tcr_cells[, ring_colors] <- "black"
    }
    checkmate::assert_data_frame(
      tcr_cells[, ring_colors, drop=FALSE],
      types="character")

    # plot sectors
    circlize::circos.trackPlotRegion(
      ylim = c(0, 1), factors = tcr_cells$tcr1, track.height=0.1,
      #panel.fun for each sector
      panel.fun = function(x, y) {
        #select details of current sector
        name = circlize::get.cell.meta.data("sector.index")
        i = circlize::get.cell.meta.data("sector.numeric.index")
        xlim = circlize::get.cell.meta.data("xlim")
        ylim = circlize::get.cell.meta.data("ylim")

        if (length(ring_colors)==1) {
          # single loop
          circlize::circos.rect(
            xleft=xlim[1], ybottom=ylim[1],
            xright=xlim[2], ytop=ylim[2],
            col = tcr_cells[i, ring_colors, drop=TRUE],
            border = tcr_cells[i, ring_colors, drop=TRUE])
        } else if (length(ring_colors)==2) {

          # colors for inner loop
          circlize::circos.rect(
            xleft=xlim[1], ybottom=ylim[1],
            xright=xlim[2], ytop=ylim[2]-0.5,
            col = tcr_cells[i, ring_colors[1], drop=TRUE],
            border = tcr_cells[i, ring_colors[1], drop=TRUE])

          # colors for outer loop
          circlize::circos.rect(
            xleft=xlim[1], ybottom=ylim[1]+0.5,
            xright=xlim[2], ytop=ylim[2],
            col = tcr_cells[i, ring_colors[2], drop=TRUE],
            border = tcr_cells[i, ring_colors[2], drop=TRUE])
        } else stop("Plotting with more than 2 loop colors is not currently supported.")

        # blank in part of main sector
        # circos.rect(xleft=xlim[1], ybottom=ylim[1], xright=xlim[2]-rowSums(m)[i], ytop=ylim[1]+0.3, col = "white", border = "white")

        #white line all the way around
        #circos.rect(xleft=xlim[1], ybottom=0.3, xright=xlim[2], ytop=0.32, col = "white", border = "white")

        #plot axis
        circlize::circos.axis(
          labels.cex=0.00000001, major.at=seq(from=0,to=floor(tcr_cells$xmax)[i],by=500)
          )
      })

    ### plot links
    if (!is.null(tcr_links)) {
      checkmate::assert(
        checkmate::check_data_frame(tcr_links))

      if (nrow(tcr_links) > 0) {

        # add sum values to tcr_cells, marking the x-position of the first links out (sum1) and in (sum2). Updated for further links in loop below.
        tcr_cells$sum <- length(unique(tcr_links$tcr1))

        if (is.null(link_colors)) {
          link_colors <- "default"
          tcr_links[,link_colors] <- "black"
        }
        checkmate::assert_character(tcr_links[, link_colors, drop=TRUE])

        if (is.null(link_width)) {
          link_width <- "default"
          tcr_links[,link_width] <- 1
        }
        checkmate::assert_numeric(tcr_links[, link_width, drop=TRUE])

        for (k in 1:nrow(tcr_links)) {
          # for(k in 1){
          # determine row of tcr_cells to use for coloring
          i <- match(tcr_links$tcr1[k], tcr_cells$tcr1)
          j <- match(tcr_links$tcr2[k], tcr_cells$tcr1)

          # Check for missing values in point1 and point2
          if (any(is.na(c(tcr_cells$sum[i], tcr_cells$sum[j])))) {
          warning("Skipping link ", k, " due to missing values in point1 or point2.")
          next  # Skip to the next iteration
          }
          
          # draw links, colored by selected variable
          circlize::circos.link(
            sector.index1=tcr_cells$tcr1[i], point1=c(tcr_cells$sum[i]),
            sector.index2=tcr_cells$tcr1[j], point2=c(tcr_cells$sum[j]),
            col = tcr_links[k, link_colors, drop=TRUE], rou1=0.75, rou2=0.75,
            lwd = tcr_links[k, link_width, drop=TRUE]*1.5)
        }
      }
    }
  }

```

# Create circos plot

```{r}

plot_TCR_circos(tcr_cells, tcr_links)

```