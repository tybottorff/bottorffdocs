---
title: "Identification of Pathogenic Immune Cell Subsets Associated with Checkpoint Inhibitor-induced Myocarditis"
output: pdf_document
---

 - data mining of https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9397491/
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(Seurat)
library(SeuratDisk)
library(ggplot2)
library(dplyr)
library(stringr)
library(tidyr)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in scRNAseq RDS

```{r}

immune.combined <- readRDS("../saved_data/final_seurat.rds")

```

# Read in scTCRseq, process to be added as metadata to scRNAseq

```{r}

dehashed_combined_tcr_seq <- read.csv("../saved_data/dehashed_tcr_seq.csv")
  
suffix_lookup <- tibble(
  Patient_ID = c("B1", "A10", "MCE12", "B10", "MCE13", "B12", "MCE7", "MCE6", "A8", "B11", "A9", "A6", "B9", "B13", "A5", "B14", "B2", "A1", "B3", "A2", "A3", "MCE1", "MCE2", "MCL1", "MCL3"),
  suffix = c("10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "1", "2", "3", "4", "5", "6", "7", "8", "9")
)

# Merge the lookup table to add the suffix column to the main data frame
dehashed_combined_tcr_seq <- dehashed_combined_tcr_seq %>%
  left_join(suffix_lookup, by = "Patient_ID") %>%
  mutate(barcode = paste(barcode, suffix, sep = "_")) %>%
  filter(chain != "Multi") %>%
  # pivot to combine 1 alpha and 1 beta (or 0 and 1) barcodes together
  select(-X) %>%
    # if a cell had two or more qualified chains of the same type, only that chain with the highest UMI count was qualified and retained
  group_by(barcode, chain) %>%
  arrange(-umis) %>%
  slice(1) %>%
  ungroup() %>%
  pivot_wider(id_cols = c(barcode, Patient_ID, irAE, suffix), names_from = chain, values_from = -c(barcode, Patient_ID, irAE, suffix))

dehashed_combined_tcr_seq <- as.data.frame(dehashed_combined_tcr_seq)

# Set row names based on the "Barcode" column
rownames(dehashed_combined_tcr_seq) <- dehashed_combined_tcr_seq$barcode

dehashed_combined_tcr_seq <- dehashed_combined_tcr_seq %>% select(-barcode)

dehashed_combined_tcr_seq

```

# Add TCRseq metadata to RNAseq

```{r}

rna_and_tcr <- AddMetaData(object = immune.combined, metadata = dehashed_combined_tcr_seq)

```

# Look at just T cells

```{r}

T_cells <- rna_and_tcr[, !(is.na(rna_and_tcr@meta.data$cdr3_TRA) | is.na(rna_and_tcr@meta.data$cdr3_TRB)) & rna_and_tcr@meta.data$predicted.celltype.l1 %in% c("CD4 T", "CD8 T", "other T") & rna_and_tcr@meta.data$predicted.celltype.l2 %in% c("CD8 TEM", "CD4 TEM", "CD8 TCM", "CD4 TCM", "Treg", "CD4 Naive", "CD8 Naive",  "dnT", "CD4 Proliferating", "CD8 Proliferating", "MAIT", "CD4 CTL", "CD8 CTL")]

```

# Re-do dimensional reduction, clustering

```{r}

T_cells <- RunPCA(T_cells, npcs = 30, verbose = FALSE)
T_cells <- RunUMAP(T_cells, reduction = "pca", dims = 1:30)
T_cells <- FindNeighbors(T_cells, reduction = "pca", dims = 1:30)
T_cells <- FindClusters(T_cells, resolution = 3)

```

# Read in reference to use for mapping

```{r}

reference <- LoadH5Seurat("../raw_data/pbmc_multimodal.h5seurat")

```

# Find reference transfer anchors

```{r}

anchors <- FindTransferAnchors(
  reference = reference,
  query = T_cells,
  normalization.method = "SCT",
  reference.reduction = "pca",
  dims = 1:50
)

```

# Map reference onto my object

```{r}

T_cells <- MapQuery(
  anchorset = anchors,
  query = T_cells,
  reference = reference,
  refdata = list(
    celltype.l1 = "celltype.l1",
    celltype.l2 = "celltype.l2",
    predicted_ADT = "ADT"
  ),
  reference.reduction = "pca", 
  reduction.model = "wnn.umap"
)

```

# Plot mapping results

```{r}

p1 = DimPlot(T_cells, reduction = "umap", group.by = "predicted.celltype.l1", label = TRUE, label.size = 3, repel = TRUE) + NoLegend()

p2 = DimPlot(T_cells, reduction = "umap", group.by = "predicted.celltype.l2", label = TRUE, label.size = 3 , repel = TRUE) + NoLegend()

p1 + p2

```

# Relook just at T cells again

```{r}

just_T_cells <- T_cells[, !(is.na(T_cells@meta.data$cdr3_TRA) | is.na(T_cells@meta.data$cdr3_TRB)) & T_cells@meta.data$predicted.celltype.l1 %in% c("CD4 T", "CD8 T", "other T") & T_cells@meta.data$predicted.celltype.l2 %in% c("CD8 TEM", "CD4 TEM", "CD8 TCM", "CD4 TCM", "Treg", "CD4 Naive", "CD8 Naive",  "dnT", "CD4 Proliferating", "CD8 Proliferating", "MAIT", "CD4 CTL", "CD8 CTL")]

just_T_cells <- RunPCA(just_T_cells, npcs = 30, verbose = FALSE)
just_T_cells <- RunUMAP(just_T_cells, reduction = "pca", dims = 1:30)
just_T_cells <- FindNeighbors(just_T_cells, reduction = "pca", dims = 1:30)
just_T_cells <- FindClusters(just_T_cells, resolution = 3)
anchors <- FindTransferAnchors(
  reference = reference,
  query = just_T_cells,
  normalization.method = "SCT",
  reference.reduction = "pca",
  dims = 1:50
)
T_cells <- MapQuery(
  anchorset = anchors,
  query = just_T_cells,
  reference = reference,
  refdata = list(
    celltype.l1 = "celltype.l1",
    celltype.l2 = "celltype.l2",
    predicted_ADT = "ADT"
  ),
  reference.reduction = "pca", 
  reduction.model = "wnn.umap"
)

```

# Plot cell type assignments

```{r}

p1 = DimPlot(just_T_cells, reduction = "umap", group.by = "predicted.celltype.l1", label = TRUE, label.size = 3, repel = TRUE) + NoLegend()

p2 = DimPlot(just_T_cells, reduction = "umap", group.by = "predicted.celltype.l2", label = TRUE, label.size = 3 , repel = TRUE) + NoLegend()

p1 + p2

```

# Save RDS

```{r}

saveRDS(just_T_cells, "../saved_data/final_seurat_T_cells.rds")

```

# Map clonal relations

```{r}

public_df <- just_T_cells@meta.data %>%
  group_by(cdr3, v_gene, j_gene, c_gene) %>%
  filter(n_distinct(Patient_ID) > 1) %>%
  # need to fix early/late patient still
  mutate(joined_cdr3 = paste(cdr3_TRA, cdr3_TRB, sep = ""))
  
public_df

clonal_relations <- just_T_cells@meta.data %>%
  mutate(joined_cdr3 = paste(cdr3_TRA, cdr3_TRB, sep = "")) %>%
  mutate(public = if_else(joined_cdr3 %in% public_df$joined_cdr3, "public", "private"))

clonal_relations

# Add metadata of publicness back

just_T_cells <- AddMetaData(object = just_T_cells, metadata = clonal_relations)

```

# Airline plot

```{r}

# Subset public cells
public_cells <- subset(just_T_cells, subset = public == "public")

# Extract UMAP coordinates for public cells
umap_coordinates <- Embeddings(public_cells, "umap")

# Plot UMAP
p2 <- DimPlot(just_T_cells, reduction = "umap", group.by = "predicted.celltype.l2", label = TRUE, label.size = 3, repel = TRUE) + NoLegend()

# Loop through unique flavors
for (flavor in unique(clonal_relations$joined_cdr3)) {
  # Subset public cells of the current flavor
  flavor_cells <- WhichCells(public_cells, cells = row.names(public_cells)[public_cells$joined_cdr3 == flavor])

  # Extract UMAP coordinates for cells of the current flavor
  flavor_umap_coords <- umap_coordinates[row.names(flavor_cells), ]
  
  # Add lines connecting cells of the same flavor
  if (nrow(flavor_umap_coords) > 1) {
    lines_data <- data.frame(
      x = flavor_umap_coords[1:(nrow(flavor_umap_coords) - 1), 1],
      y = flavor_umap_coords[1:(nrow(flavor_umap_coords) - 1), 2],
      xend = flavor_umap_coords[2:nrow(flavor_umap_coords), 1],
      yend = flavor_umap_coords[2:nrow(flavor_umap_coords), 2]
    )
    
    p2 <- p2 + geom_segment(data = lines_data, aes(x = x, y = y, xend = xend, yend = yend), color = "black", size = 0.5)
  }
}

# Display the plot
print(p2)

```






rm(list = ls())
library(plyr)
library(edgeR)
library(compareGroups)
library(dbscan)
library(MAST)
library(ggsignif)
library(monocle3)
library(dplyr)
library(geosphere)

library(ggplot2); library(reshape2); theme_set(theme_bw(26) + theme(panel.grid.major = element_blank(), 
                                                 panel.grid.minor = element_blank()) +
                              theme(legend.key = element_blank()))
update_geom_defaults("point", aes(size = 4))

## load files
setwd("~/Dropbox/RNAseq/Trinity/CD45/P91_Karen_junbao/Monocle_clone_linking/")

tcrs = readRDS("cds_scanorama_batch4_tcrs.rds") # use cds object as source of TCRs

tcrs = tcrs[c("libid", "v_gene", "j_gene", "junction")]
colnames(tcrs) = c("libID", "V.gene", "J.gene", "junction") # 1413
#tcrs = tcrs[!duplicated(tcrs[,]),] #1406

anno.tcrs = readRDS("cds_scanorama_batch4_tcrs.rds")
colnames(anno.tcrs) = gsub("v_gene", "V.gene", colnames(anno.tcrs))
colnames(anno.tcrs) = gsub("j_gene", "J.gene", colnames(anno.tcrs))
colnames(anno.tcrs) = gsub("junction", "junction", colnames(anno.tcrs))
colnames(anno.tcrs) = gsub("libid", "libID", colnames(anno.tcrs))

cds = readRDS("cds_structure_scanorama_batch4.rds")

cds$libID = cds$libId

## read cds object

p = readRDS("cds_scanorama_batch4.rds")

anno.tcrs = subset(anno.tcrs, libID %in% cds$libID) # subset tcrs to libs in cds object

## look at TCR expansion in clusters

cut <- 2
no = ddply(anno.tcrs,.(V.gene, J.gene,junction), plyr::summarize, sum = length(junction))
no.sub = subset(no, sum>=cut)
no.not.sub = subset(no, sum<cut)

E = subset(anno.tcrs, junction %in% no.sub$junction) # 1490
NE = subset(anno.tcrs, !junction %in% E$junction) # 4232
E.cell = subset(anno, anno$libID %in% E$libID) # 844
NE.cell = subset(anno, !anno$libID %in% E$libID) # 2203

E.cell.u = E.cell[!duplicated(E.cell$libID),] # 844
NE.cell.u = NE.cell[!duplicated(NE.cell$libID),] # 2203

## calculate overlap using circos code

sub = E

##### trim TCR sequences
melt.tcrs = sub[,]
melt.tcrs = melt.tcrs[c("libID", "V.gene", "junction")]
melt.tcrs$junction = as.character(melt.tcrs$junction)

###### combine TRAV as origing and TRBV as deistination using junction as key
melt.join = merge(melt.tcrs, melt.tcrs, by = "junction", stringsAsFactors = F)
melt.join$junction = as.character(melt.join$junction)

#melt.join = subset(melt.join, !melt.join$libID.x== melt.join$libID.y)

##### limit variables

melt.join = melt.join[c(1,2,4)]
colnames(melt.join) = c("junction", "orig", "dest")

##### remove duplicated TCR records including libID
#melt.join = subset(melt.join, !orig == dest)
mju = melt.join # 3386
mju = mju[!duplicated(mju[,]),] # 3770

#### tabulate repeated pairings without libID and create df2
#table.mju= aggregate(list(numdup=rep(1,nrow(mju[2:ncol(mju)]))), mju[2:ncol(mju)], length)
table.mju = ddply(mju,.(orig, dest), plyr::summarize, numdup = length(orig))

table.mju$orig = as.character(table.mju$orig)
table.mju$dest = as.character(table.mju$dest)
table.set = subset(table.mju, table.mju$orig %in% sub$libID)

## remove duplicated combinations of orig and dest http://stackoverflow.com/questions/24194879/all-combinations-of-two-and-remove-if-they-are-same-in-r

library(data.table)
library(igraph)
g <-graph_from_data_frame(table.set[, 1:2], directed = F)
g <- simplify(g, remove.multiple = T, remove.loops = T)
zz = data.frame(get.edgelist(g))
colnames(zz) = c("orig", "dest")

temp = get.data.frame(g)
colnames(temp) = c("orig", "dest")
tempa = data.frame(orig = temp$dest, dest = temp$orig) # 730
#tempc = rbind(temp, tempa)
#tempc = tempc[!duplicated(tempc[,]),]

#temp$merge = paste(temp$orig, temp$dest)

t.sub = subset(table.set, table.set$orig %in% zz$orig & table.set$dest %in% zz$dest)
mdf6 = t.sub # 238
mdf6 = temp

mdf6 = subset(mdf6, !orig == dest) # 1824

## 

## extract UMAP coordinates from ggplot object and calculate centroids for clusters as mean of x and y coordiintes
cluster_cols = c("red", "gray")
cluster_cols2 = c("red", "blue", "gray")
cluster_cols3 = c("gray", "red")
 
gb<-ggplot_build(p)
gb.data = gb$data[[1]]
libs = cds$libID
gb.data$libID = libs

## extract UMAP coordinates for each expanded cell

mdf6$x = gb.data$x[match(mdf6$orig, gb.data$libID)]
mdf6$y = gb.data$y[match(mdf6$orig, gb.data$libID)]
mdf6$xend = gb.data$x[match(mdf6$dest, gb.data$libID)]
mdf6$yend = gb.data$y[match(mdf6$dest, gb.data$libID)]

for.lines = mdf6

#for.lines = for.lines[,c("lenOver", "x","y","xend", "yend")]
#for.lines$thick = for.lines$numdup/4
#for.lines$thick = c(0.00000125)
for.lines$thick = c(0.1)

#for.lines$thick = c(1)

### colour by cluster

dev.off()
quartz(width=10,height=8, dpi=72)  ### open plotting window

## set defaults
theme_set(theme_bw(30) + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + theme(legend.key = element_blank()))

pal = c('#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffed6f','#b15928', "gray")	
plot_cells(cds, color_cells_by="cluster", cell_size = 2, group_label_size = 0.000001, graph_label_size = 0.0001, show_trajectory_graph = F, label_branch_points = F, label_cell_groups = F)
last_plot() + scale_color_manual(values = pal, name = "cluster")# custom colors
last_plot() + geom_curve(data = for.lines, aes(x = x, y = y, xend = xend, yend = yend), size = for.lines$thick, curvature = 0.6)