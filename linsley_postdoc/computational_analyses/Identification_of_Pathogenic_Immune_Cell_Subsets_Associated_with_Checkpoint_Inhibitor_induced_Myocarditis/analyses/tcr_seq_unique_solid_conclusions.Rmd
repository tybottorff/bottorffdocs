---
title: "Identification of Pathogenic Immune Cell Subsets Associated with Checkpoint Inhibitor-induced Myocarditis"
output: pdf_document
---

 - data mining of https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9397491/
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(ggplot2)
library(dplyr)
library(tidyr)
library(VennDiagram)
library(scales)
library(ggpubr)
library(ComplexHeatmap)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in data

```{r}

feature_df <- read.csv("../saved_data/tcr_seq_features.csv")

feature_df

```

# Prep hydrophobicity calculator

```{r}

# Define the amino acids and their corresponding Eisenberg hydrophobicity values
amino_acids <- c("A", "R", "N", "D", "C", "Q", "E", "G", "H", "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V")
hydrophobicity_values <- c(0.620, -2.530, -0.780, -0.900, 0.290, -0.850, -0.740, 0.480, -0.400, 1.380, 1.060, -1.500, 0.640, 1.190, 0.120, -0.180, -0.050, 0.81, 0.26, 1.08)

# Create a data frame
hydrophobicity_df <- data.frame(Amino_Acid = amino_acids, Hydrophobicity = hydrophobicity_values)

hydrophobicity_df

calculate_hydrophobicity <- function(sequence, hydrophobicity_df) {
  sequence <- toupper(sequence)
  # Calculate the hydrophobicity scores for each amino acid, and sum them
  scores <- sapply(strsplit(sequence, '')[[1]], function(aa) {
    match_aa <- match(aa, hydrophobicity_df$Amino_Acid)
    if (!is.na(match_aa)) {
      return(hydrophobicity_df$Hydrophobicity[match_aa])
    } else {
      # If an amino acid is not found, return NA
      return(NA)
    }
  })
  # If there are any NAs in the scores, return NA; otherwise, return the sum
  if (any(is.na(scores))) {
    return(NA)
  } else {
    return(sum(scores))
  }
}

```

# Import pgen data, join with other data

```{r}

igor_alpha <- read.csv("../saved_data/igor_output_alpha.csv") %>%
  dplyr::rename(TRA_pgen = pgen) %>%
  filter(!(is.na(TRA_pgen)),
         TRA_pgen != "NaN")

combined_data <- read.csv("../saved_data/igor_output_beta.csv") %>%
  dplyr::rename(TRB_pgen = pgen) %>%
  filter(!(is.na(TRB_pgen)),
         TRB_pgen != "NaN") %>%
  full_join(igor_alpha, by = c("TCR_name", "TRA_nt", "TRB_nt", "TRA_aa", "TRB_aa", "TRAV", "TRAJ", "TRA_CDR3", "TRBV", "TRBJ", "TRB_CDR3", "TRAC", "TRBC", "TRA_leader", "TRB_leader", "Linker", "Link_order", "TRA_5_prime_seq", "TRA_3_prime_seq", "TRB_5_prime_seq", "TRB_3_prime_seq", "Linked_nt", "Linked_aa", "Warnings.Errors")) %>%
  select(TCR_name, TRA_CDR3, TRB_CDR3, TRA_pgen, TRB_pgen) %>%
  mutate(TRA_pgen = as.character(TRA_pgen),
         TRB_pgen = as.character(TRB_pgen)) %>%
  pivot_longer(cols = matches("^(TRA|TRB)"),
               names_to = c("Chain", ".value"),
               names_pattern = "^(TRA|TRB)_(.*)$") %>%
  dplyr::rename(barcode = TCR_name,
         cdr3 = CDR3) %>%
  mutate(pgen = as.numeric(pgen)) %>%
  right_join(feature_df, by = c("barcode", "Chain", "cdr3")) %>%
  rowwise() %>%
  mutate(cdr3_hydrophobicity = calculate_hydrophobicity(cdr3, hydrophobicity_df)) %>%
  ungroup()

combined_data

```
  
# Examine patient sampling depth bias

```{r}

seq_depth <- combined_data %>%
  group_by(Patient_ID, irAE) %>%
  summarize(seq_depth = n()) %>%
  arrange(seq_depth) %>%
  print()

seq_depth

# Choose 324 seqs from non B10 samples to downsample all to 324

```

# Downsample

```{r}

desired_rows_per_patient <- 324/2
# /2 to get equal numbers of each chain (TRA and TRB)

set.seed(123)

# Downsample the dataframe
downsampled_df <- combined_data %>%
  group_by(Patient_ID, Chain) %>%
  sample_n(desired_rows_per_patient, replace = FALSE) %>%
  ungroup()

downsampled_df

write.csv(downsampled_df, "../saved_data/downsampled_df.csv")

```

# Look at public vs. private

```{r}

downsampled_public_df_list <- downsampled_df %>%
  group_by(cdr3) %>%
  filter(n_distinct(Patient_ID) > 1) %>%
  mutate(barc_chain = paste(barcode, chain, sep = ""))

downsampled_public_df_list

downsampled_public_df <- downsampled_df %>%
  mutate(barc_chain = paste(barcode, chain, sep = "")) %>%
  filter(barc_chain %in% downsampled_public_df_list$barc_chain,
         predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # look at just unique clonotypes from each patient
  dplyr::slice(1) %>%
  mutate(tag = "Public\n(downsampled)")

downsampled_public_df

public_df_list <- combined_data %>%
  group_by(cdr3) %>%
  filter(n_distinct(Patient_ID) > 1) %>%
  mutate(barc_chain = paste(barcode, chain, sep = ""))

public_df_list

public_df <- combined_data %>%
  mutate(barc_chain = paste(barcode, chain, sep = "")) %>%
  filter(barc_chain %in% public_df_list$barc_chain,
         predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # look at just unique clonotypes from each patient
  dplyr::slice(1) %>%
  mutate(tag = "Public")

public_df

```

# Look at TCR convergence

```{r}

convergence_within_patients <- combined_data %>%
  select(Patient_ID, barcode, Chain, cdr3, cdr3_nt, v_gene, d_gene, j_gene, c_gene) %>%
  group_by(cdr3, Patient_ID) %>%
  filter(n_distinct(cdr3_nt) > 1) %>%
  ungroup()

convergence_within_patients

convergence_across_patients <- combined_data %>%
  mutate(barc_chain = paste(barcode, chain, sep = "")) %>%
  group_by(cdr3) %>%
  mutate(distinct_cdr3_nt_count = n_distinct(cdr3_nt)) %>%
  filter(distinct_cdr3_nt_count > 1)

convergence_across_patients

# do see more convergence across patients as expected, and they are mostly in public TCRs also as expected

convergence_df <- combined_data %>%
  mutate(barc_chain = paste(barcode, chain, sep = "")) %>%
  filter(barc_chain %in% convergence_across_patients$barc_chain,
         predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # look at just unique clonotypes from each patient
  dplyr::slice(1) %>%
  mutate(tag = "Converged")

#convergence_df

```

# Plot donors/junction (AA) (x) vs. donors/junction (nt) (y)

```{r}

donor_df <- combined_data %>%
  mutate(barc_chain = paste(barcode, chain, sep = "")) %>%
  mutate(convergence  = if_else(barc_chain %in% convergence_across_patients$barc_chain, "Converged", "Not converged"),
         publicity = if_else(barc_chain %in% public_df_list$barc_chain, "Public", "Private")) %>%
  group_by(cdr3) %>%
  mutate(donors_per_junction_aa = n_distinct(Patient_ID)) %>%
  ungroup() %>%
  group_by(cdr3_nt) %>%
  mutate(donors_per_junction_nt = n_distinct(Patient_ID)) %>%
  ungroup() %>%
  # look at just unique CDR3s nts from each patient
  group_by(cdr3, cdr3_nt, Patient_ID) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(irAE = paste("irAE:", irAE))

ggplot(donor_df, aes(x = donors_per_junction_aa, y = donors_per_junction_nt, color = convergence)) +
  geom_jitter(size = 0.5) +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  facet_wrap(~irAE, ncol = 4) +
  labs(x = "Donors/junction (AA)", y = "Donors/junction (nt)", color = "Convergence") +
  theme(legend.text = element_text(size = 12),
        legend.title = element_text(size = 14))

ggplot(donor_df, aes(x = donors_per_junction_aa, y = donors_per_junction_nt, color = publicity)) +
  geom_jitter(size = 0.5) +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  facet_wrap(~irAE, ncol = 4) +
  labs(x = "Donors/junction (AA)", y = "Donors/junction (nt)", color = "Publicity") +
  theme(legend.text = element_text(size = 12),
        legend.title = element_text(size = 14))

# how can something be converged on diagonal (on or off (1,1))? I'm pretty sure it's because of intrapatient convergence

```

# Instead look at distribution of unique CDR3 NT seqs / CDR3 (AA) by irAE group

```{r}

new_convergence_df <- combined_data %>%
  group_by(cdr3) %>%
  mutate(nts_per_aa = n_distinct(cdr3_nt)) %>%
  # look at just unique CDR3s from each irAE group (to deal with cases with same CDR3 in both groups, don't want to slice and just have it in 1 group)
  # also don't want to group by patient because then I'd be double counting some CDR3s in group comparisons?
  group_by(cdr3, irAE) %>%
  slice(1) %>%
  ungroup()

new_convergence_df_hist <- new_convergence_df %>%
  group_by(nts_per_aa, irAE, predicted.celltype.l1, predicted.celltype.l2) %>%
  summarize(count = n()) %>%
  ungroup() %>%
  group_by(irAE, predicted.celltype.l1, predicted.celltype.l2) %>%
  mutate(count = count / sum(count))

# Calculate mean values
means <- new_convergence_df_hist %>%
  group_by(predicted.celltype.l1, irAE) %>%
  summarize(mean_val = mean(nts_per_aa))

means

p <- ggplot(new_convergence_df_hist, aes(x = nts_per_aa, y = sqrt(count), fill = irAE)) +
  geom_density(stat = "identity", position = "dodge", alpha = 0.75) +
  facet_wrap(~predicted.celltype.l1) +
  labs(x = "CDR3 NT sequences/\nCDR3 AA sequence", y = "Group normalized\ncount (sqrt)") +
  scale_x_continuous(breaks = pretty_breaks(n = 3))

p + geom_vline(data = means, aes(xintercept = mean_val, color = irAE),
             linetype = "solid", size = 0.5) +
    scale_color_manual(values = c("red", "blue"))  # Adjust colors as needed

#wilcox.test(nts_per_aa ~ irAE, data = new_convergence_df %>% filter(predicted.celltype.l1 == "other T"))
# CD4 T: 0.00062 (padj)
# higher in No irAE

#p.adjust(c(0.0002063, 0.75, 0.1772), method = "BH")

```

# Look at overlap between public and converged

```{r}

# Create a Venn diagram
#venn.plot <- venn.diagram(
#  x = list(A = public_df$barcode, B = convergence_df$barcode),
#  category.names = c("Public TCRs", "Converged TCRs"),
#  filename = NULL,
#  output = TRUE
#)

# Display the Venn diagram
#grid.draw(venn.plot)

```

# Plot germlineness vs. CDR3 length

```{r}

abundance_df <- combined_data %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  mutate(count = n()) %>%
  slice(1) %>%
  ungroup()

abundance_df

ggplot(aes(x = cdr3_length, y = log10(pgen)), data = abundance_df) +
  geom_jitter(alpha = 0.05) +
  labs(y = "log10(pgen)", x = "CDR3 length (AAs)") +
  stat_cor(method = "pearson", label.x = 0.8, label.y = 0.9) +
  geom_smooth(method = "lm", se = FALSE, col = "blue")

```

# Prep data for summary plots (normalized method)

```{r}

prepped_data <- combined_data %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # calculate clonotype counts within patients to get a sense of expansion
  mutate(count = n()) %>%
  # normalize by sequencing depth
  left_join(seq_depth, by = c("Patient_ID", "irAE")) %>%
  mutate(normalized_count = count / seq_depth) %>%
  # look at just unique clonotypes (CDR3 AA - VJ) from each patient
  dplyr::slice(1) %>%
  ungroup() %>%
  group_by(predicted.celltype.l1, predicted.celltype.l2, Chain) %>%
  arrange(-normalized_count) %>%
  mutate(chunk_size = ceiling(n() * 0.1),
         chunk = 10*ceiling(row_number() / chunk_size))

prepped_data

```

# Perform wilcox rank sum tests within chunks of 10% clonotypes (normalized method)

```{r}

# Function to perform the test within a specific bin of clonotype abundances
perform_wilcox_test <- function(data, cutoff) {
  result <- data %>%
    filter(chunk == cutoff) %>%
    group_by(predicted.celltype.l1, predicted.celltype.l2, Chain) %>%    
    summarize(
      p_val_pgen = {
        if(length(unique(irAE)) != 2 | any(table(irAE) == 1)) {
          NA
        } else {
          wilcox.test(pgen ~ irAE, exact = FALSE)$p.value
        }
      },
      p_val_cdr3_hydrophobicity = {
        if(length(unique(irAE)) != 2 | any(table(irAE) == 1)) {
          NA
        } else {
          wilcox.test(cdr3_hydrophobicity ~ irAE, exact = FALSE)$p.value
        }
      },
      p_val_cdr3_length = {
        if(length(unique(irAE)) != 2 | any(table(irAE) == 1)) {
          NA
        } else {
          wilcox.test(cdr3_length ~ irAE, exact = FALSE)$p.value
        }
      }
    ) %>%
    ungroup()
  
  return(result)
}

# List to store results
results_list <- list()

# Iterate through chunk cutoffs
for (num in 1:10) {
  result <- prepped_data %>%
    perform_wilcox_test(cutoff = num*10)

  results_list[[as.character(num*10)]] <- result
}

# Combine results into a single dataframe
results_df <- bind_rows(results_list, .id = "Chunk")

results_df <- results_df %>%
  pivot_longer(cols = c("p_val_pgen", "p_val_cdr3_length", "p_val_cdr3_hydrophobicity"), names_to = "p_val") %>%
  rename(p_val_category = p_val) %>%
  mutate(p_val_category = gsub("p_val_", "", p_val_category)) %>%
  mutate(category = paste(predicted.celltype.l2, Chain, p_val_category)) %>%
  # adjust pvals for multiple comparisons %>%
  mutate(value = p.adjust(value, method = "BH")) %>%
  arrange(value)

results_df

```

# Make heatmap (normalized method, padjusted)

```{r}

top_results <- results_df %>%
  filter(value < 0.05) %>%
  mutate(category = paste(predicted.celltype.l2, Chain, p_val_category))

filtered_results_df <- results_df %>%
  filter(category %in% top_results$category) %>%
  mutate(log_val = -log10(value))

filtered_results_df$Chunk <- factor(filtered_results_df$Chunk, levels = c("10", "20", "30", "40", "50", "60", "70", "80", "90", "100"))

heatmap_df <- filtered_results_df %>%
  select(-value, -category) %>%
  rename(value = log_val) %>%
  mutate(p_val_category = case_when(
    p_val_category == "pgen" ~ "Probability of generation",
    p_val_category == "cdr3_length" ~ "CDR3 length (AAs)",
    p_val_category == "cdr3_hydrophobicity" ~ "CDR3 hydrophobicity"
  )) %>%
  mutate(predicted.celltype.l2 = gsub("CD4 |CD8 ", "", predicted.celltype.l2))

heatmap_df

# Prepare the data in matrix form
heatmap_data <- reshape2::dcast(heatmap_df, predicted.celltype.l1 + predicted.celltype.l2 + p_val_category + Chain ~ Chunk, value.var = "value")

# Extract value columns
mat <- as.matrix(heatmap_data[, -(1:4)])

# Set row names
rownames(mat) <- paste(heatmap_data$predicted.celltype.l1, heatmap_data$predicted.celltype.l2, heatmap_data$p_val_category, heatmap_data$Chain, sep = "_")

# Create a matrix of annotations
chain_annotations <- cbind(
  Chain = heatmap_data$Chain
)

# Create a matrix of annotations
type_annotations <- cbind(
  "Cell type" = heatmap_data$predicted.celltype.l1
)

# Create a matrix of annotations
subtype_annotations <- cbind(
  "Cell subtype" = heatmap_data$predicted.celltype.l2
)

# Create a matrix of annotations
feature_annotations <- cbind(
  Feature = heatmap_data$p_val_category
)

# Plot the heatmap without clustering
Heatmap(mat,
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        row_names_gp = gpar(fontsize = 8),  # Adjust font size if needed
        right_annotation = rowAnnotation("Cell type" = type_annotations,
                                         "Cell subtype" = subtype_annotations,
                                         Chain = chain_annotations,
                                         Feature = feature_annotations,
                                         col = list("Cell type" = c("CD4 T" = "#fde725", "CD8 T" = "#21918c", "other T" = "#440154"),
                                                    "Chain" = c("TRA" = "#fde725", "TRB" = "#440154"),
                                                    "Cell subtype" = c("dnT" = "#440154", "Treg" = "#46327e", "Proliferating" = "#1fa187", "TCM" = "#277f8e",   "TEM" = "#365c8d", "Naive" = "#4ac16d", "MAIT" = "#a0da39", "CTL" = "#fde725"),
                                                    "Feature" = c("CDR3 length (AAs)" = "#21918c", "CDR3 hydrophobicity" = "#fde725", "Probability of generation" = "#440154"))),
        show_row_names = FALSE,
        column_title = "Clonotypes bins\n(% of repertoire across patients)",
        column_title_side = "bottom",
        heatmap_legend_param = list(title = "Wilcox padj val (-log10)\n for yes vs. no irAE"),
        layer_fun = function(j, i, x, y, width, height, fill) {
          v = pindex(mat, i, j)
          l = v > -log10(0.05) & v < -log10(0.01)
          if (any(l)) {
            grid.text("*", x[l], y[l], gp = gpar(fontsize = 10))
          }
          q = v > -log10(0.01)
          if (any(q)) {
            grid.text("**", x[q], y[q], gp = gpar(fontsize = 10))
          }
        }
      )

```
# Prep data for summary plots (downsampled method)

```{r}

prepped_data_downsampled <- downsampled_df %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # calculate clonotype counts within patients to get a sense of expansion
  mutate(count = n()) %>%
  # look at just unique clonotypes (CDR3 AA - VJ) from each patient
  dplyr::slice(1) %>%
  ungroup() %>%
  group_by(predicted.celltype.l1, predicted.celltype.l2, Chain) %>%
  arrange(-count) %>%
  mutate(chunk_size = ceiling(n() * 0.1),
         chunk = 10*ceiling(row_number() / chunk_size))

prepped_data_downsampled

```

# Perform wilcox rank sum tests within chunks of 10% clonotypes (downsampled method)

```{r}

# List to store results
results_list_downsampled <- list()

# Iterate through chunk cutoffs
for (num in 1:10) {
  result <- prepped_data_downsampled %>%
    perform_wilcox_test(cutoff = num*10)

  results_list[[as.character(num*10)]] <- result
}

# Combine results into a single dataframe
results_df_downsampled <- bind_rows(results_list, .id = "Chunk")

results_df_downsampled <- results_df_downsampled %>%
  pivot_longer(cols = c("p_val_pgen", "p_val_cdr3_length", "p_val_cdr3_hydrophobicity"), names_to = "p_val") %>%
  rename(p_val_category = p_val) %>%
  mutate(p_val_category = gsub("p_val_", "", p_val_category)) %>%
  mutate(category = paste(predicted.celltype.l2, Chain, p_val_category)) %>%
  # adjust pvals for multiple comparisons %>%
  mutate(value = p.adjust(value, method = "BH")) %>%
  arrange(value)

results_df_downsampled

```

# Make heatmap (downsampled method)

```{r}

top_results_downsampled <- results_df_downsampled %>%
  mutate(category = paste(predicted.celltype.l2, Chain, p_val_category))

filtered_results_df_downsampled <- results_df_downsampled %>%
  filter(category %in% top_results_downsampled$category) %>%
  mutate(log_val = -log10(value))

filtered_results_df_downsampled$Chunk <- factor(filtered_results_df_downsampled$Chunk, levels = c("10", "20", "30", "40", "50", "60", "70", "80", "90", "100"))

heatmap_df_downsampled <- filtered_results_df_downsampled %>%
  select(-value, -category) %>%
  rename(value = log_val) %>%
  mutate(p_val_category = case_when(
    p_val_category == "pgen" ~ "Probability of generation",
    p_val_category == "cdr3_length" ~ "CDR3 length (AAs)",
    p_val_category == "cdr3_hydrophobicity" ~ "CDR3 hydrophobicity"
  )) %>%
  mutate(predicted.celltype.l2 = gsub("CD4 |CD8 ", "", predicted.celltype.l2))

heatmap_df_downsampled

# Prepare the data in matrix form
heatmap_data_downsampled <- reshape2::dcast(heatmap_df_downsampled, predicted.celltype.l1 + predicted.celltype.l2 + p_val_category + Chain ~ Chunk, value.var = "value")

# Extract value columns
mat_downsampled <- as.matrix(heatmap_data_downsampled[, -(1:4)])

# Set row names
rownames(mat_downsampled) <- paste(heatmap_data_downsampled$predicted.celltype.l1, heatmap_data_downsampled$predicted.celltype.l2, heatmap_data_downsampled$p_val_category, heatmap_data_downsampled$Chain, sep = "_")

# Create a matrix of annotations
chain_annotations_downsampled <- cbind(
  Chain = heatmap_data_downsampled$Chain
)

# Create a matrix of annotations
type_annotations_downsampled <- cbind(
  "Cell type" = heatmap_data_downsampled$predicted.celltype.l1
)

# Create a matrix of annotations
subtype_annotations_downsampled <- cbind(
  "Cell subtype" = heatmap_data_downsampled$predicted.celltype.l2
)

# Create a matrix of annotations
feature_annotations_downsampled <- cbind(
  Feature = heatmap_data_downsampled$p_val_category
)

# Plot the heatmap without clustering
Heatmap(mat_downsampled,
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        row_names_gp = gpar(fontsize = 8),  # Adjust font size if needed
        right_annotation = rowAnnotation("Cell type" = type_annotations_downsampled,
                                         "Cell subtype" = subtype_annotations_downsampled,
                                         Chain = chain_annotations_downsampled,
                                         Feature = feature_annotations_downsampled,
                                         col = list("Cell type" = c("CD4 T" = "#fde725", "CD8 T" = "#21918c", "other T" = "#440154"),
                                                    "Chain" = c("TRA" = "#fde725", "TRB" = "#440154"),
                                                    "Cell subtype" = c("dnT" = "#440154", "Treg" = "#46327e", "Proliferating" = "#1fa187", "TCM" = "#277f8e",   "TEM" = "#365c8d", "Naive" = "#4ac16d", "MAIT" = "#a0da39", "CTL" = "#fde725"),
                                                    "Feature" = c("CDR3 length (AAs)" = "#21918c", "CDR3 hydrophobicity" = "#fde725", "Probability of generation" = "#440154"))),
        show_row_names = FALSE,
        column_title = "Clonotypes bins\n(% of repertoire across patients)",
        column_title_side = "bottom",
        heatmap_legend_param = list(title = "Wilcox p val (-log10)\n for yes vs. no irAE"))

```