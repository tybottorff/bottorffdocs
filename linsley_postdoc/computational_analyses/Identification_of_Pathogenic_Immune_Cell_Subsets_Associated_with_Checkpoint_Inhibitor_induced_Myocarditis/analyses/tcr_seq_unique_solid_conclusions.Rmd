---
title: "Identification of Pathogenic Immune Cell Subsets Associated with Checkpoint Inhibitor-induced Myocarditis"
output: pdf_document
---

 - data mining of https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9397491/
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(ggplot2)
library(dplyr)
library(tidyr)
library(VennDiagram)
library(scales)
library(ggpubr)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in data

```{r}

feature_df <- read.csv("../saved_data/tcr_seq_features.csv")

feature_df

```

# Import pgen data, join with other data

```{r}

igor_alpha <- read.csv("../saved_data/igor_output_alpha.csv") %>%
  dplyr::rename(TRA_pgen = pgen) %>%
  filter(!(is.na(TRA_pgen)),
         TRA_pgen != "NaN")

combined_data <- read.csv("../saved_data/igor_output_beta.csv") %>%
  dplyr::rename(TRB_pgen = pgen) %>%
  filter(!(is.na(TRB_pgen)),
         TRB_pgen != "NaN") %>%
  full_join(igor_alpha, by = c("TCR_name", "TRA_nt", "TRB_nt", "TRA_aa", "TRB_aa", "TRAV", "TRAJ", "TRA_CDR3", "TRBV", "TRBJ", "TRB_CDR3", "TRAC", "TRBC", "TRA_leader", "TRB_leader", "Linker", "Link_order", "TRA_5_prime_seq", "TRA_3_prime_seq", "TRB_5_prime_seq", "TRB_3_prime_seq", "Linked_nt", "Linked_aa", "Warnings.Errors")) %>%
  select(TCR_name, TRA_CDR3, TRB_CDR3, TRA_pgen, TRB_pgen) %>%
  mutate(TRA_pgen = as.character(TRA_pgen),
         TRB_pgen = as.character(TRB_pgen)) %>%
  pivot_longer(cols = matches("^(TRA|TRB)"),
               names_to = c("Chain", ".value"),
               names_pattern = "^(TRA|TRB)_(.*)$") %>%
  dplyr::rename(barcode = TCR_name,
         cdr3 = CDR3) %>%
  mutate(pgen = as.numeric(pgen)) %>%
  right_join(feature_df, by = c("barcode", "Chain", "cdr3"))

combined_data

```
  
# Examine patient sampling depth bias

```{r}

seq_depth <- combined_data %>%
  group_by(Patient_ID, irAE) %>%
  summarize(seq_depth = n()) %>%
  arrange(seq_depth) %>%
  print()

seq_depth

# Choose 324 seqs from non B10 samples to downsample all to 324

```

# Downsample

```{r}

desired_rows_per_patient <- 324/2
# /2 to get equal numbers of each chain (TRA and TRB)

set.seed(123)

# Downsample the dataframe
downsampled_df <- combined_data %>%
  group_by(Patient_ID, Chain) %>%
  sample_n(desired_rows_per_patient, replace = FALSE) %>%
  ungroup()

downsampled_df

```

# Look at public vs. private

```{r}

downsampled_public_df_list <- downsampled_df %>%
  group_by(cdr3, v_gene, j_gene, c_gene) %>%
  filter(n_distinct(Patient_ID) > 1) %>%
  mutate(clonotype = paste(cdr3, v_gene, j_gene, c_gene, sep = ""))

downsampled_public_df_list

downsampled_public_df <- downsampled_df %>%
  mutate(clonotype = paste(cdr3, v_gene, j_gene, c_gene, sep = "")) %>%
  filter(clonotype %in% downsampled_public_df_list$clonotype,
         predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # look at just unique TCRs
  dplyr::slice(1) %>%
  mutate(tag = "Public\n(downsampled)")

downsampled_public_df

public_df_list <- combined_data %>%
  group_by(cdr3, v_gene, j_gene, c_gene) %>%
  filter(n_distinct(Patient_ID) > 1) %>%
  mutate(clonotype = paste(cdr3, v_gene, j_gene, c_gene, sep = ""))

public_df_list

public_df <- combined_data %>%
  mutate(clonotype = paste(cdr3, v_gene, j_gene, c_gene, sep = "")) %>%
  filter(clonotype %in% public_df_list$clonotype,
         predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # look at just unique TCRs
  dplyr::slice(1) %>%
  mutate(tag = "Public")

public_df

```

# Look at TCR convergence

```{r}

convergence_within_patients <- combined_data %>%
  select(Patient_ID, barcode, Chain, cdr3, cdr3_nt, v_gene, d_gene, j_gene, c_gene) %>%
  group_by(cdr3, Patient_ID, v_gene) %>%
  filter(n_distinct(cdr3_nt) > 1) %>%
  ungroup() %>%
  group_by(Patient_ID, cdr3, cdr3_nt) %>%
  summarize(count = n())

convergence_across_patients <- combined_data %>%
  mutate(clonotype = paste(cdr3, v_gene, j_gene, c_gene, sep = "")) %>%
  group_by(cdr3, v_gene) %>%
  mutate(distinct_cdr3_nt_count = n_distinct(cdr3_nt)) %>%
  filter(distinct_cdr3_nt_count > 1)

convergence_across_patients

# do see more convergence across patients as expected, and they are mostly in public TCRs also as expected

convergence_df <- combined_data %>%
  mutate(clonotype = paste(cdr3, v_gene, j_gene, c_gene, sep = "")) %>%
  filter(clonotype %in% convergence_across_patients$clonotype,
         predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # look at just unique TCRs
  dplyr::slice(1) %>%
  mutate(tag = "Converged")

convergence_df

```

# Check convergence degree by irAE group

```{r}

irae_convergence_df <- convergence_across_patients %>%
  select(barcode, Chain, cdr3, predicted.celltype.l1, predicted.celltype.l2, irAE, cdr3_nt, distinct_cdr3_nt_count, clonotype) %>%
  group_by(clonotype) %>%
  slice(1)

irae_convergence_df

p <- ggplot(irae_convergence_df, aes(x = predicted.celltype.l1, y = log10(distinct_cdr3_nt_count), fill = irAE)) +
  geom_boxplot() +
  labs(x = "", fill = "irAE", y = "Distinct CDR3 nt\ncount (log10)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12))

# Adjust y-axis scales with a specified number of ticks
p + scale_y_continuous(expand = expansion(mult = c(0.1, 0.5)), breaks = pretty_breaks(n = 3))

```

# Plot donors/junction (AA) (x) vs. donors/junction (nt) (y)

```{r}

donor_df <- combined_data %>%
  select(barcode, Chain, cdr3, cdr3_nt, Patient_ID, predicted.celltype.l1, predicted.celltype.l2, irAE, v_gene, j_gene, c_gene) %>%
  group_by(cdr3) %>%
  mutate(donors_per_junction_aa = n_distinct(Patient_ID)) %>%
  ungroup() %>%
  group_by(cdr3_nt) %>%
  mutate(donors_per_junction_nt = n_distinct(Patient_ID)) %>%
  ungroup() %>%
  group_by(Patient_ID, cdr3, Chain, v_gene, j_gene) %>%
  mutate(count = n()) %>%
  left_join(seq_depth, by = c("Patient_ID", "irAE")) %>%
  mutate(normalized_count = count / seq_depth) %>%
  ungroup() %>%
  # look at just unique CDR3 nt seqs
  group_by(cdr3_nt) %>%
  slice(1) %>%
  ungroup() %>%
  arrange(-normalized_count) %>%
  group_by(predicted.celltype.l1, Chain, irAE) %>%
  mutate(tag = if_else(row_number() <= 15, "Highly\nexpanded", "Not highly\nexpanded")) %>%
  ungroup() %>%
  mutate(irAE = paste("irAE:", irAE))

donor_df

ggplot(donor_df, aes(x = donors_per_junction_aa, y = donors_per_junction_nt)) +
  geom_point(alpha = 0.25) +
  geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
  facet_wrap(~tag + irAE, ncol = 4) +
  labs(x = "Donors/junction (AA)", y = "Donors/junction (nt)")

```

# Look at overlap between public and converged

```{r}

# Create a Venn diagram
venn.plot <- venn.diagram(
  x = list(A = public_df$barcode, B = convergence_df$barcode),
  category.names = c("Public TCRs", "Converged TCRs"),
  filename = NULL,
  output = TRUE
)

# Display the Venn diagram
grid.draw(venn.plot)

```

# Get unique CD8 TEMs TRBs from top 15 clonotypes per irAE group (normalizing counts by seq depth)

```{r}

unique_cd8_tem_trb <- combined_data %>%
  filter(predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # calculate clonotype counts within patients to get a sense of expansion
  mutate(count = n()) %>%
  # normalize by sequencing depth
  left_join(seq_depth, by = c("Patient_ID", "irAE")) %>%
  mutate(normalized_count = count / seq_depth) %>%
  # look at just unique TCRs
  dplyr::slice(1) %>%
  arrange(-normalized_count) %>%
  ungroup() %>%
  mutate(tag = "All")

unique_cd8_tem_trb

unique_cd8_tem_trb_top_15 <- unique_cd8_tem_trb %>%
  group_by(predicted.celltype.l1, Chain, irAE) %>%
  filter(row_number() <= 15) %>%
  ungroup() %>%
  mutate(tag = "Top 15 clonotypes\n(normalized)")

unique_cd8_tem_trb_top_15

```

# Get unique CD8 TEMs TRBs from top 15 clonotypes per irAE group (not normalizing counts by seq depth)

```{r}

unique_cd8_tem_trb_top_15_not_normalized <- combined_data %>%
  filter(predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # calculate clonotype counts within patients to get a sense of expansion
  mutate(count = n()) %>%
  # look at just unique TCRs
  dplyr::slice(1) %>%
  arrange(-count) %>%
  ungroup() %>%
  group_by(predicted.celltype.l1, Chain, irAE) %>%
  filter(row_number() <= 15) %>%
  ungroup() %>%
  mutate(tag = "Top 15 clonotypes\n(not normalized)")

unique_cd8_tem_trb_top_15_not_normalized

```

# Get unique CD8 TEMs TRBs from top 15 clonotypes per irAE group from downsampled data

```{r}

unique_cd8_tem_trb_downsampled <- downsampled_df %>%
  filter(predicted.celltype.l1 == "CD8 T",
         predicted.celltype.l2 == "CD8 TEM",
         Chain == "TRB") %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # calculate clonotype counts within patients to get a sense of expansion
  mutate(count = n()) %>%
  # look at just unique TCRs
  dplyr::slice(1) %>%
  arrange(-count) %>%
  ungroup() %>%
  mutate(tag = "Downsampled")

unique_cd8_tem_trb_downsampled

unique_cd8_tem_trb_top_15_downsampled <- unique_cd8_tem_trb_downsampled %>%
  group_by(predicted.celltype.l1, Chain, irAE) %>%
  filter(row_number() <= 15) %>%
  ungroup() %>%
  mutate(tag = "Top 15 clonotypes\n(downsampled)")

unique_cd8_tem_trb_top_15_downsampled

```

# Join dfs

```{r}

unique_cd8_tem_trb_all <- unique_cd8_tem_trb_top_15 %>%
  full_join(unique_cd8_tem_trb) %>%
  full_join(unique_cd8_tem_trb_top_15_not_normalized) %>%
  full_join(unique_cd8_tem_trb_top_15_downsampled) %>%
  full_join(unique_cd8_tem_trb_downsampled) %>%
  full_join(public_df) %>%
  full_join(downsampled_public_df) %>%
  full_join(convergence_df)

```

# Plot pgen conclusions

```{r}

unique_cd8_tem_trb_all$tag <- factor(unique_cd8_tem_trb_all$tag, levels = c("Top 15 clonotypes\n(normalized)", "Top 15 clonotypes\n(not normalized)", "Top 15 clonotypes\n(downsampled)", "Converged", "Public", "Public\n(downsampled)", "All", "Downsampled"))

p <- ggplot(unique_cd8_tem_trb_all, aes(x = tag, y = log10(pgen), fill = irAE)) +
  geom_boxplot() +
  labs(x = "", fill = "irAE", y = "CD8 TEM\nTRB pgen (log10)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12))

# Adjust y-axis scales with a specified number of ticks
p + scale_y_continuous(expand = expansion(mult = c(0.1, 0.5)), breaks = pretty_breaks(n = 3))

# Filter the data for statistical test
test_data <- unique_cd8_tem_trb_all %>%
  filter(tag == "Converged")

# Calculate the Wilcoxon rank-sum test statistic and p-value
wilcox_result <- wilcox.test(test_data$pgen ~ test_data$irAE)

# Print the results
print(wilcox_result)

# top 15 (normalized): 0.03
# top 15 (not normalized): 0.02
# top 15 (downsampled): 0.06
# public (downsampled): 0.06

p_values <- c(0.03, 0.02, 0.06)

# Adjust p-values using Benjamini-Hochberg procedure
adjusted_p_values <- p.adjust(p_values, method = "BH")

# Display the original and adjusted p-values
data.frame(original_p_values = p_values, adjusted_p_values = adjusted_p_values)

```

# Plot length conclusions

```{r}

p <- ggplot(unique_cd8_tem_trb_all, aes(x = tag, y = (cdr3_length), fill = irAE)) +
  geom_boxplot() +
  labs(x = "", fill = "irAE", y = "CD8 TEM\ TRB\nCDR3 length (AAs)") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12))

# Adjust y-axis scales with a specified number of ticks
p + scale_y_continuous(expand = expansion(mult = c(0.1, 0.5)), breaks = pretty_breaks(n = 3))

# Filter the data for statistical test
test_data <- unique_cd8_tem_trb_all %>%
  filter(tag == "Public\n(downsampled)")

# Calculate the Wilcoxon rank-sum test statistic and p-value
wilcox_result <- wilcox.test(test_data$cdr3_length ~ test_data$irAE)

# Print the results
print(wilcox_result)

# top 15 (not normalized): 0.009

```

# Plot germlineness vs. CDR3 length

```{r}

ggplot(aes(x = cdr3_length, y = log10(pgen)), data = combined_data) +
  geom_point() +
  labs(y = "log10(pgen)", x = "CDR3 length (AAs)") +
  stat_cor(method = "pearson", label.x = 0.8, label.y = 0.9)

```

# Plot abundance vs. CDR3 length or pgen

```{r}

abundance_df <- combined_data %>%
  group_by(Patient_ID, cdr3_nt, chain, v_gene, j_gene) %>%
  mutate(count = n()) %>%
  slice(1) %>%
  ungroup() %>%
  select(predicted.celltype.l1, predicted.celltype.l2, count, Patient_ID, irAE, barcode, Chain, cdr3, cdr3_length, pgen) %>%
  mutate(irAE = paste("irAE:", irAE))

abundance_df

# Plot with best-fit liness
ggplot(abundance_df %>% filter(predicted.celltype.l1 == "CD8 T" & Chain == "TRB"),
       aes(x = log10(count), y = cdr3_length)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = FALSE, col = "blue") +
  facet_wrap(~ irAE, scales = "free_y") +
  labs(x = "CD8 TRB clonotype abundance (log10)", fill = "irAE", y = "CD8 TRB CDR3 length") +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.5)), breaks = pretty_breaks(n = 3))

# Plot with best-fit lines
ggplot(abundance_df %>% filter(predicted.celltype.l1 == "CD8 T" & Chain == "TRB"),
       aes(x = log10(count), y = log10(pgen))) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = FALSE, col = "blue") +
  facet_wrap(~ irAE, scales = "free_y") +
  labs(x = "CD8 TRB clonotype abundance (log10)", fill = "irAE", y = "CD8 TRB pgen (log10)") +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.5)), breaks = pretty_breaks(n = 3))

```

# Plot abundance vs. CDR3 length or pgen just for public TCRs

 - now trends are not what I see for highly expanded

```{r}

abundance_df_public <- combined_data %>%
  group_by(cdr3, v_gene, j_gene, c_gene) %>%
  filter(n_distinct(Patient_ID) > 1) %>%
  ungroup() %>%
  group_by(Patient_ID, cdr3_nt, chain, v_gene, j_gene) %>%
  mutate(count = n()) %>%
  slice(1) %>%
  ungroup() %>%
  select(predicted.celltype.l1, predicted.celltype.l2, count, Patient_ID, irAE, barcode, Chain, cdr3, cdr3_length, pgen) %>%
  mutate(irAE = paste("irAE:", irAE))

abundance_df_public

# Plot with best-fit liness
ggplot(abundance_df_public %>% filter(predicted.celltype.l1 == "CD8 T" & Chain == "TRB"),
       aes(x = (count), y = cdr3_length)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = FALSE, col = "blue") +
  facet_wrap(~ irAE, scales = "free_y") +
  labs(x = "CD8 TRB clonotype abundance (log10)", fill = "irAE", y = "CD8 TRB CDR3 length") +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.5)), breaks = pretty_breaks(n = 3))

# Plot with best-fit lines
ggplot(abundance_df_public %>% filter(predicted.celltype.l1 == "CD8 T" & Chain == "TRB"),
       aes(x = (count), y = log10(pgen))) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", se = FALSE, col = "blue") +
  facet_wrap(~ irAE, scales = "free_y") +
  labs(x = "CD8 TRB clonotype abundance (log10)", fill = "irAE", y = "CD8 TRB pgen (log10)") +
  scale_y_continuous(expand = expansion(mult = c(0.1, 0.5)), breaks = pretty_breaks(n = 3))

```

# Prep data for summary plots

```{r}

prepped_data <- combined_data %>%
  group_by(Patient_ID, cdr3, chain, v_gene, j_gene) %>%
  # calculate clonotype counts within patients to get a sense of expansion
  mutate(count = n()) %>%
  # normalize by sequencing depth
  left_join(seq_depth, by = c("Patient_ID", "irAE")) %>%
  mutate(normalized_count = count / seq_depth) %>%
  # look at just unique TCRs
  dplyr::slice(1) %>%
  arrange(-normalized_count) %>%
  ungroup()
  
prepped_data

size_df <- prepped_data %>%
  filter(irAE == "Yes") %>%
  group_by(Chain, predicted.celltype.l1, predicted.celltype.l2) %>%
  summarize(count = n())

size_df

```

# Perform wilcox rank sum tests for top n clonotypes

```{r}

# Function to perform the test for a specific row number
perform_wilcox_test <- function(data, row_num) {
  data %>%
    group_by(predicted.celltype.l1, predicted.celltype.l2, Chain, irAE) %>%
    filter(row_number() <= row_num) %>%
    ungroup() %>%
    group_by(predicted.celltype.l1, predicted.celltype.l2, Chain) %>%    
    summarize(p_val_pgen = wilcox.test(pgen ~ irAE)$p.value,
              p_val_cdr3_length = wilcox.test(cdr3_length ~ irAE)$p.value,
              top_n_clonotypes = row_num) %>%
    ungroup()
}

# List to store results
results_list <- list()

# Iterate through row numbers (1:1, 1:2, ..., 1:50)
for (row_num in 2:5231) {
  result <- prepped_data %>%
    perform_wilcox_test(row_num = row_num)

  results_list[[as.character(row_num)]] <- result
}

# Combine results into a single dataframe
results_df <- bind_rows(results_list, .id = "Row_Number")

results_df

```

# Reformat df

```{r}

reformatted_df <- results_df %>%
  select(-Row_Number) %>%
  left_join(size_df, by = c("predicted.celltype.l1", "predicted.celltype.l2", "Chain")) %>%
  group_by(predicted.celltype.l1, predicted.celltype.l2, Chain) %>%
  filter(top_n_clonotypes <= count) %>%
  mutate(top_n_clonotypes_perc = top_n_clonotypes/count * 100) %>%
  pivot_longer(cols = c("p_val_pgen", "p_val_cdr3_length"), names_to = "p_val_category") %>%
  mutate(p_val_category = gsub("p_val_", "", p_val_category))

reformatted_df

```

# Create summary plot of p values of yes/no irAE group comparisons across all top n clonotype splits for all cell (sub)types, chains, features

```{r}

ggplot(reformatted_df %>% filter(predicted.celltype.l1 == "CD8 T" & predicted.celltype.l2 == "CD8 TEM"), aes(x = top_n_clonotypes_perc, y = value)) +
  geom_point(size = 0.01) +
  geom_hline(yintercept = 0.05, linetype = "dashed", color = "red") +
  facet_wrap(~Chain + p_val_category, ncol = 2) +
  labs(x = "Top repertoire (%, normalized\nfor sequencing depth)", y = "Wilcox p val for yes\nvs. no irAE") +
  scale_y_continuous(trans = 'log10') +
  scale_x_continuous(trans = 'log10')

```