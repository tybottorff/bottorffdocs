---
title: "Identification of Pathogenic Immune Cell Subsets Associated with Checkpoint Inhibitor-induced Myocarditis"
output: pdf_document
---

 - data mining of https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9397491/
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(Seurat)
library(Matrix)
library(ggplot2)
library(dplyr)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in non-control data

```{r}

# List of sample names
sample_names <- c(
"A10-B10-MCE12-MCE13-filtered_feature_bc_matrix", "B2-filtered_feature_bc_matrix", "A1-filtered_feature_bc_matrix", "B3-filtered_feature_bc_matrix", "A2-filtered_feature_bc_matrix", "A3-filtered_feature_bc_matrix", "MCE1-filtered_feature_bc_matrix", "A5-B14-MCL15-filtered_feature_bc_matrix", "MCE2-filtered_feature_bc_matrix", "A6-A9-B13-B9-filtered_feature_bc_matrix", "MCL1-filtered_feature_bc_matrix", "A8-B11-filtered_feature_bc_matrix", "MCL3-filtered_feature_bc_matrix", "B12-NCE6-NCE7-filtered_feature_bc_matrix", "B1-filtered_feature_bc_matrix"
)

output_dir = "../raw_data/"

# Create Seurat objects for each sample
heart_t_cells_objects <- list()

for (sample_name in sample_names) {
  # Construct file paths
  counts_file <- paste0(output_dir, sample_name, "/matrix.mtx.gz")
  barcodes_file <- paste0(output_dir, sample_name, "/barcodes.tsv.gz")
  genes_file <- paste0(output_dir, sample_name, "/features.tsv.gz")
  
  # Read data files
  counts <- readMM(counts_file)
  barcodes <- read.table(barcodes_file, stringsAsFactors = FALSE)[, 1]
  features <- read.csv(genes_file, stringsAsFactors = FALSE, sep = "\t", header = FALSE)
  rownames(counts) <- make.unique(features[, 2])
  colnames(counts) <- barcodes
  
  # Create Seurat object
  heart_t_cells <- CreateSeuratObject(counts, project = sample_name)
  
  # Store Seurat object in the list
  heart_t_cells_objects[[sample_name]] <- heart_t_cells
}

new_object_names <- lapply(names(heart_t_cells_objects), function(name) {
  new_name <- gsub("-filtered_feature_bc_matrix$", "", name)
  return(new_name)
})

# Rename the objects in the list
names(heart_t_cells_objects) <- new_object_names

```

# Dehash A10-B10-MCE12-MCE13 sample, remove multiplets/0-lets

```{r}

# A10 (Group A, Hash3-TotalSeqC), B10 (Group B, Hash4-TotalSeqC), MCE12 (Group C, Hash1-TotalSeqC), MCE13 (Group C, Hash2-TotalSeqC)

dehash_1 <- heart_t_cells_objects[["A10-B10-MCE12-MCE13"]]

hash_features_dehash_1 <- subset(dehash_1, features = c("Hash1-TotalSeqC", "Hash2-TotalSeqC", "Hash3-TotalSeqC", "Hash4-TotalSeqC"))

hash_counts_1 <- as_tibble(hash_features_dehash_1@assays$RNA@data)

# Convert each row into a list
row_list <- lapply(1:nrow(hash_counts_1), function(i) unlist(hash_counts_1[i, ]))
# Now row_list is a list where each element is a vector containing the values of a row

cutoff_list_1 <- c()

# Apply a function to each row in the list
for (row in row_list) {
  percentile_1_75 <- quantile(row, probs = 0.75)
  cutoff_list_1 <- c(cutoff_list_1, percentile_1_75)
}

hash_counts_1$hash = c("Hash1-TotalSeqC", "Hash2-TotalSeqC", "Hash3-TotalSeqC", "Hash4-TotalSeqC")
hash_counts_1$cutoffs = cutoff_list_1

hash_calls_1 <- hash_counts_1 %>%
  mutate(across(-c(hash, cutoffs), ~ ifelse(. > cutoffs, 1, 0)))
  #1 is pass, 0 is fail

# Count the number of "pass" values in each column
pass_counts_1 <- colSums(hash_calls_1[, !(colnames(hash_calls_1) %in% c("hash", "cutoffs"))])

hist(pass_counts_1, main = "Histogram of Column Sums", xlab = "Sum of 'pass' Values")

# Identify columns with sum equal to 1
cols_to_keep <- which(pass_counts_1 == 1)

# Subset the data frame to keep only the columns with sum equal to 1
hash_calls_subsetted_1 <- hash_calls_1[, c(colnames(hash_calls_1)[cols_to_keep], "hash")]

# Find the row number of the pass (1) value for each barcode column
pass_row_numbers_1 <- apply(hash_calls_subsetted_1[, -ncol(hash_calls_subsetted_1)], 2, which.max)

# Create a new data frame with the hash values for the pass in each barcode column
hash_calls_named_1 <- data.frame(
 Barcode = colnames(hash_calls_subsetted_1)[-ncol(hash_calls_subsetted_1)],  # All barcode column names
  Hash = hash_calls_subsetted_1[pass_row_numbers_1, "hash"]  # Corresponding hash values
)

hash_calls_named_1 <- hash_calls_named_1 %>%
  mutate(
    orig.ident = case_when(
      hash == "Hash3-TotalSeqC" ~ "A10",
      hash == "Hash4-TotalSeqC" ~ "B10",
      hash == "Hash1-TotalSeqC" ~ "MCE12",
      hash == "Hash2-TotalSeqC" ~ "MCE13"))

rownames(hash_calls_named_1) <- hash_calls_named_1$Barcode

hash_calls_named_1 <- hash_calls_named_1 %>%
  select(-Barcode)

# subset hashed Seurat object to remove non-single hash calls
dehash_1_subset <- subset(dehash_1, cells = rownames(hash_calls_named_1))

dehash_1_subset <- AddMetaData(object = dehash_1_subset, metadata = hash_calls_named_1)

dehash_1_split <- SplitObject(dehash_1_subset, split.by = "orig.ident")

heart_t_cells_objects[["A10-B10-MCE12-MCE13"]] <- NULL

heart_t_cells_objects <- c(heart_t_cells_objects, dehash_1_split)

```

# Dehash B12-MCE6-MCE7 sample, remove multiplets/0-lets

```{r}

# B12 (Group B, Hash4-TotalSeqC), MCE6 (Group C, Hash 1-TotalSeqC), MCE7 (Group C, Hash2-TotalSeqC)

dehash_2 <- heart_t_cells_objects[["B12-NCE6-NCE7"]]

hash_features_dehash_2 <- subset(dehash_2, features = c("Hash1-TotalSeqC", "Hash2-TotalSeqC", "Hash4-TotalSeqC"))

hash_counts_2 <- as_tibble(hash_features_dehash_2@assays$RNA@data)

# Convert each row into a list
row_list <- lapply(1:nrow(hash_counts_2), function(i) unlist(hash_counts_2[i, ]))
# Now row_list is a list where each element is a vector containing the values of a row

cutoff_list_2 <- c()

# Apply a function to each row in the list
for (row in row_list) {
  percentile_2_65 <- quantile(row, probs = 0.65)
  cutoff_list_2 <- c(cutoff_list_2, percentile_2_65)
}

hash_counts_2$hash = c("Hash1-TotalSeqC", "Hash2-TotalSeqC", "Hash4-TotalSeqC")
hash_counts_2$cutoffs = cutoff_list_2

hash_calls_2 <- hash_counts_2 %>%
  mutate(across(-c(hash, cutoffs), ~ ifelse(. > cutoffs, 1, 0)))
  #1 is pass, 0 is fail

# Count the number of "pass" values in each column
pass_counts_2 <- colSums(hash_calls_2[, !(colnames(hash_calls_2) %in% c("hash", "cutoffs"))])

hist(pass_counts_2, main = "Histogram of Column Sums", xlab = "Sum of 'pass' Values")

# Identify columns with sum equal to 1
cols_to_keep <- which(pass_counts_2 == 1)

# Subset the data frame to keep only the columns with sum equal to 1
hash_calls_subsetted_2 <- hash_calls_2[, c(colnames(hash_calls_2)[cols_to_keep], "hash")]

# Find the row number of the pass (1) value for each barcode column
pass_row_numbers_2 <- apply(hash_calls_subsetted_2[, -ncol(hash_calls_subsetted_2)], 2, which.max)

# Create a new data frame with the hash values for the pass in each barcode column
hash_calls_named_2 <- data.frame(
  Barcode = colnames(hash_calls_subsetted_2)[-ncol(hash_calls_subsetted_2)],  # All barcode column names
  Hash = hash_calls_subsetted_2[pass_row_numbers_2, "hash"]  # Corresponding hash values
)

hash_calls_named_2 <- hash_calls_named_2 %>%
  mutate(
    orig.ident = case_when(
      hash == "Hash4-TotalSeqC" ~ "B12",
      hash == "Hash1-TotalSeqC" ~ "MCE6",
      hash == "Hash2-TotalSeqC" ~ "MCE7"))

rownames(hash_calls_named_2) <- hash_calls_named_2$Barcode

hash_calls_named_2 <- hash_calls_named_2 %>%
  select(-Barcode)

# subset hashed Seurat object to remove non-single hash calls
dehash_2_subset <- subset(dehash_2, cells = rownames(hash_calls_named_2))

dehash_2_subset <- AddMetaData(object = dehash_2_subset, metadata = hash_calls_named_2)

dehash_2_split <- SplitObject(dehash_2_subset, split.by = "orig.ident")

heart_t_cells_objects[["B12-NCE6-NCE7"]] <- NULL

heart_t_cells_objects <- c(heart_t_cells_objects, dehash_2_split)

```

# Dehash A8-B11 sample, remove multiplets/0-lets

```{r}

# A8 (Group A, Hash4-TotalSeqC), B11 (Group B, Hash3-TotalSeqC)

dehash_3 <- heart_t_cells_objects[["A8-B11"]]

hash_features_dehash_3 <- subset(dehash_3, features = c("Hash3-TotalSeqC", "Hash4-TotalSeqC"))

hash_counts_3 <- as_tibble(hash_features_dehash_3@assays$RNA@data)

# Convert each row into a list
row_list <- lapply(1:nrow(hash_counts_3), function(i) unlist(hash_counts_3[i, ]))
# Now row_list is a list where each element is a vector containing the values of a row

cutoff_list_3 <- c()

# Apply a function to each row in the list
for (row in row_list) {
  percentile_3_60 <- quantile(row, probs = 0.60)
  cutoff_list_3 <- c(cutoff_list_3, percentile_3_60)
}

hash_counts_3$hash = c("Hash3-TotalSeqC", "Hash4-TotalSeqC")
hash_counts_3$cutoffs = cutoff_list_3

hash_calls_3 <- hash_counts_3 %>%
  mutate(across(-c(hash, cutoffs), ~ ifelse(. > cutoffs, 1, 0)))
  #1 is pass, 0 is fail

# Count the number of "pass" values in each column
pass_counts_3 <- colSums(hash_calls_3[, !(colnames(hash_calls_3) %in% c("hash", "cutoffs"))])

hist(pass_counts_3, main = "Histogram of Column Sums", xlab = "Sum of 'pass' Values")

# Identify columns with sum equal to 1
cols_to_keep <- which(pass_counts_3 == 1)

# Subset the data frame to keep only the columns with sum equal to 1
hash_calls_subsetted_3 <- hash_calls_3[, c(colnames(hash_calls_3)[cols_to_keep], "hash")]

# Find the row number of the pass (1) value for each barcode column
pass_row_numbers_3 <- apply(hash_calls_subsetted_3[, -ncol(hash_calls_subsetted_3)], 2, which.max)

# Create a new data frame with the hash values for the pass in each barcode column
hash_calls_named_3 <- data.frame(
  Barcode = colnames(hash_calls_subsetted_3)[-ncol(hash_calls_subsetted_3)],  # All barcode column names
  Hash = hash_calls_subsetted_3[pass_row_numbers_3, "hash"]  # Corresponding hash values
)

hash_calls_named_3 <- hash_calls_named_3 %>%
  mutate(
    orig.ident = case_when(
      hash == "Hash3-TotalSeqC" ~ "B11",
      hash == "Hash4-TotalSeqC" ~ "A8"))

rownames(hash_calls_named_3) <- hash_calls_named_3$Barcode

hash_calls_named_3 <- hash_calls_named_3 %>%
  select(-Barcode)

# subset hashed Seurat object to remove non-single hash calls
dehash_3_subset <- subset(dehash_3, cells = rownames(hash_calls_named_3))

dehash_3_subset <- AddMetaData(object = dehash_3_subset, metadata = hash_calls_named_3)

dehash_3_split <- SplitObject(dehash_3_subset, split.by = "orig.ident")

heart_t_cells_objects[["A8-B11"]] <- NULL

heart_t_cells_objects <- c(heart_t_cells_objects, dehash_3_split)

```

# Dehash A6-A9-B9-B13 sample, remove multiplets/0-lets

```{r}

# A6 (Group A, Hash1-TotalSeqC), A9 (Group A, Hash2-TotalSeqC), B9 (Group B, Hash3-TotalSeqC), B13 (Group B, Hash4-TotalSeqC)

dehash_4 <- heart_t_cells_objects[["A6-A9-B13-B9"]]

hash_features_dehash_4 <- subset(dehash_4, features = c("Hash1-TotalSeqC", "Hash2-TotalSeqC", "Hash3-TotalSeqC", "Hash4-TotalSeqC"))

hash_counts_4 <- as_tibble(hash_features_dehash_4@assays$RNA@data)

# Convert each row into a list
row_list <- lapply(1:nrow(hash_counts_4), function(i) unlist(hash_counts_4[i, ]))
# Now row_list is a list where each element is a vector containing the values of a row

cutoff_list_4 <- c()

# Apply a function to each row in the list
for (row in row_list) {
  percentile_4_70 <- quantile(row, probs = 0.70)
  cutoff_list_4 <- c(cutoff_list_4, percentile_4_70)
}

hash_counts_4$hash = c("Hash1-TotalSeqC", "Hash2-TotalSeqC", "Hash3-TotalSeqC", "Hash4-TotalSeqC")
hash_counts_4$cutoffs = cutoff_list_4

hash_calls_4 <- hash_counts_4 %>%
  mutate(across(-c(hash, cutoffs), ~ ifelse(. > cutoffs, 1, 0)))
  #1 is pass, 0 is fail

# Count the number of "pass" values in each column
pass_counts_4 <- colSums(hash_calls_4[, !(colnames(hash_calls_4) %in% c("hash", "cutoffs"))])

hist(pass_counts_4, main = "Histogram of Column Sums", xlab = "Sum of 'pass' Values")

# Identify columns with sum equal to 1
cols_to_keep <- which(pass_counts_4 == 1)

# Subset the data frame to keep only the columns with sum equal to 1
hash_calls_subsetted_4 <- hash_calls_4[, c(colnames(hash_calls_4)[cols_to_keep], "hash")]

# Find the row number of the pass (1) value for each barcode column
pass_row_numbers_4 <- apply(hash_calls_subsetted_4[, -ncol(hash_calls_subsetted_4)], 2, which.max)

# Create a new data frame with the hash values for the pass in each barcode column
hash_calls_named_4 <- data.frame(
  Barcode = colnames(hash_calls_subsetted_4)[-ncol(hash_calls_subsetted_4)],  # All barcode column names
  Hash = hash_calls_subsetted_4[pass_row_numbers_4, "hash"]  # Corresponding hash values
)

hash_calls_named_4 <- hash_calls_named_4 %>%
  mutate(
    orig.ident = case_when(
      hash == "Hash1-TotalSeqC" ~ "A6",
      hash == "Hash2-TotalSeqC" ~ "A9",
      hash == "Hash3-TotalSeqC" ~ "B9",
      hash == "Hash4-TotalSeqC" ~ "B13"))

rownames(hash_calls_named_4) <- hash_calls_named_4$Barcode

hash_calls_named_4 <- hash_calls_named_4 %>%
  select(-Barcode)

# subset hashed Seurat object to remove non-single hash calls
dehash_4_subset <- subset(dehash_4, cells = rownames(hash_calls_named_4))

dehash_4_subset <- AddMetaData(object = dehash_4_subset, metadata = hash_calls_named_4)

dehash_4_split <- SplitObject(dehash_4_subset, split.by = "orig.ident")

heart_t_cells_objects[["A6-A9-B13-B9"]] <- NULL

heart_t_cells_objects <- c(heart_t_cells_objects, dehash_4_split)

```

# Dehash A5-B14 sample, remove multiplets/0-lets

```{r}

# A5 (Group A, Hash4-TotalSeqC), B14 (Group B, Hash3-TotalSeqC), not sure hash1/2 for MCL15... excluding for now

dehash_5 <- heart_t_cells_objects[["A5-B14-MCL15"]]

hash_features_dehash_5 <- subset(dehash_5, features = c("Hash3-TotalSeqC", "Hash4-TotalSeqC"))

hash_counts_5 <- as_tibble(hash_features_dehash_5@assays$RNA@data)

# Convert each row into a list
row_list <- lapply(1:nrow(hash_counts_5), function(i) unlist(hash_counts_5[i, ]))
# Now row_list is a list where each element is a vector containing the values of a row

cutoff_list_5 <- c()

# Apply a function to each row in the list
for (row in row_list) {
  percentile_5_55 <- quantile(row, probs = 0.55)
  cutoff_list_5 <- c(cutoff_list_5, percentile_5_55)
}

hash_counts_5$hash = c("Hash3-TotalSeqC", "Hash4-TotalSeqC")
hash_counts_5$cutoffs = cutoff_list_5

hash_calls_5 <- hash_counts_5 %>%
  mutate(across(-c(hash, cutoffs), ~ ifelse(. > cutoffs, 1, 0)))
  #1 is pass, 0 is fail

# Count the number of "pass" values in each column
pass_counts_5 <- colSums(hash_calls_5[, !(colnames(hash_calls_5) %in% c("hash", "cutoffs"))])

hist(pass_counts_5, main = "Histogram of Column Sums", xlab = "Sum of 'pass' Values")

# Identify columns with sum equal to 1
cols_to_keep <- which(pass_counts_5 == 1)

# Subset the data frame to keep only the columns with sum equal to 1
hash_calls_subsetted_5 <- hash_calls_5[, c(colnames(hash_calls_5)[cols_to_keep], "hash")]

# Find the row number of the pass (1) value for each barcode column
pass_row_numbers_5 <- apply(hash_calls_subsetted_5[, -ncol(hash_calls_subsetted_5)], 2, which.max)

# Create a new data frame with the hash values for the pass in each barcode column
hash_calls_named_5 <- data.frame(
  Barcode = colnames(hash_calls_subsetted_5)[-ncol(hash_calls_subsetted_5)],  # All barcode column names
  Hash = hash_calls_subsetted_5[pass_row_numbers_5, "hash"]  # Corresponding hash values
)

hash_calls_named_5 <- hash_calls_named_5 %>%
  mutate(
    orig.ident = case_when(
      hash == "Hash3-TotalSeqC" ~ "B14",
      hash == "Hash4-TotalSeqC" ~ "A5"))

rownames(hash_calls_named_5) <- hash_calls_named_5$Barcode

hash_calls_named_5 <- hash_calls_named_5 %>%
  select(-Barcode)

# subset hashed Seurat object to remove non-single hash calls
dehash_5_subset <- subset(dehash_5, cells = rownames(hash_calls_named_5))

dehash_5_subset <- AddMetaData(object = dehash_5_subset, metadata = hash_calls_named_5)

dehash_5_split <- SplitObject(dehash_5_subset, split.by = "orig.ident")

heart_t_cells_objects[["A5-B14-MCL15"]] <- NULL

heart_t_cells_objects <- c(heart_t_cells_objects, dehash_5_split)

```

# Save dehashed RDS

```{r}

saveRDS(heart_t_cells_objects, "../saved_data/dehashed.rds")

```

# Read in control data, add to Seurat list

```{r}

# Define the list of control file paths
control_paths <- c(
  "../raw_data/hc_rds/GSM4557334_HIP002_cell.counts.matrices.rds",
  "../raw_data/hc_rds/GSM4557335_HIP015_cell.counts.matrices.rds",
  "../raw_data/hc_rds/GSM4557336_HIP023_cell.counts.matrices.rds",
  "../raw_data/hc_rds/GSM4557337_HIP043_cell.counts.matrices.rds",
  "../raw_data/hc_rds/GSM4557338_HIP044_cell.counts.matrices.rds",
  "../raw_data/hc_rds/GSM4557339_HIP045_cell.counts.matrices.rds"
)

# Load and store Seurat objects in the list
for (i in 1:length(control_paths)) {
  control_seurat <- readRDS(control_paths[i])
  sample_name <- paste0("control_", i)
  heart_t_cells_objects[[sample_name]] <- CreateSeuratObject(counts = control_seurat$exon, project = sample_name)
  # could also choose intron or spanning (exon + intron?), but I think exon is the best choice here...
}

```

# Merge Seurat objects from all samples to perform QC

```{r}

# Merge the first element with a sublist of the rest excluding the first element
heart_t_cells <- merge(heart_t_cells_objects[[1]], y = heart_t_cells_objects[-1])

```

# Fix labels

```{r}

heart_t_cells@meta.data$orig.ident <- gsub("-filtered_feature_bc_matrix$", "", heart_t_cells@meta.data$orig.ident)

```

# Calculate percent mitochondrial, ribosomal, hemoglobin features

```{r}

heart_t_cells[["percent_mito"]] <- PercentageFeatureSet(heart_t_cells, pattern = "^MT-")
heart_t_cells[["percent_ribo"]] <- PercentageFeatureSet(heart_t_cells, pattern = "^RP[SL]")
heart_t_cells[["percent_hb"]] <- PercentageFeatureSet(heart_t_cells, pattern = "HB[^(P)]")

```

# Count number of cells from all samples

```{r}

length(colnames(heart_t_cells)) # 231,927 cells

View(heart_t_cells)

```

# Count cells per each of the 31 samples

```{r}

cell_capture <- heart_t_cells@meta.data %>%
  group_by(orig.ident) %>%
  dplyr::count()

cell_capture %>% arrange(orig.ident)

```

# Visualize QC metrics across all patient samples

```{r}

vln_plot <- VlnPlot(heart_t_cells, features = c("nFeature_RNA", "nCount_RNA", "percent_mito", "percent_ribo"), ncol = 4, pt.size=0)

# Loop through each panel and remove x-axis text
for (i in 1:4) {
  vln_plot[[i]] <- vln_plot[[i]] + theme(axis.text.x = element_blank())
}

vln_plot

ggsave(vln_plot, file = "../figures/vln_plot_qc.svg")

```

# Set author QC metric thresholds

```{r}

qcMetricsThresholds <-
  c(
    "nFeature_RNA_min" = 500,
    
    "percent_mito" = 15
  )

```

# Plot distributions of nFeature_RNA across samples

```{r}

nFeature_RNA_QC <- ggplot(heart_t_cells@meta.data, mapping = aes(x = nFeature_RNA)) +
  geom_density(mapping = aes(color = orig.ident), size = 0.5) +
  scale_x_log10() +
  geom_vline(xintercept = qcMetricsThresholds["nFeature_RNA_min"],
             color = "red", linetype = "dashed")
ggsave(nFeature_RNA_QC, file = "../figures/nFeature_RNA.svg")

nFeature_RNA_QC

```

# Plot distributions of nCount_RNA across samples

```{r}

nCount_RNA_QC <- ggplot(heart_t_cells@meta.data, mapping = aes(x = nCount_RNA)) +
  geom_density(mapping = aes(color = orig.ident), size = 0.5) +
  scale_x_log10()
ggsave(nCount_RNA_QC, file = "../figures/nCount_RNA.svg")

nCount_RNA_QC

```

# Plot distributions of percent mito across samples

```{r}

percent_mt_QC <- ggplot(heart_t_cells@meta.data, mapping = aes(x = percent_mito + 1/length(colnames(heart_t_cells)))) +
  geom_density(mapping = aes(color = orig.ident), size = 0.5) +
  scale_x_log10() +
  geom_vline(xintercept = qcMetricsThresholds["percent_mito"],
             color = "red", linetype = "dashed") +
  xlab("percent_mito (with pseudocount)")
ggsave(percent_mt_QC, file = "../figures/percent_mt.svg")

percent_mt_QC

```

# Plot distributions of percent ribo across samples

```{r}

percent_rb_QC <- ggplot(heart_t_cells@meta.data, mapping = aes(x = percent_ribo + 1/length(colnames(heart_t_cells)))) +
  geom_density(mapping = aes(color = orig.ident), size = 0.5) +
  scale_x_log10() +
  xlab("percent_ribo (with pseudocount)")
ggsave(percent_rb_QC, file = "../figures/percent_rb.svg")

percent_rb_QC

```

# Plot distributions of percent hemoglobin across samples

```{r}

percent_hb_QC <- ggplot(heart_t_cells@meta.data, mapping = aes(x = percent_hb + 1/length(colnames(heart_t_cells)))) +
  geom_density(mapping = aes(color = orig.ident), size = 0.5) +
  scale_x_log10() +
  xlab("percent_hb (with pseudocount)")

ggsave(percent_hb_QC, file = "../figures/percent_hb.svg")

percent_hb_QC

```

# Filter cells based on QC metrics, track how many drop out

```{r}

cellsKeep <-
  WhichCells(
    heart_t_cells, expression = nFeature_RNA >= qcMetricsThresholds["nFeature_RNA_min"]) %>%
  intersect(
    WhichCells(
      heart_t_cells, expression = percent_mito <= qcMetricsThresholds["percent_mito"]))
cellsDrop <-
  setdiff(colnames(heart_t_cells), cellsKeep)
length(cellsDrop) # 50,524 cells dropped from analysis

heart_t_cells_filtered <-
  subset(heart_t_cells, cells = cellsKeep)

length(colnames(heart_t_cells_filtered)) # 181,403 cells left behind in filtered data

```

# Count cells by sample after QC filtering

```{r}

cell_capture <- heart_t_cells_filtered@meta.data %>%
  group_by(orig.ident) %>%
  dplyr::count()

cell_capture %>% arrange(n)

```

# Normalize cell numbers across samples

```{r}

num_random_barcodes = 2000

set.seed(123)

# Get the list of unique orig.ident groups
unique_orig_idents <- unique(heart_t_cells_filtered$orig.ident)

# Initialize an empty list to store the subset Seurat objects
subset_seurat_list <- list()

# Loop through each orig.ident group
for (orig_ident in unique_orig_idents) {
  # Get the barcodes for the current orig.ident
  current_barcodes <- colnames(heart_t_cells_filtered)[heart_t_cells_filtered$orig.ident == orig_ident]
  
  # Randomly choose 2000 barcodes
  random_barcodes <- sample(current_barcodes, num_random_barcodes)
  
  # Subset the Seurat object to the randomly chosen barcodes
  subset_seurat <- subset(heart_t_cells_filtered, cells = random_barcodes)
  
  # Append the subset Seurat object to the list
  subset_seurat_list[[orig_ident]] <- subset_seurat
}

# Merge the first element with a sublist of the rest excluding the first element
heart_t_cells_filtered_downsampled <- merge(subset_seurat_list[[1]], y = subset_seurat_list[-1])

cell_capture <- heart_t_cells_filtered_downsampled@meta.data %>%
  group_by(orig.ident) %>%
  dplyr::count()

cell_capture %>% arrange(n)

```

# Save RDS file

```{r}

saveRDS(heart_t_cells_filtered, "../saved_data/qc_filtered.rds")

```