---
title: "Identification of Pathogenic Immune Cell Subsets Associated with Checkpoint Inhibitor-induced Myocarditis"
output: pdf_document
---

 - data mining of https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9397491/
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)
library(Seurat)
library(purrr)
library(ComplexHeatmap)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in TCRseq data

```{r}

tcrs <- read.csv("../saved_data/tcr_seq_features.csv") %>%
  dplyr::select(Patient_ID, predicted.celltype.l1, predicted.celltype.l2, irAE, barcode, Chain, v_gene, j_gene, c_gene, cdr3, cdr3_nt)

tcrs

```

# Read in RNAseq data for UMAP coordinates

```{r}

seurat_obj <- readRDS("../saved_data/final_seurat_T_cells.rds")

```

# Extract UMAP coordinates

```{r}

umap_coords <- Embeddings(object = seurat_obj[["umap"]])[(colnames(seurat_obj)), c(1, 2)]
umap_coords <- as.data.frame(umap_coords)
umap_coords$celltype <- seurat_obj@meta.data$predicted.celltype.l2
umap_coords$irAE <- seurat_obj@meta.data$irAE

umap_coords$barcode <- rownames(umap_coords)

rownames(umap_coords) <- NULL

umap_coords

```

# Find TCR linkages

```{r}

alpha_tcrs_split <- tcrs %>%
  filter(Chain == "TRA") %>%
  group_by(cdr3) %>%
  filter(n() > 1) %>%
  ungroup() %>%
  split(.$cdr3)

alpha_linkages_list <- lapply(alpha_tcrs_split, function(df) {
  df %>%
    summarise(linkages = list(t(combn(barcode, 2, simplify = TRUE)))) %>%
    pull(linkages) %>%
    as.data.frame() %>%
    rename(barcode1 = X1, barcode2 = X2)
})

alpha_linkages <- bind_rows(alpha_linkages_list)

alpha_linkages

beta_tcrs_split <- tcrs %>%
  filter(Chain == "TRB") %>%
  group_by(cdr3) %>%
  filter(n() > 1) %>%
  ungroup() %>%
  split(.$cdr3)

beta_linkages_list <- lapply(beta_tcrs_split, function(df) {
  df %>%
    summarise(linkages = list(t(combn(barcode, 2, simplify = TRUE)))) %>%
    pull(linkages) %>%
    as.data.frame() %>%
    rename(barcode1 = X1, barcode2 = X2)
})

beta_linkages <- bind_rows(beta_linkages_list)

beta_linkages

```

# Get UMAP coordinates for barcodes in linkages

```{r}

barcode1 <- umap_coords %>%
  rename(barcode1 = barcode,
         celltype1 = celltype,
         irAE1 = irAE)

barcode2 <- umap_coords %>%
  rename(barcode2 = barcode,
         celltype2 = celltype,
         irAE2 = irAE)

alpha_links_with_coords <- alpha_linkages %>%
  left_join(barcode1, by = "barcode1") %>%
  rename(x_start = umap_1,
         y_start = umap_2) %>%
  left_join(barcode2, by = c("barcode2")) %>%
  rename(x_end = umap_1,
         y_end = umap_2)

alpha_links_with_coords

beta_links_with_coords <- beta_linkages %>%
  left_join(barcode1, by = "barcode1") %>%
  rename(x_start = umap_1,
         y_start = umap_2) %>%
  left_join(barcode2, by = c("barcode2")) %>%
  rename(x_end = umap_1,
         y_end = umap_2)

beta_links_with_coords

```

# Summarize degree of cell type junction crossover sharing for all cell types to make heatmap (TRA, yes irAE)

```{r}

heatmap_prep_tra <- alpha_links_with_coords %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, irAE1, irAE2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(irAE1, irAE2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo == "Yes_Yes") %>%
  group_by(celltype_combo) %>%
  summarize(count = n()) %>%
  mutate(
    cell_type1 = map_chr(strsplit(celltype_combo, "_"), 1),
    cell_type2 = map_chr(strsplit(celltype_combo, "_"), 2)
  ) %>%
  select(-celltype_combo)

print(sum(heatmap_prep_tra$count))

# Create a matrix with all possible combinations of cell types for rows and cols
all_combinations <- expand.grid(
  cell_type1 = unique(c(heatmap_prep_tra$cell_type1, heatmap_prep_tra$cell_type2)),
  cell_type2 = unique(c(heatmap_prep_tra$cell_type1, heatmap_prep_tra$cell_type2))
)

# Merge the actual data with all combinations and fill missing counts with 1 (for cell type combos with 0 linkages, 1 because doing log transform)
df_merged <- merge(all_combinations, heatmap_prep_tra, by = c("cell_type1", "cell_type2"), all.x = TRUE)
df_merged[is.na(df_merged$count), "count"] <- 1

df_merged <- df_merged %>%
  mutate(count = log10(count))

# Sorting levels for ordered display in the heatmap to keep row and col orders same
df_merged$cell_type1 <- factor(df_merged$cell_type1, levels = sort(unique(df_merged$cell_type1)))
df_merged$cell_type2 <- factor(df_merged$cell_type2, levels = sort(unique(df_merged$cell_type2)))

# Creat a matrix with counts
heatmap_matrix <- matrix(df_merged$count, nrow = length(unique(df_merged$cell_type1)), 
                         ncol = length(unique(df_merged$cell_type2)),
                         byrow = TRUE)

# Set the lower triangle to 0
heatmap_matrix[lower.tri(heatmap_matrix)] <- NA

# Setting row and column names
rownames(heatmap_matrix) <- sort(unique(df_merged$cell_type1))
colnames(heatmap_matrix) <- sort(unique(df_merged$cell_type2))

# Plotting the heatmap
Heatmap(heatmap_matrix, 
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        heatmap_legend_param = list(title = "TRA CDR3 AA linkage\ncount (log10) within\nirAE group"),
        na_col = "white"
)

```

# Summarize degree of cell type junction crossover sharing for all cell types to make heatmap (TRA, no irAE)

```{r}

heatmap_prep_tra <- alpha_links_with_coords %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, irAE1, irAE2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(irAE1, irAE2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo == "No_No") %>%
  group_by(celltype_combo) %>%
  summarize(count = n()) %>%
  mutate(
    cell_type1 = map_chr(strsplit(celltype_combo, "_"), 1),
    cell_type2 = map_chr(strsplit(celltype_combo, "_"), 2)
  ) %>%
  select(-celltype_combo)

print(sum(heatmap_prep_tra$count))

# Create a matrix with all possible combinations of cell types for rows and cols
all_combinations <- expand.grid(
  cell_type1 = unique(c(heatmap_prep_tra$cell_type1, heatmap_prep_tra$cell_type2)),
  cell_type2 = unique(c(heatmap_prep_tra$cell_type1, heatmap_prep_tra$cell_type2))
)

# Merge the actual data with all combinations and fill missing counts with 1 (for cell type combos with 0 linkages, 1 because doing log transform)
df_merged <- merge(all_combinations, heatmap_prep_tra, by = c("cell_type1", "cell_type2"), all.x = TRUE)
df_merged[is.na(df_merged$count), "count"] <- 1

df_merged <- df_merged %>%
  mutate(count = log10(count))

# Sorting levels for ordered display in the heatmap to keep row and col orders same
df_merged$cell_type1 <- factor(df_merged$cell_type1, levels = sort(unique(df_merged$cell_type1)))
df_merged$cell_type2 <- factor(df_merged$cell_type2, levels = sort(unique(df_merged$cell_type2)))

# Creat a matrix with counts
heatmap_matrix <- matrix(df_merged$count, nrow = length(unique(df_merged$cell_type1)), 
                         ncol = length(unique(df_merged$cell_type2)),
                         byrow = TRUE)

# Set the lower triangle to 0
heatmap_matrix[lower.tri(heatmap_matrix)] <- NA

# Setting row and column names
rownames(heatmap_matrix) <- sort(unique(df_merged$cell_type1))
colnames(heatmap_matrix) <- sort(unique(df_merged$cell_type2))

# Plotting the heatmap
Heatmap(heatmap_matrix, 
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        heatmap_legend_param = list(title = "TRA CDR3 AA linkage\ncount (log10) within\nno irAE group"),
        na_col = "white"
)

```

# Summarize degree of cell type junction crossover sharing for all cell types to make heatmap (TRB, yes irAE)

```{r}

heatmap_prep_trb <- beta_links_with_coords %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, irAE1, irAE2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(irAE1, irAE2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo == "Yes_Yes") %>%
  group_by(celltype_combo) %>%
  summarize(count = n()) %>%
  mutate(
    cell_type1 = map_chr(strsplit(celltype_combo, "_"), 1),
    cell_type2 = map_chr(strsplit(celltype_combo, "_"), 2)
  ) %>%
  select(-celltype_combo)

print(sum(heatmap_prep_trb$count))

# Create a matrix with all possible combinations of cell types for rows and cols
all_combinations <- expand.grid(
  cell_type1 = unique(c(heatmap_prep_trb$cell_type1, heatmap_prep_trb$cell_type2)),
  cell_type2 = unique(c(heatmap_prep_trb$cell_type1, heatmap_prep_trb$cell_type2))
)

# Merge the actual data with all combinations and fill missing counts with 1 (for cell type combos with 0 linkages, 1 because doing log transform)
df_merged <- merge(all_combinations, heatmap_prep_trb, by = c("cell_type1", "cell_type2"), all.x = TRUE)
df_merged[is.na(df_merged$count), "count"] <- 1

df_merged <- df_merged %>%
  mutate(count = log10(count))

# Sorting levels for ordered display in the heatmap to keep row and col orders same
df_merged$cell_type1 <- factor(df_merged$cell_type1, levels = sort(unique(df_merged$cell_type1)))
df_merged$cell_type2 <- factor(df_merged$cell_type2, levels = sort(unique(df_merged$cell_type2)))

# Creat a matrix with counts
heatmap_matrix <- matrix(df_merged$count, nrow = length(unique(df_merged$cell_type1)), 
                         ncol = length(unique(df_merged$cell_type2)),
                         byrow = TRUE)

# Set the lower triangle to 0
heatmap_matrix[lower.tri(heatmap_matrix)] <- NA

# Setting row and column names
rownames(heatmap_matrix) <- sort(unique(df_merged$cell_type1))
colnames(heatmap_matrix) <- sort(unique(df_merged$cell_type2))

# Plotting the heatmap
Heatmap(heatmap_matrix, 
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        heatmap_legend_param = list(title = "TRB CDR3 AA linkage\ncount (log10) within\nirAE group"),
        na_col = "white"
)

```

# Summarize degree of cell type junction crossover sharing for all cell types to make heatmap (TRB, no irAE)

```{r}

heatmap_prep_trb <- beta_links_with_coords %>%
  mutate(celltype1 = ifelse(celltype1 == "dnT", "DNT", celltype1),
         celltype2 = ifelse(celltype2 == "dnT", "DNT", celltype2)) %>%
  select(celltype1, celltype2, irAE1, irAE2) %>%
  mutate(celltype_combo = apply(across(c(celltype1, celltype2)), 1, function(x) paste(sort(x), collapse = "_")),
         group_combo = apply(across(c(irAE1, irAE2)), 1, function(x) paste(sort(x), collapse = "_"))) %>%
  filter(group_combo == "No_No") %>%
  group_by(celltype_combo) %>%
  summarize(count = n()) %>%
  mutate(
    cell_type1 = map_chr(strsplit(celltype_combo, "_"), 1),
    cell_type2 = map_chr(strsplit(celltype_combo, "_"), 2)
  ) %>%
  select(-celltype_combo)

print(sum(heatmap_prep_trb$count))

# Create a matrix with all possible combinations of cell types for rows and cols
all_combinations <- expand.grid(
  cell_type1 = unique(c(heatmap_prep_trb$cell_type1, heatmap_prep_trb$cell_type2)),
  cell_type2 = unique(c(heatmap_prep_trb$cell_type1, heatmap_prep_trb$cell_type2))
)

# Merge the actual data with all combinations and fill missing counts with 1 (for cell type combos with 0 linkages, 1 because doing log transform)
df_merged <- merge(all_combinations, heatmap_prep_trb, by = c("cell_type1", "cell_type2"), all.x = TRUE)
df_merged[is.na(df_merged$count), "count"] <- 1

df_merged <- df_merged %>%
  mutate(count = log10(count))

# Sorting levels for ordered display in the heatmap to keep row and col orders same
df_merged$cell_type1 <- factor(df_merged$cell_type1, levels = sort(unique(df_merged$cell_type1)))
df_merged$cell_type2 <- factor(df_merged$cell_type2, levels = sort(unique(df_merged$cell_type2)))

# Creat a matrix with counts
heatmap_matrix <- matrix(df_merged$count, nrow = length(unique(df_merged$cell_type1)), 
                         ncol = length(unique(df_merged$cell_type2)),
                         byrow = TRUE)

# Set the lower triangle to 0
heatmap_matrix[lower.tri(heatmap_matrix)] <- NA

# Setting row and column names
rownames(heatmap_matrix) <- sort(unique(df_merged$cell_type1))
colnames(heatmap_matrix) <- sort(unique(df_merged$cell_type2))

# Plotting the heatmap
Heatmap(heatmap_matrix, 
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        heatmap_legend_param = list(title = "TRB CDR3 AA linkage\ncount (log10) within\nno irAE group"),
        na_col = "white"
)

```

# Prepare df for upset plots

```{r}

alpha_upset_yes_irae <- tcrs %>%
  filter(Chain == "TRA",
         irAE == "Yes") %>%
  mutate(present = 1) %>%
  spread(key = 'predicted.celltype.l2', value = 'present', fill = 0) %>%
  select(-Patient_ID, -predicted.celltype.l1, -irAE, -barcode, -Chain, -v_gene, -j_gene, -c_gene, -cdr3_nt) %>%
  group_by(cdr3) %>%
  summarize(across(everything(), sum)) %>%
  ungroup() %>%
  mutate(across(-cdr3, ~ifelse(. > 0, 1, 0)))

alpha_upset_yes_irae

alpha_upset_no_irae <- tcrs %>%
  filter(Chain == "TRA",
         irAE == "No") %>%
  mutate(present = 1) %>%
  spread(key = 'predicted.celltype.l2', value = 'present', fill = 0) %>%
  select(-Patient_ID, -predicted.celltype.l1, -irAE, -barcode, -Chain, -v_gene, -j_gene, -c_gene, -cdr3_nt) %>%
  group_by(cdr3) %>%
  summarize(across(everything(), sum)) %>%
  ungroup() %>%
  mutate(across(-cdr3, ~ifelse(. > 0, 1, 0)))

alpha_upset_no_irae

beta_upset_yes_irae <- tcrs %>%
  filter(Chain == "TRB",
         irAE == "Yes") %>%
  mutate(present = 1) %>%
  spread(key = 'predicted.celltype.l2', value = 'present', fill = 0) %>%
  select(-Patient_ID, -predicted.celltype.l1, -irAE, -barcode, -Chain, -v_gene, -j_gene, -c_gene, -cdr3_nt) %>%
  group_by(cdr3) %>%
  summarize(across(everything(), sum)) %>%
  ungroup() %>%
  mutate(across(-cdr3, ~ifelse(. > 0, 1, 0)))

beta_upset_yes_irae

beta_upset_no_irae <- tcrs %>%
  filter(Chain == "TRB",
         irAE == "No") %>%
  mutate(present = 1) %>%
  spread(key = 'predicted.celltype.l2', value = 'present', fill = 0) %>%
  select(-Patient_ID, -predicted.celltype.l1, -irAE, -barcode, -Chain, -v_gene, -j_gene, -c_gene, -cdr3_nt) %>%
  group_by(cdr3) %>%
  summarize(across(everything(), sum)) %>%
  ungroup() %>%
  mutate(across(-cdr3, ~ifelse(. > 0, 1, 0)))

beta_upset_no_irae

```

# Create upset plots

```{r}

upset(as.data.frame(alpha_upset_yes_irae), sets = setdiff(colnames(alpha_upset_yes_irae), "cdr3"), sets.bar.color = "#56B4E9", sets.x.label = "TRA CDR3AAs per cell type in irAE", mainbar.y.label = "TRA CDR3AA linkages (log10) within cell type (combos) in irAE", point.size = 1.5, show.numbers = FALSE, scale.intersections = "log10", text.scale = 0.75)

upset(as.data.frame(alpha_upset_no_irae), sets = setdiff(colnames(alpha_upset_no_irae), "cdr3"), sets.bar.color = "#56B4E9", sets.x.label = "TRA CDR3AAs per cell type in no irAE", mainbar.y.label = "TRA CDR3AA linkages (log10) within cell type (combos) in no irAE", point.size = 1.5, show.numbers = FALSE, scale.intersections = "log10", text.scale = 0.75)

upset(as.data.frame(beta_upset_yes_irae), sets = setdiff(colnames(beta_upset_yes_irae), "cdr3"), sets.bar.color = "#56B4E9", sets.x.label = "TRB CDR3AAs per cell type in irAE", mainbar.y.label = "TRB CDR3AA linkages (log10) within cell type (combos) in irAE", point.size = 1.5, show.numbers = FALSE, scale.intersections = "log10", text.scale = 0.75)

upset(as.data.frame(beta_upset_no_irae), sets = setdiff(colnames(beta_upset_no_irae), "cdr3"), sets.bar.color = "#56B4E9", sets.x.label = "TRB CDR3AAs per cell type in no irAE", mainbar.y.label = "TRB CDR3AA linkages (log10) within cell type (combos) in no irAE", point.size = 1.5, show.numbers = FALSE, scale.intersections = "log10", text.scale = 0.75)

```