---
title: "P576-1 - ITN ATAC study"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(knitr)
library(dplyr)
library(ggplot2)
library(ggthemes)
library(ggbeeswarm)
library(viridis)
library(stringr)
library(readxl)
library(kableExtra)
library(RColorBrewer)
library(plotly)
library(tidyr)
library(gtools)
library(corrplot)
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
library(stringr) # string processing
library(dplyr) # dataframe handling
library(readxl) # load excel files
library(ggplot2); # plotting
library(circlize) # get the color gradient function (color ramp) for heatmaps
library(apird)
library(ATACseqQC)
library(GenomicAlignments)
library(chromVAR)
library(soGGi)
library(DiffBind)
library(EnsDb.Hsapiens.v86) # this is used for annotation data
library(readr)
library(edgeR)
library(ComplexHeatmap)
library(ChIPpeakAnno)
library(ggrepel)
library(ggpubr)
library(ggvenn)
library(msigdbr)
library(fgsea)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Use apird to access data (metrics and annotations from database)

```{r}

# set base directory to folder above current analyses folder
baseDir <- gsub("/analyses$", "", getwd())

# saved data directory
dataDir <- function(fname) {
  return (file.path(baseDir,'saved_data', fname))
}

# figures directory
plotDir <- function(fname) {
  return (file.path(baseDir,'figures', fname))
}

projects = c("P576-1")

dataFileName = "P576-1_data.Rdata"

pathToDataFile = dataDir(dataFileName)

# If the data file exists, load it
if (file.exists(pathToDataFile)) {
  load(pathToDataFile)
  
# if not, pull data from research database
} else {
  IDs = projects

  annotations = c()
  metrics = c()

  for (ID in IDs) {
    getGcqProjectInfo(ID)
    libids = getProjectLibs(ID)
    
    annotations = dplyr::bind_rows(annotations, getAnno(libids))
    metrics = dplyr::bind_rows(metrics, getMetrics(libids))
  }
  
  metrics = metrics[complete.cases(metrics), ]
  
  # Save for offline analysis
  save(annotations,
     metrics,
     file = pathToDataFile)
}

```

# Combine and cleanup metrics and annotations

```{r}

annotations = dplyr::select(annotations, -c("studyGroup", "donorId"))

donorKey = data.frame(testID = c("xpb1020740416", "xpb184727720", "xpb330116592", "xpb43423629", "xpb689481616", "xpb842527707", "xpb846719829", "xpb851902364", "xpb92768395", "xpb98176920", "xpb99368178", "xpb99638795" ),
                      studyGroup = c("flaring", "healthy", "healthy", "non-flaring", "healthy", "healthy", "non-flaring", "healthy", "non-flaring", "flaring", "flaring", "non-flaring" ),
                      sex = c("female", "female", "female", "female", "male", "female", "female", "female", "female", "female", "female", "female" )
)

annotations = merge(annotations, donorKey, by = "testID")

annotations$donorId = annotations$testID
# annotations$studyGroup = "HC"
# annotations$studyGroup[grepl("MS", annotations$sample_name, fixed = F)] = "MS"
# 
# annotations$donorId = sapply(strsplit(annotations$donorId, "_"), function(x) x[1])

annotations$cellType = "CD4"
annotations$cellType[grepl("CD8", annotations$sort, fixed = F)] = "CD8"

annotations$sampleName = paste(annotations$cellType, annotations$donorId, sep = "_")

design <- full_join(annotations, metrics, by = c("libid"))

design$studyGroup = factor(design$studyGroup, levels = c("healthy", "non-flaring", "flaring"))

table(design$donorId, design$cellType)

table(design$donorId, design$studyGroup)

```

# Setup colors

```{r}

myPalette = c('#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080', '#ffffff', '#000000')

colors.cellType = c("#388F50","#9861DB", "#FF3333")
names(colors.cellType) <- unique(design$cellType)

colors.studyGroup = c("#FF6457", "#4C698F", "#FF8554", "#FF3333")
names(colors.studyGroup) <- unique(design$studyGroup)

colors.donorId = myPalette[1:length(unique(design$donorId))]
names(colors.donorId) = unique(design$donorId)

```

# Setup file paths

```{r}

flowcellDirectories = c("/mnt/bioinformatics/pipeline/Illumina/230118_VH00126_253_AAAV5VCHV/Project_P576-1Processed_bri_230122")

# insert sizes is txt file for each lib that is collection of how long fragments are and freqs (input for histogram of frag size distribution in bp)
fragmentFiles = list.files(file.path(flowcellDirectories, "insertSizes"), full.names = T)
names(fragmentFiles) = str_extract(fragmentFiles, "lib[0-9]+")

# alignments are bam files, everything else derived from alignments
alignmentFiles = list.files(file.path(flowcellDirectories, "alignments"), full.names = T, pattern = "^.*\\mapped.bam$")
names(alignmentFiles) = str_extract(alignmentFiles, "lib[0-9]+")

# peak files: get files for all libs (summits, peaks, narrow peak), bed file is genomics format that has genomic interval and chr and score (in this case, summits bed is highest point of all peaks found, score is how high)
# narrow peak file: broader range than summit, it's entire peak range not just summit/peak, score is integral of scores over range
# bigwigs: similar to bam, contain fragments, use to generate coverage plots/trace plots, shows sum of counts b/w positions/genomic ranges
peakFiles = list.files(file.path(flowcellDirectories, "peaks"), full.names = T, pattern = "^.*\\.narrowPeak$")
names(peakFiles) = str_extract(peakFiles, "lib[0-9]+")

for (i in 1:nrow(design)){
  design$bamFile[i] = alignmentFiles[design$libid[i]]
  design$fragmentFile[i] = fragmentFiles[design$libid[i]]
  design$peakFiles[i] = peakFiles[design$libid[i]]
}

```

# Summarize sample overview

```{r}

table(design$donorId, design$cellType) %>%
  kable() %>%
  kable_minimal(full_width = F)

table(design$studyGroup, design$cellType) %>%
  kable() %>%
  kable_minimal(full_width = F)

```

# QC: fragment size distributions
 - 1 peak ideally, also with oscillations
 - expect a peak around 100 bp (nuclesome free region) and then oscillations with maxima 200 bp mono-nucleosome, 400 bp di-nucleosome and so on
 - ENCODE: A nucleosome free region (NFR) must be present. A mononucleosome peak must be present in the fragment length distribution. These are reads that span a single nucleosome, so they are longer than 147 bp but shorter than 147*2 bp. Good ATAC-seq datasets have reads that span nucleosomes (which allows for calling nucleosome positions in addition to open regions of chromatin).

```{r}

species = "human"
fragmentDistributionsFile <- "P576-1_fragmentsize_distributions.Rdata"

pathToDataFile = dataDir(fragmentDistributionsFile)

  # Function to read and process files, 
  unpackFragData <- function(fragmentFile, species, includeShortFrags = F){
    libid <- str_extract(fragmentFile, "lib[0-9]+")
    cat(sprintf("Counting fragments of %s... \n", libid))
    fragmentDistribution <- read.table(fragmentFile)
    colnames(fragmentDistribution) <- c("nReads", "fragLen")
    
    # fragmentDistribution$shortReads = fragmentDistribution$nReads[fragmentDistribution$fragLen == 0]
    
    if (!includeShortFrags) {
      fragmentDistribution = dplyr::filter(fragmentDistribution, fragLen > 15)
    }
    
    fragmentDistribution$fragmentLengths <- abs(fragmentDistribution$fragLen)
    fragmentDistribution$normReads <- fragmentDistribution$nReads/sum(fragmentDistribution$nReads) * 10^3
    
    fragmentDistribution$nFragments = sum(fragmentDistribution$nReads)
    
    fragmentDistribution$libid <- libid
    return(fragmentDistribution)
    
  }
  
  fragmentList <- lapply(design$fragmentFile[!is.na(design$fragmentFile)], function(x) unpackFragData(x, species))
  
  cat(sprintf("Combining fragment distributions into one dataframe...\n"))
  fragmentDistributions <- bind_rows(fragmentList)
  
  cat(sprintf("Saving datafile...\n"))
  save(fragmentDistributions,
     file = pathToDataFile)

fragmentDistributions <- merge(fragmentDistributions, dplyr::select(design, libid, sample_name, studyGroup, cellType, donorId), by="libid", all = T)

```

# Plot fragment size distributions

 - wiggles in the above plot are a biological feature and come from 10 bp per helical turn of the DNA

```{r}

xrange = c(0,750)

fragmentDistributionPlot  <- fragmentDistributions %>%
  dplyr::filter(fragmentLengths > xrange[1] & fragmentLengths < xrange[2]) %>%
  ggplot(aes(x = fragmentLengths, y = normReads, color = donorId, group = libid)) +
  #scale_color_manual(values = colors.donorId) +
  geom_line() +
  xlim(c(xrange[1],xrange[2])) +
  labs(x = "Fragment length, bp", y = expression(paste("Normalized read density (a.u.)")), color = "") + 
  theme(text = element_text(size = 14)) +
  theme(legend.position="right") + 
  theme(legend.direction='vertical') +
  theme_bw() +
  facet_grid(cellType ~ studyGroup, scales="free")

print(fragmentDistributionPlot)

ggsave(plotDir("P576-1_fragmentSizeDistributions.pdf"), plot = fragmentDistributionPlot, height = 8,  width = 12)

```

# QC: TSSe
 - in ATAC we expect an enhancement at the TSSe
 - enrichment over TSS, signal:noise > 5 at peak (exclude libs that don't meet this requirement)
 - plots for this were generate using deeptools and are currently located in the flow cell directory. They are included here for completeness
 - ENCODE: Transcription start site (TSS) enrichment values are dependent on the reference files used; cutoff values for high quality data are listed in the table below, for `GRCh38 Refseq TSS annotation` we are looking for > 7, while 5-7 is still acceptable.

# run this with deeptools installed in the current python environment, skip for now?
cores=48

computeMatrix scale-regions -S pathToBigWigs/HC1_H3K27Ac.bigWig pathToBigWigs/MS1_H3K27Ac.bigWig \
                              -R /mnt/bioinformatics/pipeline/annotation/GRCh38/Homo_sapiens.GRCh38.91.sorted.gtf \
                              --beforeRegionStartLength 3000 \
                              --regionBodyLength 3000 \
                              --afterRegionStartLength 3000 \
                              --skipZeros -o outdir/H3K27Ac.gz -p $cores
                              
plotProfile -m H3K27Ac.gz \
-out TSSe_H3K27Ac.png \
--perGroup \
--plotTitle "" \
--refPointLabel "TSS" \
-T "H3K27Ac density" \
-z ""

```{r}

calculateCoverage = function(bamfile, ref) {
  distanceToTSS = -1500:1500
  coverage_ <- regionPlot(bamFile = bamfile, 
                          testRanges = ref, style = "point", 
                          format = "bam", paired = TRUE,
                          minFragmentLength = 0, 
                          maxFragmentLength = 500, 
                          normalize = "RPM")
  
  coverage = as.vector(colSums(coverage_@assays@data@listData[[1]]))
  coverage = coverage/min(coverage)
  
  coverage = data.frame(distanceToTSS, coverage)
  
  colnames(coverage) <- c("distanceToTSS", "aggregateTSSscore")
  
  return(coverage)
}

TSSs <- resize(genes(TxDb.Hsapiens.UCSC.hg38.knownGene), fix = "start", 1)
seqlevelsStyle(TSSs) <- "NCBI"

fragmentDistributionsFile <- "P576-1_TSS_coverage.Rdata"

pathToDataFile = dataDir(fragmentDistributionsFile)

# If the data file exists, load it
if (file.exists(pathToDataFile)) {
  load(pathToDataFile)
  
} else {
    TSScoverage = c()
  for (i in 1:1:nrow(design)) {
    if (!is.na(design$bamFile[i])) {
      TSScoverage_ = calculateCoverage(design$bamFile[i], TSSs)
      TSScoverage_$libid = design$libid[i]
      
      TSScoverage = rbind(TSScoverage, TSScoverage_)
    }
  }
  
  cat(sprintf("Saving datafile...\n"))
  save(TSScoverage,
       file = pathToDataFile)
}

```

# Plot TSS coverage

```{r}

TSScoverage = merge(TSScoverage, 
                    dplyr::select(design, libid, cellType, donorId, studyGroup),
                    by = "libid")

TSSePlot  <- TSScoverage %>%
  ggplot(aes(x = distanceToTSS,
             y = aggregateTSSscore,
             group = libid,
             color = donorId))+
  geom_line() +
  scale_color_manual(values = colors.donorId) +
  labs(x = "distance to TSS (bp)",
       y = "aggregate, normalized TSS score", color = "") + 
  theme_bw() +
  theme(legend.position="right") + 
  theme(legend.direction='vertical') + 
  # facet_wrap(~ treatment, scales="fixed") +
  facet_grid(cellType ~ studyGroup, scales="fixed") +
  geom_hline(yintercept = 5, linetype = 2) + 
  geom_hline(yintercept = 7, linetype = 3, color = "grey")

plot(TSSePlot)

ggsave(plotDir("P576-1_TSSePlot.pdf"), plot = TSSePlot, height = 8,  width = 12)

```

# Display TSSe scores

```{r}

TSSe_scores = TSScoverage %>%
  group_by(libid) %>%
  summarise(TSSe_score = max(aggregateTSSscore))

design = merge(design, TSSe_scores, by = "libid")

table_data = dplyr::select(design, 
                           libid, studyGroup, donorId, 
                           `cell type` = cellType, 
                           `TSSe score` = TSSe_score)

table_data$`TSSe score` = round(table_data$`TSSe score`, 1)

table_data %>%
  kbl() %>%
  # kable_paper("hover", full_width = F)
  kable_minimal(full_width = F)

```

# QC: read counts and alignment
 - ENCODE recommends 50 mio (aligned) reads for paired-end, 25 mio for single read
 - ENCODE: Each replicate should have 25 million non-duplicate, non-mitochondrial aligned reads for single-end sequencing and 50 million for paired-ended sequencing (i.e. 25 million fragments, regardless of sequencing run type). The alignment rate, or percentage of mapped reads, should be greater than 95%, though values > 80% may be acceptable
 - want 10-50 mil reads depending on if TF analysis required (ENCODE suggestions)

```{r}

# cutoffs from encode
alignCut = 80
readCut = 50000000

# This makes a total read plots
totalReadsPlot = ggplot(design, aes(fill = donorId, y = tophatstats_total_reads/1e6, x = donorId)) + 
    geom_bar(position="stack", stat="identity") +
    labs(x = "", y = "total reads / 1e6", fill = "") + 
    scale_fill_manual(values = colors.donorId) +
    # theme(text = element_text(size = 13)) +
    theme(legend.position="bottom") + 
    geom_hline(yintercept = readCut/1e6, linetype = 2) +
    # ylim(c(0,55))+
    theme(legend.direction='horizontal') +
    # facet_wrap(. ~ histone, scales="free") + 
    facet_grid(cellType ~ studyGroup, scales = "free") +
    theme_bw() +
    theme(axis.text.x = element_blank(), axis.ticks = element_blank())

print(totalReadsPlot)

ggsave(plotDir("P576-1_totalReads.pdf"), totalReadsPlot, height = 6, width = 8)

```

# Plot alignment vs. read count (~alignment vs median CV)
 - ENCODE recommends an alignment of at least `r alignCut`% and `r (readCut/1e6)` mio reads. In contrast to the RNAseq plot where we are good samples are in the top left, we now want our samples to fall into the top right corner

```{r, fig.width=6, fig.height=4, fig.align = 'center'}

gPctAligned <- ggplot(data = design) +
  geom_point(aes(x = tophatstats_total_reads/1e6, 
                 y = pct_aligned,
                 color = donorId, 
                 shape = cellType),
                 size = 1.5) + 
  scale_color_manual(values = colors.donorId) +
  labs(x = "total reads / mio", 
       y = "percent alignment", 
       color = "donor",
       shape = "cell type")+
  geom_hline(yintercept = alignCut, linetype = 2)+
  geom_vline(xintercept = readCut/1e6, linetype = 2)+
  ylim(c(0,100))+
  xlim(c(0,70))+
  theme_bw() +
  # theme(text = element_text(size=14)) +
  theme(legend.position = "right") + 
  theme(legend.direction=  'vertical')

print(gPctAligned)

ggsave(plotDir("P576-1_totalReads_vs_alignment.pdf"), gPctAligned, height = 7, width = 8)

```

 - may want to make UCSC genome browser session with bigwig files for each library that was run, tracks representing "coverage", can be helpful to identify samples that might have seemed suspicious in any of the above metrics. Look out for samples that do not show well defined features, or that are spotty or of low intensity (in case of low reads). Later, peak calls and differential peaks will be added as bed files.

# QC: peak calling
 - peaks were called using macs2 with the following parameters:`macs2 callpeak -t {input} -g hs -f BAMPE -n {output}`
 - peak calling: count peaks for each file (bed files, count rows), recommended 10k peaks (less means too few reads or bad data/sample prep)

```{r}

peaksDataFile <- "P576-1_peaks.Rdata"

pathToDataFile = dataDir(peaksDataFile)

readPeaks = function(peakFile, libid, peakCaller) {
    peaks_ = read.table(peakFile, header = FALSE, fill = TRUE)  %>% mutate(width = abs(V3-V2))
    
    if (peakCaller == "seacr") {
       colnames(peaks_)[1:6] = c("chr", "start", "end", "total sign", "max signal", "max signal region")
    } else if (peakCaller == "macs2") {
       colnames(peaks_)[1:10] = c("chr", "start", "end", "name", "score", "strand", "total sign", "pValue", "qValue", "peak")
    }
    
    peaks_$libid = libid
    
    return (peaks_)
    }

# If the data file exists, load it
if (file.exists(pathToDataFile)) {
  
  load(pathToDataFile)
} else {
  macs2Peaks = c()
  
  for (i in 1:nrow(design)) {
    
    # step through library
    print(paste0("Reading peaks from ", design$libid[i]))

    # MACS2 full data set
    # get macs2 peaks
    peaks_ = readPeaks(design$peakFiles[i], libid = design$libid[i], peakCaller = "macs2")
    
    macs2Peaks = rbind(macs2Peaks, peaks_)
    
  }

  save(macs2Peaks, file = pathToDataFile)
}

macs2Peaks = dplyr::filter(macs2Peaks, chr %in% c(1:23,"X","Y"))

macs2Peaks = merge(macs2Peaks, dplyr::select(design, c("libid", "donorId", "studyGroup", "sampleName", "studyGroup", "cellType")), by = "libid")

```

# Summarize peaks

```{r}

peakSummary = macs2Peaks %>% 
  dplyr::group_by(libid) %>%
  dplyr::summarise(nPeaks = n(), minPeak = min(width), meanPeaks = mean(width), medianPeaks = median(width), maxPeak = max(width))

design = merge(design, peakSummary, by = "libid")

```

# Calculate FRiP

```{r}

fripsDataFile <- "P576-1_frips.Rdata"

pathToDataFile = dataDir(fripsDataFile)

# If the data file exists, load it
if (file.exists(pathToDataFile)) {
  load(pathToDataFile)
  
} else {
  
  inPeakData = c()
  ## overlap with bam file to get count
  for(i in 1:nrow(design)){
      peaks_ = dplyr::filter(macs2Peaks, libid == design$libid[i])
      peaks_gr = GRanges(seqnames = peaks_$chr, IRanges(start = peaks_$start, end = peaks_$end), strand = "*")
      fragment_counts <- chromVAR::getCounts(design$bamFile[i], peaks_gr, paired = TRUE, by_rg = FALSE, format = "bam")
      inPeakN = counts(fragment_counts)[,1] %>% sum
      inPeakData = rbind(inPeakData, data.frame(inPeakN = inPeakN, libid = design$libid[i]))
  }
  
  save(inPeakData, file = pathToDataFile)
  
}

design = merge(design, inPeakData, by = "libid")
                 
design = design %>% dplyr::mutate(frip = round(inPeakN/as.numeric(mapped_paired_reads) * 100,2))

```

# Do we get same peaks with full data vs. downsampled, i.e. are downsampled peaks within full data peaks?

```{r}

# peakOverlap = c()
# 
# for (cellType_ in unique(design$cellType)){
#   print(paste0("Calculating peak overlap for ", cellType_, "..."))
#   for (donorId_ in unique(design$donorId)) {
#     print(paste0("  ... ", donorId_))
#     libids = dplyr::filter(design, donorId == donorId_, cellType == cellType_)$libid
#     peaksets = c()
#     
#     if (length(libids == 2)) {
#        peakset_1 = dplyr::filter(macs2Peaks, libid == libids[1])
#        peakset_2 = dplyr::filter(macs2Peaks, libid == libids[2])
#        
#        Ns = c(nrow(peakset_1), nrow(peakset_2))
#        
#        imorePeaks = which.max(Ns)
#        ifewerPeaks = which.min(Ns)
#        
#        peaksets[[1]] = GRanges(peakset_1$chr, IRanges(start = peakset_1$start, end = peakset_1$end), strand = "*")
#        peaksets[[2]] = GRanges(peakset_2$chr, IRanges(start = peakset_2$start, end = peakset_2$end), strand = "*")
#       
#        overlap.gr = peaksets[[imorePeaks]][findOverlaps(peaksets[[1]], peaksets[[2]])@from]
#        
#        peakOverlap = data.frame(libid = libids,  nReproducedPeaks = length(overlap.gr)) %>% rbind(peakOverlap, .)
#     }
#     
#   }
#   
# }
# 
# design = merge(design, peakOverlap, by = "libid")
# design = design %>% dplyr::mutate(peakReproducability = round(nReproducedPeaks/nPeaks * 100,2))
```

# Summarize peak calling

```{r}

table_data = dplyr::select(design, libid, donorId, `cell type` = cellType, `totalReads (Mio)` = tophatstats_total_reads, `align %` = pct_aligned, `aligned reads` = mapped_paired_reads, `peak calls` = nPeaks, `median peak width` = medianPeaks, FRiP = frip)
table_data$`totalReads (Mio)` = round(table_data$`totalReads (Mio)`/1e6,1)
table_data$`align %` = round(table_data$`align %`,1)

table_data %>%
  kbl() %>%
  # kable_paper("hover", full_width = F)
  kable_minimal(full_width = F)

```

# QC: peak counts
 - first plot below summarizes the number of peaks that were discovered for cell type and study group

```{r}

ggpeakN = design %>% ggplot(aes(x = studyGroup, y = nPeaks, fill = studyGroup)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(aes(color = donorId), position = position_jitter(0.15)) +
    scale_fill_manual(values = colors.studyGroup) +
    scale_color_manual(values = colors.donorId) +
    # scale_fill_viridis(discrete = TRUE, begin = 0.1, end = 0.55, option = "magma", alpha = 0.8) +
    # scale_color_viridis(discrete = TRUE, begin = 0.1, end = 0.9) +
    theme_bw() +
    ylab("Number of Peaks") + 
    facet_grid(.~ cellType, scales = "fixed")
    # xlab("") + 
    # theme(axis.text.x = element_blank(), axis.ticks = element_blank())

plot(ggpeakN)

ggsave(filename = plotDir("peak_counts.pdf"),
         plot = ggpeakN,
         width = 9,
         height = 5)

```

# Plot peaks vs reads
 - ENCODE:The number of peaks within a replicated peak file should be >150,000, though values >100,000 may be acceptable. 
 - ENCODE recommends > 150 000 peaks, although > 100 000 is still acceptable

```{r}

ggPeakNvsReads = ggplot(data = design) +
  geom_point(aes(x = tophatstats_total_reads/1e6, 
                 y = nPeaks,
                 color = donorId, 
                 shape = cellType),
                 size = 1.5) + 
  scale_color_manual(values = colors.donorId) +
  labs(x = "total reads / mio", 
       y = "number of peaks", 
       color = "donor",
       shape = "cell type")+
  xlim(c(0,70)) +
  theme_bw() +
  # theme(text = element_text(size=14)) +
  theme(legend.position = "right") + 
  theme(legend.direction=  'vertical')

plot(ggPeakNvsReads)

ggsave(filename = plotDir("peakCalling_peakN_vs_reads.pdf"),
         plot = ggPeakNvsReads,
         width = 8,
         height = 6)

```

# QC: peak widths
 - first, the median peak width by study group
 - want them to not be too narrow or too broad, want ~400-1000 bp peak widths as medians, cut and run wider than ATACseq

```{r}

ggPeakWidthSummarized = design  %>% ggplot(aes(x = studyGroup, y = medianPeaks, fill = studyGroup)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(aes(color = donorId), position = position_jitter(0.15)) +
    scale_fill_manual(values = colors.studyGroup) +
    scale_color_manual(values = colors.donorId) +
    facet_grid(cellType ~ ., scales = "fixed") +
    # scale_y_continuous(limits = c(500, 1000)) +
    theme_bw() +
    ylab("Median width of Peaks") 

plot(ggPeakWidthSummarized)

ggsave(filename = plotDir("peak_median_widths.pdf"),
         plot = ggPeakWidthSummarized,
         width = 8,
         height = 6)

```

# Investigate peak width distribution by libid

```{r}

ggPeakWidth = macs2Peaks  %>% ggplot(aes(x = libid, y = width, fill = donorId)) +
    geom_violin() +
    facet_wrap(cellType ~ ., scales = "free") +
    scale_fill_manual(values = colors.donorId) +
    # scale_color_manual(values = colors.donorId) +
    # scale_fill_viridis(discrete = TRUE, begin = 0.1, end = 0.55, option = "magma", alpha = 0.8) +
    # scale_color_viridis(discrete = TRUE, begin = 0.1, end = 0.9) +
    # scale_y_continuous(trans = "log", breaks = c(10, 3000, 16000), limits = c(100, 2000)) +
    scale_y_continuous(limits = c(100, 2000)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +
    ylab("Width of Peaks")
    # xlab("") + 
    # theme(axis.text.x = element_blank(), axis.ticks = element_blank())

plot(ggPeakWidth)

ggsave(filename = plotDir("peakwidths_by_sample.pdf"),
         plot = ggPeakWidth,
         width = 8,
         height = 6)

```

# QC: FRiP
 - ENCODE: The fraction of reads in called peak regions (FRiP score) should be > 0.3, though values greater than 0.2 are acceptable. For EN-TEx tissues, FRiP scores will not be enforced as QC metric. TSS enrichment remains in place as a key signal to noise measure
 - FRiP is calculated by going through the bam files and counting the reads that fall within a called peak

```{r}

# design %>% dplyr::select(libid, donorId, studyGroup, cellType, tophatstats_total_reads, mapped_paired_reads, pct_aligned, inPeakN, frip)

ggFRiPs = design %>% ggplot(aes(x = studyGroup, y = frip, fill = studyGroup)) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(aes(color = donorId), position = position_jitter(0.15)) +
    scale_fill_manual(values = colors.studyGroup) +
    scale_color_manual(values = colors.donorId) +
    theme_bw() +
    ylab("% of Fragments in Peaks") +
    xlab("") + 
    facet_grid(cellType ~ ., scales = "free")

plot(ggFRiPs)

ggsave(filename = plotDir("frips.pdf"),
         plot = ggFRiPs,
         width = 8,
         height = 6)

```

# Peak overlap between biological replicates
 - peak overlap between biological replicates helps us asses sample preparation issues. However, this metric is sensitive to the total number of peaks called per sample
 - should instead here calculate a "master peakset" from all replicates, then calculate reproduction rate as overlap of peaks from a sample with this master peak set

```{r}

# ggpeakOverlap = design %>% ggplot(aes(x = studyGroup, y = peakReproducability, fill = studyGroup)) +
#     geom_boxplot(outlier.shape = NA) +
#     geom_jitter(aes(color = donorId), position = position_jitter(0.15)) +
#     scale_fill_manual(values = colors.studyGroup) +
#     scale_color_manual(values = colors.donorId) +
#     facet_grid(cellType ~ ., scales = "fixed") +
#     theme_bw() +
#     ylab("Between replicate peak reproduction rate")
# 
# plot(ggpeakOverlap)
# 
# ggsave(filename = plotDir("peakCalling_peakreproducibility.pdf"),
#          plot = ggpeakOverlap,
#          width = 8,
#          height = 6)

```

# Plot peak overalp against total peaks

```{r}

# gPeakRepVsNPeaks <- ggplot(data = design) +
#   geom_point(aes(x = nPeaks, 
#                  y = peakReproducability,
#                  color = donorId, 
#                  shape = cellType),
#                  size = 3) + 
#   scale_color_manual(values = colors.donorId) +
#   labs(x = "total number of peaks", 
#        y = "Between replicate peak reproduction rate", 
#        color = "donor",
#        shape = "cell type")+
#   # theme(text = element_text(size=14)) +
#   theme_bw() +
#   theme(legend.position = "right") + 
#   theme(legend.direction=  'vertical')
# 
# plot(gPeakRepVsNPeaks)
# 
# ggsave(filename = plotDir("peakCalling_peakreproducibility_vs_npeaks.pdf"),
#          plot = gPeakRepVsNPeaks,
#          width = 8,
#          height = 6)

```

# QC: mitochondrial percentages

```{r}

all_mapped_reads <- data.frame()

for (bam_file in alignmentFiles) {
  # some reads mapped to alternative chr, but less commonly
  mapped_reads <- idxstatsBam(bam_file) %>% dplyr::filter(seqnames %in% c(1:23, "X", "Y", "MT"))
  mapped_reads$file <- basename(bam_file)
  mapped_reads$libid <- sub("lib([0-9]+)_.*", "\\1", mapped_reads$file)
  all_mapped_reads <- rbind(all_mapped_reads, mapped_reads)
}

perc_mt <- all_mapped_reads %>%
  group_by(libid) %>%
  summarize(mt_perc = 100*mapped[seqnames == "MT"] / sum(mapped))

perc_mt

p <- ggplot(perc_mt, aes(libid, mt_perc, fill = libid)) +
  geom_bar(stat = "identity") +
  theme(legend.position = "none",
        axis.text.x = element_text(size = 8, angle = 45, hjust = 1)) +
  labs(x = "Lib ID", y = "Mapped counts to MT (%)")

p

ggsave("../figures/mt_map_perc.svg", p)

```

# Exclude samples with failed QC
 - here's a good stopping point to show Basilin/Stephan QC plots before moving on to try merging bam files