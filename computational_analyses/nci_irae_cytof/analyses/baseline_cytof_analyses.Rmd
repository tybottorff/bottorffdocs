---
title: "CyTOF analyses for NCI irAE project"
output: pdf_document
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(ggbreak)
library(cowplot)
library(kableExtra)
library(beeswarm)
library(Matrix)
library(ggplot2)
library(stringr)
library(scales)
library(tidyr)
library(ComplexHeatmap)
library(viridis)
library(readxl)
library(circlize)
library(factoextra)
library(lmerTest)
library(gtsummary)
library(ica)
library(dplyr)
library(ggrepel)
library(purrr)
library(compareGroups)
library(reshape2)
library(limma)
library(pyRforest)
library(reticulate)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in all data

```{r}

flow_data <- read_excel("../raw_data/2024_10_17_flow_data.xlsx") %>%
  # deal with multiple dates in a column
  mutate(
    # Handle cases where the infusion date might not be in a standard format
    `Infusion date` = case_when(
      grepl(",", `Infusion date`) ~ sapply(strsplit(`Infusion date`, ","), function(x) x[1]), # Take the first date if there are multiple
      TRUE ~ `Infusion date`  # Keep the date as is if there's only one
    ),
    # Convert to Date format using lubridate or as.Date (handle potential non-standard date formats)
    `Infusion date` = as.numeric(`Infusion date`)) %>%
  # CTCAE Grade (Highest) is the column for (ir)AE grade
  rename(patient_id = `Subject ID`, ctcae_grade = `CTCAE Grade (Highest)`, group = `General irAE Classification`, cancer_type = `Primary Cancer Type`, age = `Age at Draw`, thyroid_cat = `Thyroid Category (JB)`, data_source = `Data Source`, ici_drug = `Immune Checkpoint Inhibitor`) %>%
  mutate(`Infusion date` = as.Date(as.numeric(`Infusion date`), origin = "1899-12-30"),
         `First irAE Onset or Thyroid Test Date` = as.Date(as.numeric(`First irAE Onset or Thyroid Test Date`), origin = "1899-12-30"),
         days_to_irae = as.numeric(difftime(`First irAE Onset or Thyroid Test Date`, `Infusion date`, units = "days")),
         cleaned_visit_info = case_when(
          str_detect(`Visit Descriptor`, "Healthy") ~ "baseline",
          str_detect(`Visit Descriptor`, "AID") ~ "baseline",
          str_detect(`Visit Descriptor`, "(?i)visit 1") ~ "baseline",  # Case-insensitive match for "Visit 1"
          str_detect(`Visit Descriptor`, "\\d+") ~ str_extract(`Visit Descriptor`, "\\d+"),
          str_detect(`Visit Descriptor`, "F/U") ~ "irAE F/U",
          str_detect(`Visit Descriptor`, "irAE") ~ "irAE",
          TRUE ~ "Other"),
         # fix 1 patient with NA cancer type but looks like lung from other column info
         cancer_type = if_else(patient_id == "LinsleyLab732066", "Lung", cancer_type),
         # combine multiple irAE cols
         irae_ex = paste(`irAE Documented (if any)`, `Documented irAE's (9/6/2024)`, sep = "_"),
         # if CTCAE grade is not-NA, group should be irAE... (some grade 1-2 ctcae were in non-irAE group before using updated category 9/6/24, using `General irAE Classification` as its cleaner metadata though otherwise
         group = if_else(!is.na(ctcae_grade), "irAE/SAE", group),
         thyroid_cat = if_else(is.na(thyroid_cat), "None", thyroid_cat),
         thyroid_irae_including_oor = if_else(str_detect(irae_ex, regex("thyroid", ignore_case = TRUE)) | str_detect(thyroid_cat, regex("Abnormal", ignore_case = TRUE)),
                                "Thyroid irAE", 
                                "No thyroid irAE"),
         thyroid_irae = if_else(str_detect(irae_ex, regex("thyroid", ignore_case = TRUE)),
                                "Thyroid irAE", 
                                "No thyroid irAE"),
         skin_irae = if_else(str_detect(irae_ex, regex("rash|itch|skin|dermatitis|Pruritis|Pruritus", ignore_case = TRUE)),
                                "Skin irAE", 
                                "No skin irAE"),
         pneumonitis_irae = if_else(str_detect(irae_ex, regex("pneumonitis", ignore_case = TRUE)),
                                "Pneumonitis", 
                                "No pneumonitis"),
         pneumonitis_irae_including_effusion = if_else(str_detect(irae_ex, regex("pneumonitis|effusion", ignore_case = TRUE)),
                                "Pneumonitis", 
                                "No pneumonitis"),
         gastro_irae = if_else(str_detect(irae_ex, regex("nausea|esophagitis|diarrhea", ignore_case = TRUE)),
                                "Gastrointestinal irAE", 
                                "No gastrointestinal irAE"),
         rheumatoid_irae = if_else(str_detect(irae_ex, regex("arthritis|arthralgia|Arthalgia|edema", ignore_case = TRUE)),
                                "Rheumatoid irAE", 
                                "No rheumatoid irAE"),
         # clean up cancer types and ICI drugs
        cancer_type = case_when(
          cancer_type %in% c("head-neck", "head_and_neck") ~ "Head/neck",
          cancer_type %in% c("lung", "Lung") ~ "Lung",
          cancer_type == "urinary_tract" ~ "Urinary tract",
          cancer_type == "esophageal" ~ "Esophageal",
          cancer_type == "gastric" ~ "Gastric"),
               ici_drug = case_when(
                 ici_drug == "avelumab" ~ "Avelumab",
                 ici_drug == "cemiplimab" ~ "Cemiplimab",
                 ici_drug == "durvalumab" ~ "Durvalumab",
                 ici_drug %in% c("nivolumab", "nivolumab, other_antidpl") ~ "Nivolumab/other",
                 ici_drug == "pembrolizumab" ~ "Pembrolizumab",
         )) %>%
  select(patient_id, group, ctcae_grade, cancer_type, cleaned_visit_info, Batch, age, irae_ex, days_to_irae, thyroid_cat, thyroid_irae_including_oor, thyroid_irae, skin_irae, pneumonitis_irae, pneumonitis_irae_including_effusion, gastro_irae, rheumatoid_irae, data_source, ici_drug, starts_with("pct_")) %>%
  pivot_longer(
    cols = starts_with("pct_"), 
    names_to = "sort",
    values_to = "freq") %>%
  mutate(parent_population = gsub(".*_of_", "", sort),
         parent_population = gsub("_", " ", parent_population),
         parent_parent_population = str_extract(parent_population, "[^ ]+$"),
         sort = gsub("pct_", "", sort),
         sort = gsub("_", " ", sort)
  ) %>%
  dplyr::filter(freq > 0) %>%
  # get rid of technically variable features
  dplyr::filter(!(sort %in% c("granulocytes of live", "PD1pos of DN Bcells", "PD1pos of naive Bcells", "PD1pos of swMem Bcells", "PD1pos of unswMem Bcells", "basophils of nonGrans", "EMRA of Tconv Tcells", "CXCR6pos of NN CD8 Tcells", "CXCR6posGrzmBpos of NN CD8 Tcells"))) %>%
  # manually fix a few days_to_irae values that were wonky (besides negative ones that are ignored nicely)
  mutate(days_to_irae = case_when(
    patient_id == "LinsleyLab017509" ~ 42,
    patient_id == "LinsleyLab479010" ~ 70,
    patient_id == "LinsleyLab722615" ~ 50,
    TRUE ~ days_to_irae
  ))
    
# only 2 patients with serious (grade > 2) irAEs

flow_data

```

# Summarize cancer cohort metadata

```{r}

cohort_metadata_long <- flow_data %>%
  # fix thyroid test dates as irAE dates for no irAE group
  mutate(days_to_irae = if_else(group == "non-irAE", NA, days_to_irae)) %>%
  # subset for cancer patients
  dplyr::filter(group %in% c("non-irAE", "irAE/SAE")) %>%
  # ignore pivoted freq/longitudinal info, just get 1 metadata row/patient
  group_by(patient_id) %>%
  slice(1) %>%
  ungroup() %>%
  # standardize irae_ex for non-irAE group
  mutate(irae_ex = if_else(group == "non-irAE", "None", irae_ex)) %>%
  # Split irae_ex into multiple rows for multiple irAEs/patient
  separate_rows(irae_ex, sep = ";\\s*|_|,\\s*") %>%
  # standardize values for toxicities, here are irAE keywords
  # rash, Arthralgia, Fatigue, pneumonitis, esophagitis, nausea, itching, Hypothyroidism/hyper, edema, Pruritus, Arthritis, skin, Encephalitis, AKI, hepatitis, diarrhea, dermatitis, Pericardial/Pleural effusion
  mutate(
    irae_ex = case_when(
      grepl("rash|itch|skin|dermatitis|Pruritis|Pruritus", irae_ex, ignore.case = TRUE) ~ "Skin",
      grepl("Thyroid", irae_ex, ignore.case = TRUE) ~ "Thyroid",
      grepl("Arthritis|Arthalgia|Arthralgia", irae_ex, ignore.case = TRUE) ~ "Rheumatoid",
      grepl("Encephalitis", irae_ex, ignore.case = TRUE) ~ "Encephalitis",
      grepl("Pericardial/Pleural effusion", irae_ex, ignore.case = TRUE) ~ "Pericardial/pleural effusion",
      grepl("edema", irae_ex, ignore.case = TRUE) ~ "Edema",
      grepl("Fatigue", irae_ex, ignore.case = TRUE) ~ "Fatigue",      
      grepl("esophagitis", irae_ex, ignore.case = TRUE) ~ "Esophagitis",
      grepl("pneumonitis", irae_ex, ignore.case = TRUE) ~ "Pneumonitis",
      grepl("nausea", irae_ex, ignore.case = TRUE) ~ "Nausea",      
      grepl("AKI", irae_ex, ignore.case = TRUE) ~ "AKI",      
      grepl("hepatitis", irae_ex, ignore.case = TRUE) ~ "Hepatitis",    
      grepl("diarrhea", irae_ex, ignore.case = TRUE) ~ "Diarrhea",      
      # everything else is just redundant/useless info I believe
      TRUE ~ NA
    ),
    patient_id = gsub("LinsleyLab", "", patient_id),
    ctcae_grade = as.character(ctcae_grade),
    age = as.character(age),
    days_to_irae = as.character(days_to_irae)
  ) %>%
  # get rid of redundant/unnecessary irAE info
  group_by(patient_id, irae_ex) %>%
  slice(1) %>%
  ungroup() %>%
  # gather variables into long format for plotting
  pivot_longer(cols = c(cancer_type, irae_ex, ctcae_grade, data_source, ici_drug, days_to_irae),
               names_to = "variable", values_to = "value") %>%
  dplyr::filter(!(is.na(value))) %>%
  mutate(variable = case_when(
    variable == "cancer_type" ~ "Cancer\ntype",
    variable == "irae_ex" ~ "irAE\ntype",
    variable == "ctcae_grade" ~ "CTCAE\ngrade",
    variable == "data_source" ~ "Data\nsource",
    variable == "ici_drug" ~ "ICI\ndrug",
    variable == "days_to_irae" ~ "Days\nto irAE",
    TRUE ~ variable
  ))

cohort_metadata_long <- cohort_metadata_long %>%
  mutate(value = case_when(
    #variable == "Cancer\ntype" ~ factor(value, levels = c("Type1", "Type2", "Type3")),  # Replace with actual cancer types
    #variable == "Data\nsource" ~ factor(value, levels = c("Source1", "Source2")),  # Replace with actual data sources
    #variable == "ICI\ndrug" ~ factor(value, levels = c("Drug1", "Drug2", "Drug3")),  # Replace with actual ICI drugs
    #variable == "irAE\ntype" ~ factor(value, levels = c("Skin", "Thyroid", "Arthritis", "Encephalitis", "Fatigue", "Edema", "Nausea", "AKI")),  # Replace with actual irAE types
    variable == "Days\nto irAE" ~ factor(value, levels = sort(unique(as.numeric(value)))),  # Keep numeric sorted for 'Days to irAE'
    #variable == "CTCAE\ngrade" ~ factor(value, levels = c("Grade1", "Grade2", "Grade3", "Grade4")),  # Replace with actual CTCAE grades
    TRUE ~ factor(value)  # Default case for other variables
  ))

cohort_metadata_long$variable <- factor(
  cohort_metadata_long$variable, 
  levels = c("Data\nsource", "Cancer\ntype", "ICI\ndrug", "irAE\ntype", "CTCAE\ngrade", "Days\nto irAE")
)

# just split into 2 plots with issues with some numeric and some character

cohort_metadata_long_char <- cohort_metadata_long %>%
  dplyr::filter(variable != "Days\nto irAE")

p <- ggplot(cohort_metadata_long_char %>% dplyr::filter(!(variable %in% c("Data\nsource"))), aes(x = patient_id, y = value)) +
  geom_point(aes(color = group), size = 1.25) +
  facet_grid(variable ~ group, scales = "free", space = "free_y") +
  labs(x = "Patient ID", y = "") +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 10),
        legend.text = element_text(size = 12),
        axis.text.y = element_text(size = 11))

p

ggsave("../figures/metadata_char.svg", p, width = 7, height = 6)

cohort_metadata_long_num <- cohort_metadata_long %>%
  dplyr::filter(variable == "Days\nto irAE") %>%
  mutate(value = as.numeric(as.character(value))) %>%
  select(patient_id, group, variable, value)

missing_rows <- data.frame(
  patient_id = c("236490", "575762"),
  group = c("irAE/SAE", "irAE/SAE"),
  variable = "Days\nto irAE",
  value = NA
)

cohort_metadata_long_num <- rbind(cohort_metadata_long_num, missing_rows)

# create dummy no irAE group data
dummy_rows <- data.frame(
  patient_id = 1:24,
  value = NA,
  group = "non-irAE",
  variable = "Days\nto irAE"
)
cohort_metadata_long_num_dummy <- rbind(cohort_metadata_long_num, dummy_rows)

p <- ggplot(cohort_metadata_long_num_dummy, aes(x = patient_id, y = log2(value))) +
  geom_point(aes(color = group), size = 1.25) +
  facet_grid(variable ~ group, scales = "free", space = "free_y") +
  labs(x = "Patient ID", y = "") +
  scale_y_continuous(
    breaks = log2(c(1, 2, 4, 8, 16, 32, 64, 128, 256, 512)), # Custom breaks
    labels = c(1, 2, 4, 8, 16, 32, 64, 128, 256, 512)        # Labels as original values
  ) +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 10),
        legend.text = element_text(size = 12),
        axis.text.y = element_text(size = 11))

p

ggsave("../figures/metadata_num.svg", p, width = 5.5, height = 2)

```

# Look at how many cancer patients are represented across multiple batches
 - if patients were split across batches, could try other batch effect tools/ideas

```{r}

flow_data %>%
  filter(group %in% c("non-irAE", "irAE/SAE")) %>%
  group_by(patient_id, group, cleaned_visit_info, Batch) %>%
  slice(1) %>%
  ungroup() %>%
  group_by(patient_id) %>%
  summarize(batch_count = n_distinct(Batch))

# all patients' longitudinal data are in the same batch

```

# Look at ages and group distributions by batch, seem to be pretty similar except for batch 7 (no non-irAE patients)

```{r}

flow_data %>%
  group_by(Batch) %>%
  summarize(avg_age = mean(age, na.rm = TRUE))

flow_data %>%
  # deal w/ pivoted format
  group_by(patient_id) %>%
  slice(1) %>%
  ungroup() %>%
  group_by(Batch, group) %>%
  summarize(count = n())

```

# Define logit transform func

```{r}

logitNorm <- function(v){
  newVals <- v
  # Check to see if it's 0 to 1 or 0 to 100, and then switch it to 0 to 1
  if( any(v>1) & all(v<=100) ){
    newVals <- v/100
  }
  # if there are 0s or 1s, add/subtract a small value
  # so the logit norm is defined
  epsilon <- min(newVals[newVals!=0])/2
  newVals[newVals==0] <- epsilon
  newVals[newVals==1] <- 1-epsilon
  # Do the logit norm
  newVals <- log2(newVals/(1-newVals))
  if( any(is.na(newVals))){
    print(head(data.frame(v,newVals)))
  }
  return(newVals)
}

```

# Compare how cancer patients' features frequencies correlatations differ in each batch
 - these look different, i.e. batch effects

```{r}

corr_df <- flow_data %>%
  filter(group %in% c("non-irAE", "irAE/SAE")) %>%
  mutate(freq = logitNorm(freq)) %>%
  select(patient_id, cleaned_visit_info, Batch, sort, freq) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(Batch = as.factor(Batch)) %>%
  mutate(across(where(is.numeric), ~ scale(.))) %>%
  select(-patient_id, -cleaned_visit_info) %>%
  group_by(Batch) %>%
  group_split() %>% 
  lapply(function(batch_data) {
    batch_id <- unique(batch_data$Batch)
    batch_corr <- cor(batch_data[,-1], use = "pairwise.complete.obs")
    list(Batch = batch_id, CorrelationMatrix = batch_corr)
  })

corr_df

heatmap_plots <- lapply(corr_df, function(corr_obj) {
  batch_id <- corr_obj$Batch
  corr_matrix <- corr_obj$CorrelationMatrix
  corr_melt <- melt(corr_matrix)
  
  ggplot(corr_melt, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile() +
    scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0,
                         limit = c(-1, 1), name = "Correlation") +
    labs(title = paste("Batch", batch_id, "Correlation Heatmap")) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
})

for (i in seq_along(heatmap_plots)) {
  print(heatmap_plots[[i]])
}

```

# Plot PCA results before batch regressed out, color by batch
 - another way to see batch effects

```{r}

pca_df <- flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, irae_ex, ici_drug, data_source)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(Batch = as.factor(Batch),
         patient_id = as.factor(patient_id))

wide_baseline_flow_metadata <- pca_df[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data <- (pca_df)[, 17:ncol(pca_df)] %>%
  # Z-score normalize across samples for each feature
  mutate(across(where(is.numeric), ~ scale(.)))

# don't drop NA rows, instead remove features (cols) with an NA
# remove 22/71 features with NAs
na_count_per_feature <- colSums(is.na(wide_baseline_flow_num_data))
wide_baseline_flow_num_data <- wide_baseline_flow_num_data[, na_count_per_feature == 0]

#dim(wide_baseline_flow_num_data)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = Batch), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = Batch), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_color_by_batch_batch_not_regressed_out.png", plot = p, width = 3, height = 3.5)

```

# Look for significant features b/w irAE groups using limma & design matrix

```{r}

limma_df <- flow_data %>%
  # subet for baseline data
  filter(cleaned_visit_info == "baseline") %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, irae_ex, ici_drug, data_source)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(across(17:ncol(.), ~ scale(.)))

limma_df

# Convert group and Batch to factors
# using group as just skin_irae yes/no since that's the 1 contrast where I see results
limma_df$group <- factor(limma_df$skin_irae)
limma_df$Batch <- factor(limma_df$Batch)

# Create the design matrix with the formula and contrasts argument
design <- model.matrix(~0 + group + Batch, data = limma_df)

colnames(design) <- gsub("group", "", colnames(design))
# make colnames work, replace special chars with _
colnames(design) <- gsub("\\s|/|-", "_", colnames(design))

# Step 2: Contrast matrix for group comparisons
contrasts <- makeContrasts(
   irae_comparison = `Skin_irAE` - `No_skin_irAE`,
   levels = colnames(design)
)

# transpose
transposed_num_data <- limma_df[, 17:ncol(limma_df)] %>% t()

# Step 4: Linear modeling
# block batch here is redundant I think with design above, but keeping
corfit <- duplicateCorrelation(transposed_num_data, design, block=limma_df$Batch)
fit <- lmFit(transposed_num_data, design, block=limma_df$Batch, correlation=corfit$consensus)

# Step 5: Apply contrasts and compute statistics
fit2 <- contrasts.fit(fit, contrasts)
efit <- eBayes(fit2)

# results
topTable(efit, coef="irae_comparison", n=Inf)

# using this method...
# combined irAEs: no features w/ padj < 0.1

# skin irAEs: several hits with padj < 0.1
# padj < 0.01 CD11c+ of Bcells (this had padj just over 0.05 with limma::removeBatchEffects), Bcells of nongrans, Tcells of nongrans
# padj < 0.05: NKcells of nongrans, CXCR3+ of NN Tconv Tcells, CXCR3+CCR6+ of NN Tconv Tcells, naive of Treg Tcells, CCR4+ of NN CD8 Tcells
# padj < 0.05 & see these also with limma:removeBatchEffects & stats after that on adjusted data: CM of Tconv Tcells, DN of Bcells, CM of CD8 Tcells

# thyroid irAEs: no features w/ padj < 0.1
# pneumonitis: no features w/ padj < 0.1
# rheumatoid irAE: no features w/ padj < 0.1

```

# Try another approach: removeBatchEffect (limma), then stats on adjusted data

```{r}

remove_batch_effects_df <- flow_data %>%
  # filter for baseline data as not sure how to use this function with longitudinal data
  filter(cleaned_visit_info == "baseline") %>%
  mutate(freq = logitNorm(freq),
       ctcae_grade = as.factor(coalesce(ctcae_grade, 0))) %>%
  select(patient_id, group, ctcae_grade, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, cleaned_visit_info, Batch, sort, freq) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(Batch = as.factor(Batch)) %>%
  mutate(across(where(is.numeric), ~ scale(.)))

remove_batch_effects_df_t <- remove_batch_effects_df %>%
  select(-c(patient_id, group, ctcae_grade, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, cleaned_visit_info, Batch)) %>%
  t()

#patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, cleaned_visit_info, Batch

colnames(remove_batch_effects_df_t) <- paste(remove_batch_effects_df$patient_id, remove_batch_effects_df$group, remove_batch_effects_df$ctcae_grade, remove_batch_effects_df$skin_irae, remove_batch_effects_df$thyroid_irae, remove_batch_effects_df$pneumonitis_irae, remove_batch_effects_df$rheumatoid_irae, remove_batch_effects_df$cleaned_visit_info, remove_batch_effects_df$Batch, sep = "_")

# no longer need visit_info here
design_mat <- model.matrix(~ 0 + group, data = remove_batch_effects_df)

adjusted_data <- limma::removeBatchEffect(
  x = remove_batch_effects_df_t,
  batch = remove_batch_effects_df$Batch,
  design = design_mat
) %>%
  t()

metadata <- rownames(adjusted_data) %>%
  str_split_fixed("_", 9) %>%
  as.data.frame() %>%
  setNames(c("patient_id", "group", "ctcae_grade", "skin_irae", "thyroid_irae", "pneumonitis_irae", "rheumatoid_irae", "cleaned_visit_info", "Batch"))

adjusted_data <- adjusted_data %>%
  bind_cols(metadata) %>%
  # although using all data to remove batch effect, will be focusing on baseline cancer data for now
  filter(cleaned_visit_info == "baseline", group %in% c("non-irAE", "irAE/SAE"))

adjusted_data

```

# Try another approach (lmer of all data with batch as fixed effect, patient_id as fixed effect)
 - this feels best, using most data to regress out batch effects, will just use this adjusted_data downstream

```{r}

lmer_df <- flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, irae_ex, ici_drug, data_source)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(Batch = as.factor(Batch)) %>%
  dplyr::filter(!(is.na(patient_id)))

lmer_df

metadata_cols <- lmer_df[, 1:16]
feature_cols <- lmer_df[, 17:ncol(lmer_df)] %>%
  mutate(across(where(is.numeric), ~ scale(.)))

# Function to regress out confounders (batch) for each feature
regress_out_confounders <- function(freq, batch, patient_id) {
  # Build the linear model and get residuals
  model <- lmer(freq ~ batch + (1|patient_id))
  residuals(model)
}

adjusted_data <- (lapply(feature_cols,
                         regress_out_confounders,
                         batch = lmer_df$Batch,
                         patient_id = lmer_df$patient_id))

for (col in colnames(lmer_df[, 17:ncol(lmer_df)])) {
  not_missing_index <- !is.na(lmer_df[[col]])
  # replace only non-NA values from original data
  lmer_df[[col]][not_missing_index] <- adjusted_data[[col]]
}

adjusted_data <- lmer_df

adjusted_data

write.csv(adjusted_data, "../saved_data/batch_effect_removed_data.csv")

```

# Plot PCA results for baseline data with batch regressed out, color by batch

```{r}

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(where(~ sum(is.na(.)) <= 1))

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

pcaData <- pcaData[sample(nrow(pcaData)), ]

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = Batch), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = Batch), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2]) #+
  #xlim(-1, 1) + ylim(-1, 1)

p

ggsave("../figures/baseline_pca_color_by_batch_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

```

# Filter data for baseline cancer analyses below

```{r}

adjusted_data <- adjusted_data %>%
  dplyr::filter(cleaned_visit_info == "baseline", group %in% c("non-irAE", "irAE/SAE"))

# show features with > 5% NAs, remove them when doing PCA
na_counts <- colSums(is.na(adjusted_data[, 17:ncol(adjusted_data)]))
na_ridden_features <- names(na_counts[na_counts > 0.05*nrow(adjusted_data)])

```

# Look at ratio of activation markers to IRs

```{r}

# tried CD4/8 together and see result but don't see if CD4/8 separately...

# only looks like able to do this for T cells
activation_features <- c("ICOSpos of Tfh Tconv Tcells", "CXCR3pos of NN Tconv Tcells", 
                         "CXCR3posCCR6pos of NN Tconv Tcells", "GrzmBpos of NN CD8 Tcells", 
                         "CD38hiCD127neg of NN CD8 Tcells")

ir_features <- c("PD1pos of gd Tcells", "PD1pos of DN Tcells", "PD1pos of CM Treg Tcells", 
                 "PD1pos of EM Treg Tcells", "PD1pos of CM CD8 Tcells", 
                 "PD1pos of EM CD8 Tcells", "PD1pos of EMRA CD8 Tcells", 
                 "PD1posCD27neg of EMRA CD8 Tcells", "KLRG1posTIGITpos of EM Tconv Tcells", 
                 "KLRG1posTIGITpos of NN CD8 Tcells")

t_cell_activation_ir_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  filter(sort %in% c(activation_features, ir_features)) %>%
  mutate(feature_type = ifelse(sort %in% activation_features, "Activation", "IR")) %>%
  group_by(patient_id, group, cleaned_visit_info, feature_type) %>%
  summarize(avg_value = mean(value, na.rm = TRUE), .groups = "drop") %>%
  pivot_wider(names_from = feature_type, values_from = avg_value) %>%
  mutate(ratio = Activation / IR)

t_cell_activation_ir_df

ggplot(t_cell_activation_ir_df, aes(x = group, y = ratio, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  labs(x = "", y = "T cell activation:IR ratio", fill = "irAE group")

# Test for normality
shapiro_test <- t_cell_activation_ir_df %>%
  group_by(group) %>%
  summarize(p_value = shapiro.test(ratio)$p.value)

# Decide on test based on normality results
if (all(shapiro_test$p_value > 0.05)) {
  # Both groups are normal, use t-test
  stats_result <- t.test(ratio ~ group, data = t_cell_activation_ir_df)
} else {
  # At least one group is non-normal, use Wilcoxon test
  stats_result <- wilcox.test(ratio ~ group, data = t_cell_activation_ir_df)
}

stats_result$p.value

```

# Baseline data with batch regressed out, test combined irAE yes vs. no

```{r}

stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[group == "non-irAE"])$p.value > 0.05,
                       shapiro.test(value[group == "irAE/SAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ group)$p.value else wilcox.test(value ~ group)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(pval) %>%
  dplyr::filter(!(sort %in% na_ridden_features)) %>%
  head(4)

stats_df

plot_data <- adjusted_data %>% select(group, `SCM of Tconv Tcells`) %>%
  pivot_longer(cols = c(`SCM of Tconv Tcells`), names_to = "sort", values_to = "freq")

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color = "black", size = 0.5) +
  labs(x = "", y = "SCM of Tconv\nTcells (residuals)", fill = "irAE group") +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 12))

p

ggsave("../figures/batch_regressed_out_residuals_by_feature_hit_combined_irae.png", plot = p, width = 6, height = 4)

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

# instead of filtering for no NA, remove features in na_ridden_features list and impute rest of NAs
# instead of using stats df-way of selecting top features, take them from random forest analysis: SCM of Tconv Tcells, DN of Tcells, EM of CD8s, Tcells of nonGrans
wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(-na_ridden_features) %>% mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>% select(`SCM of Tconv Tcells`, `DN of Tcells`, `EM of CD8 Tcells`, `Tcells of nonGrans`)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1 <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2 <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3 <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = group), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = group), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_combined_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      group = pcaData$group)
res <- compareGroups(group ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# make pretty PCA contribution tables
styled_table <- pca_contributions %>%
  rename(PC1 = Dim.1, PC2 = Dim.2, PC3 = Dim.3) %>%
  mutate(PC1 = round(PC1, 3), PC2 = round(PC2, 3), PC3 = round(PC3, 3)) %>%
  select(PC2) %>%
  kable("html") %>%
  kable_styling(full_width = FALSE, # Adjust width if needed
                bootstrap_options = c("striped", "hover", "condensed", "responsive"), # Add styling options
                position = "left")  # Align table to the left

html_file <- "../figures/combined_irae_pca_contributions_table.html"
save_kable(styled_table, file = html_file)

```

# Instead of top 4 features for combined irAE, iteratively choose a random set of 4 features (to get at that I'm overfitting to dataset's noise here)
 - using 75k random sets of size 4, see ~similarly significant results as when choosing top 4 arbitrarily ~1.2% of the time...

```{r}

num_iterations <- 1000  # Number of random subsets
num_features <- 4       # Number of features in each subset
results <- list()       # To store results from each iteration

# Random Sampling and PCA Loop
set.seed(123)  # For reproducibility
for (i in 1:num_iterations) {
  # Randomly sample features
  sampled_features <- sample(colnames(adjusted_data[, 17:ncol(adjusted_data)]), num_features)
  
  # Subset data and handle NAs
  pca_data <- adjusted_data %>%
    select(all_of(sampled_features)) %>%
    mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))
  
  # Perform PCA
  pca <- prcomp(pca_data, center = TRUE, scale. = TRUE)
  pca_scores <- as.data.frame(pca$x)
  pca_scores$skin_irae <- adjusted_data$skin_irae
  
  # Test for differences between groups on PCA axes
  pc1_pval <- if (shapiro.test(pca_scores$PC1)$p.value > 0.05) {
    t.test(PC1 ~ skin_irae, data = pca_scores)$p.value
  } else {
    wilcox.test(PC1 ~ skin_irae, data = pca_scores)$p.value
  }
  
  pc2_pval <- if (shapiro.test(pca_scores$PC2)$p.value > 0.05) {
    t.test(PC2 ~ skin_irae, data = pca_scores)$p.value
  } else {
    wilcox.test(PC2 ~ skin_irae, data = pca_scores)$p.value
  }
  
  pc3_pval <- if (shapiro.test(pca_scores$PC3)$p.value > 0.05) {
    t.test(PC3 ~ skin_irae, data = pca_scores)$p.value
  } else {
    wilcox.test(PC3 ~ skin_irae, data = pca_scores)$p.value
  }
  
  # Record results
  results[[i]] <- list(
    features = sampled_features,
    pc1_pval = pc1_pval,
    pc2_pval = pc2_pval,
    pc3_pval = pc3_pval
  )
}

# Summarize Results
results_df <- bind_rows(lapply(results, function(x) {
  data.frame(
    features = paste(x$features, collapse = ", "),
    PC1_pval = x$pc1_pval,
    PC2_pval = x$pc2_pval,
    PC3_pval = x$pc3_pval
  )
}))

# combined: 1 < 0.01 --> p < 0.05 here for monte carlo
# skin just 1 < 0.05 --> p > 0.05 here for monte carlo (if using random forest module, if using top 4 by pval arranging then p < 0.01...)
# pneumonitis 2/3 < 0.001 and other < 0.01 --> p < 0.01 here for monte carlo (not surprising given 2 features statistically significant at baseline, so module works great really only if likely having these 2)
# rheumatoid 2 < 0.01 --> p < 0.01
# thyroid 1 < 0.001 and 1 < 0.05 --> p < 0.01 as well

# Filter for significant results
significant_results <- results_df %>%
  #filter(PC1_pval < 0.01 | PC2_pval < 0.01 | PC3_pval < 0.01)
  filter((PC1_pval < 0.05) + (PC2_pval < 0.05) + (PC3_pval < 0.05) >= 2)
  #filter(
  #  (PC1_pval < 0.001 & (PC2_pval < 0.05 | PC3_pval < 0.05)) |
  #  (PC2_pval < 0.001 & (PC1_pval < 0.05 | PC3_pval < 0.05)) |
  #  (PC3_pval < 0.001 & (PC1_pval < 0.05 | PC2_pval < 0.05))
  #)

significant_results

print(nrow(significant_results)/num_iterations*100)

feature_counts <- significant_results %>%
  separate_rows(features, sep = ", ") %>%
  count(features, sort = TRUE) %>%
  mutate(n = n/(4*num_iterations) * 100)

feature_counts

```

# Plot PCA results for baseline data with batch regressed out, thyroid irAEs specifically

```{r}

thyroid_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[thyroid_irae == "Thyroid irAE"])$p.value > 0.05,
                       shapiro.test(value[thyroid_irae == "No thyroid irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ thyroid_irae)$p.value else wilcox.test(value ~ thyroid_irae)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(pval) %>%
  filter(!(sort %in% na_ridden_features)) %>%
  head(4)

thyroid_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

# instead of filtering for no NA, remove features in na_ridden_features list and impute rest of NAs
wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(-na_ridden_features) %>% mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>% select(thyroid_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_thyroid <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_thyroid <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3_thyroid <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

# switch colors
pcaData$thyroid_irae <- factor(pcaData$thyroid_irae, levels = c("Thyroid irAE", "No thyroid irAE"))
                                 
p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = thyroid_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = thyroid_irae), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_thyroid_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      thyroid_irae = pcaData$thyroid_irae)
res <- compareGroups(thyroid_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# make pretty PCA contribution tables
styled_table <- pca_contributions %>%
  rename(PC1 = Dim.1, PC2 = Dim.2, PC3 = Dim.3) %>%
  mutate(PC1 = round(PC1, 3), PC2 = round(PC2, 3), PC3 = round(PC3, 3)) %>%
  kable("html") %>%
  kable_styling(full_width = FALSE, # Adjust width if needed
                bootstrap_options = c("striped", "hover", "condensed", "responsive"), # Add styling options
                position = "left")  # Align table to the left

html_file <- "../figures/thyroid_irae_pca_contributions_table.html"
save_kable(styled_table, file = html_file)

```

# Plot PCA results for baseline data with batch regressed out, thyroid irAEs (including OOR) specifically

```{r}

thyroid_including_oor_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[thyroid_irae_including_oor == "Thyroid irAE"])$p.value > 0.05,
                       shapiro.test(value[thyroid_irae_including_oor == "No thyroid irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ thyroid_irae_including_oor)$p.value else wilcox.test(value ~ thyroid_irae_including_oor)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(pval) %>%
  filter(!(sort %in% na_ridden_features)) %>%
  head(4)

thyroid_including_oor_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

# instead of filtering for no NA, remove features in na_ridden_features list and impute rest of NAs
wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(-na_ridden_features) %>% mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>% select(thyroid_including_oor_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_thyroid_with_oor <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_thyroid_with_oor <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3_thyroid_with_oor <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC3, color = thyroid_irae_including_oor), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC3, color = thyroid_irae_including_oor), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[3])

p

ggsave("../figures/baseline_pca_thyroid_irae_with_oor_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      thyroid_irae_including_oor = pcaData$thyroid_irae_including_oor)
res <- compareGroups(thyroid_irae_including_oor ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

```

# Plot PCA results for baseline data with batch regressed out, skin irAEs specifically

```{r}

skin_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[skin_irae == "Skin irAE"])$p.value > 0.05,
                       shapiro.test(value[skin_irae == "No skin irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ skin_irae)$p.value else wilcox.test(value ~ skin_irae)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(pval) %>%
  filter(!(sort %in% na_ridden_features)) %>%
  head(4)

skin_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

# instead of filtering for no NA, remove features in na_ridden_features list and impute rest of NAs
# instead use 4 features from random forest top importances
wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(-na_ridden_features) %>% mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>% select(`SCM of Tconv Tcells`, `DN of Tcells`, `Tcells of nonGrans`, `PD1pos of CM Tconv Tcells`)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_skin <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_skin <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3_skin <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

# switch colors
pcaData$skin_irae <- factor(pcaData$skin_irae, levels = c("Skin irAE", "No skin irAE"))

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC3, color = skin_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC3, color = skin_irae), size = 1, linetype = 2) +
  #scale_color_manual(values = c("HC" = "purple", "AID" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  #scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = median(pcaData$age, na.rm = TRUE), limits = c(min(pcaData$age), max(pcaData$age))) +  # Blue-White-Red gradient with median age as white
  #xlim(-limits[1], limits[1]) +
  #ylim(-limits[2], limits[2]) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[3])

p

ggsave("../figures/baseline_pca_skin_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      skin_irae = pcaData$skin_irae)
res <- compareGroups(skin_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# make pretty PCA contribution tables
styled_table <- pca_contributions %>%
  rename(PC1 = Dim.1, PC2 = Dim.2, PC3 = Dim.3) %>%
  mutate(PC1 = round(PC1, 3), PC2 = round(PC2, 3), PC3 = round(PC3, 3)) %>%
  select(PC3) %>%
  kable("html") %>%
  kable_styling(full_width = FALSE, # Adjust width if needed
                bootstrap_options = c("striped", "hover", "condensed", "responsive"), # Add styling options
                position = "left")  # Align table to the left

html_file <- "../figures/skin_irae_pca_contributions_table.html"
save_kable(styled_table, file = html_file)

```

# Results for baseline data with batch regressed out, pneumonitis specifically

```{r}

pneumonitis_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[pneumonitis_irae == "Pneumonitis"])$p.value > 0.05,
                       shapiro.test(value[pneumonitis_irae == "No pneumonitis"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ pneumonitis_irae)$p.value else wilcox.test(value ~ pneumonitis_irae)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(pval) %>%
  filter(!(sort %in% na_ridden_features)) %>%
  head(4)

pneumonitis_stats_df

adjusted_data$pneumonitis_irae <- factor(
  adjusted_data$pneumonitis_irae, 
  levels = c("Pneumonitis", "No pneumonitis")
)

plot_data <- adjusted_data %>% select(pneumonitis_irae, `CD56bright of NKcells`, `PD1pos of NKcells`) %>%
  pivot_longer(cols = c(`CD56bright of NKcells`, `PD1pos of NKcells`), names_to = "sort", values_to = "freq")

p <- plot_data %>%
  ggplot(aes(x = pneumonitis_irae, y = freq, fill = pneumonitis_irae)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color = "black", size = 0.5) +
  facet_wrap(~ sort) +
  labs(x = "", y = "Residuals", fill = "Pneumonitis group") +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 12))

p

ggsave("../figures/batch_regressed_out_residuals_by_feature_hit_pneumonitis.png", plot = p, width = 9, height = 4)

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

# instead of filtering for no NA, remove features in na_ridden_features list and impute rest of NAs
wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(-na_ridden_features) %>% mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>% select(pneumonitis_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_pneumonitis <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_pneumonitis <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3_pneumonitis <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = pneumonitis_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = pneumonitis_irae), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      pneumonitis_irae = pcaData$pneumonitis_irae)
res <- compareGroups(pneumonitis_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

```

# Results for baseline data with batch regressed out, pneumonitis specifically (including effusion)

```{r}

pneumonitis_including_effusion_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[pneumonitis_irae_including_effusion == "Pneumonitis"])$p.value > 0.05,
                       shapiro.test(value[pneumonitis_irae_including_effusion == "No pneumonitis"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ pneumonitis_irae_including_effusion)$p.value else wilcox.test(value ~ pneumonitis_irae_including_effusion)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(pval) %>%
  filter(!(sort %in% na_ridden_features)) %>%
  head(4)

pneumonitis_including_effusion_stats_df

```

# Plot PCA results for baseline data with batch regressed out, rheumatoid irAEs

```{r}

rheumatoid_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[rheumatoid_irae == "Rheumatoid irAE"])$p.value > 0.05,
                       shapiro.test(value[rheumatoid_irae == "No rheumatoid irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ rheumatoid_irae)$p.value else wilcox.test(value ~ rheumatoid_irae)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(pval) %>%
  filter(!(sort %in% na_ridden_features)) %>%
  head(4)

rheumatoid_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

# instead of filtering for no NA, remove features in na_ridden_features list and impute rest of NAs
wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(-na_ridden_features) %>% mutate(across(everything(), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .))) %>% select(rheumatoid_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_rheumatoid_irae <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_rheumatoid_irae <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3_rheumatoid_irae <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

pcaData$rheumatoid_irae <- factor(pcaData$rheumatoid_irae, levels = c("Rheumatoid irAE", "No rheumatoid irAE"))

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC3, color = rheumatoid_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC3, color = rheumatoid_irae), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[3])

p

ggsave("../figures/baseline_pca_rhematoid_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      rheumatoid_irae = pcaData$rheumatoid_irae)
res <- compareGroups(rheumatoid_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# make pretty PCA contribution tables
styled_table <- pca_contributions %>%
  rename(PC1 = Dim.1, PC2 = Dim.2, PC3 = Dim.3) %>%
  mutate(PC1 = round(PC1, 3), PC2 = round(PC2, 3), PC3 = round(PC3, 3)) %>%
  select(PC1, PC3) %>%
  kable("html") %>%
  kable_styling(full_width = FALSE, # Adjust width if needed
                bootstrap_options = c("striped", "hover", "condensed", "responsive"), # Add styling options
                position = "left")  # Align table to the left

html_file <- "../figures/rheumatoid_irae_pca_contributions_table.html"
save_kable(styled_table, file = html_file)

```

# Plot PCA results for baseline data with batch regressed out, gastrointestinal irAEs
 - only 2 patients with gastrointestinal irAEs...

# Find features contributing most to variance for general and specific irAEs and compare

```{r}

all_features <- unique(c(
  rownames(top_contributing_features_PC1_thyroid),
  rownames(top_contributing_features_PC1),
  rownames(top_contributing_features_PC1_skin),
  rownames(top_contributing_features_PC1_pneumonitis),
  rownames(top_contributing_features_PC1_rheumatoid_irae),
  rownames(top_contributing_features_PC2_thyroid),
  rownames(top_contributing_features_PC2),
  rownames(top_contributing_features_PC2_skin),
  rownames(top_contributing_features_PC2_pneumonitis),
  rownames(top_contributing_features_PC2_rheumatoid_irae),
  rownames(top_contributing_features_PC3_thyroid),
  rownames(top_contributing_features_PC3),
  rownames(top_contributing_features_PC3_skin),
  rownames(top_contributing_features_PC3_pneumonitis),
  rownames(top_contributing_features_PC3_rheumatoid_irae)
  ))

merged_data <- data.frame(
  PC1_combined = top_contributing_features_PC1$Dim.1[match(all_features, rownames(top_contributing_features_PC1))],
  PC2_combined = top_contributing_features_PC2$Dim.2[match(all_features, rownames(top_contributing_features_PC2))],
  PC3_combined = top_contributing_features_PC3$Dim.3[match(all_features, rownames(top_contributing_features_PC3))],

  PC1_skin = top_contributing_features_PC1_skin$Dim.1[match(all_features, rownames(top_contributing_features_PC1_skin))],
  PC2_skin = top_contributing_features_PC2_skin$Dim.2[match(all_features, rownames(top_contributing_features_PC2_skin))],
  PC3_skin = top_contributing_features_PC3_skin$Dim.3[match(all_features, rownames(top_contributing_features_PC3_skin))],

  PC1_thyroid = top_contributing_features_PC1_thyroid$Dim.1[match(all_features, rownames(top_contributing_features_PC1_thyroid))],
  PC2_thyroid = top_contributing_features_PC2_thyroid$Dim.2[match(all_features, rownames(top_contributing_features_PC2_thyroid))],
  PC3_thyroid = top_contributing_features_PC3_thyroid$Dim.3[match(all_features, rownames(top_contributing_features_PC3_thyroid))],
  
  PC1_pneumonitis = top_contributing_features_PC1_pneumonitis$Dim.1[match(all_features, rownames(top_contributing_features_PC1_pneumonitis))],
  PC2_pneumonitis = top_contributing_features_PC2_pneumonitis$Dim.2[match(all_features, rownames(top_contributing_features_PC2_pneumonitis))],
  PC3_pneumonitis = top_contributing_features_PC3_pneumonitis$Dim.3[match(all_features, rownames(top_contributing_features_PC3_pneumonitis))],
  
  PC1_rheumatoid = top_contributing_features_PC1_rheumatoid_irae$Dim.1[match(all_features, rownames(top_contributing_features_PC1_rheumatoid_irae))],
  PC2_rheumatoid = top_contributing_features_PC2_rheumatoid_irae$Dim.2[match(all_features, rownames(top_contributing_features_PC2_rheumatoid_irae))],
  PC3_rheumatoid = top_contributing_features_PC3_rheumatoid_irae$Dim.3[match(all_features, rownames(top_contributing_features_PC3_rheumatoid_irae))]
)

rownames(merged_data) <- all_features

# p < 0.05
highlight_columns <- c(
  # For general, PC2
  "PC2_combined", 

  # For thyroid, PCs 1-2
  "PC1_thyroid",
  "PC2_thyroid",
  
  # For skin, PC3
  "PC3_skin", 

  # For pneumonitis, PCs 1-3
  "PC1_pneumonitis", 
  "PC2_pneumonitis", 
  "PC3_pneumonitis", 
  
  # For rheumatoid, PCs 1/3
  "PC1_rheumatoid",
  "PC3_rheumatoid"
)

filtered_data <- merged_data[, colnames(merged_data) %in% highlight_columns, drop = FALSE]

# Replace any NA values with 0
#filtered_data[is.na(filtered_data)] <- 0

filtered_data <- filtered_data %>%
  mutate(MaxValue = apply(., 1, function(x) max(x, na.rm = TRUE))) %>%  # Compute the max value per row, ignoring NA values
  arrange(desc(MaxValue)) %>%   # Order rows by the max value in descending order
  select(-MaxValue)  # Remove the temporary MaxValue column

# Clean up feature names (replace dots with spaces for clarity)
rownames(filtered_data) <- gsub("\\.", " ", rownames(filtered_data))

# Extract irAE_type and PC number from column names
column_annotations <- data.frame(
  irAE_type = sub("^[^_]+_", "", colnames(filtered_data)),  # Extract everything after the underscore
  PC = sub("PC", "", sub("_.*", "", colnames(filtered_data)))  # Extract only the number part before the underscore
)

column_annotations$irAE_type <- factor(column_annotations$irAE_type, 
                                       levels = c("combined", "skin", "thyroid", "pneumonitis", "rheumatoid"))

# Define colors for column annotations
annotation_colors <- list(
  irAE_type = c("combined" = "black", "skin" = "red", "thyroid" = "blue", "pneumonitis" = "green", "rheumatoid" = "pink"),
  PC = c("1" = "#440154FF", "2" = "#21908CFF", "3" = "#FDE725FF")
)

# Ensure column annotations are in the correct order for filtered_data
rownames(column_annotations) <- colnames(filtered_data)

# Create HeatmapAnnotation for columns with color annotations
col_anno <- HeatmapAnnotation(
  irAE_type = column_annotations$irAE_type,
  PC = column_annotations$PC,
  col = annotation_colors
)

specific_features <- c("naive of Bcells", "swMem of Bcells", "PD1pos of NKcells", "plasmablasts of Bcells", "CCR4pos of NN Tconv Tcells", "CD4 of Tcells")

row_split <- ifelse(rownames(filtered_data) %in% specific_features, 
                    "irAE-type-specific", 
                    "Non-specific")

# Create the heatmap with annotations for both the irAE type and PC number
p <- Heatmap(filtered_data, 
        name = "Contribution (%)", 
        row_names_gp = gpar(fontsize = 10),
        column_names_gp = gpar(fontsize = 10),
        cluster_rows = FALSE, 
        cluster_columns = FALSE,
        show_column_names = FALSE, 
        top_annotation = col_anno,
        heatmap_legend_param = list(title = "Contribution (%)"),
        # split rows based on irAE-type-specific or not
        row_split = row_split,
        show_row_names = TRUE)

# Save the heatmap to a PDF file
pdf(file = "../figures/irae_types_contributing_features_highlighted.pdf", width = 10, height = 8)  # Adjust width and height as needed
draw(p)  # Render the heatmap
dev.off()  # Close the PDF device

```

# Look for correlation b/w irAE grade/time to irAE and freq for each feature/subset (baseline)

```{r}

ctcae_cor_df <- adjusted_data %>%
  filter(cleaned_visit_info == "baseline", group %in% c("non-irAE", "irAE/SAE")) %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, Batch, age, thyroid_irae, thyroid_irae_including_oor, skin_irae, pneumonitis_irae, pneumonitis_irae_including_effusion, gastro_irae, rheumatoid_irae, days_to_irae, thyroid_cat, cancer_type, cleaned_visit_info), names_to = "sort", values_to = "freq") %>%
  # replace non-irAE CTCAE grade (NA) with 0 to include in analysis
  mutate(ctcae_grade = if_else(is.na(ctcae_grade), 0, ctcae_grade)) %>%
  group_by(sort) %>%
  summarize(kruskal_result = list(kruskal.test(freq ~ as.factor(ctcae_grade))), .groups = 'drop') %>%
  mutate(
    p.value = map_dbl(kruskal_result, ~ .x$p.value)
  ) %>%
  mutate(p.adj = p.adjust(p.value, method = "BH")) %>%
  select(sort, p.value, p.adj) %>%
  arrange(p.adj) %>%
  print()

time_to_irae_df <- adjusted_data %>%
  filter(cleaned_visit_info == "baseline", group %in% c("non-irAE", "irAE/SAE")) %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, Batch, age, thyroid_irae, thyroid_irae_including_oor, skin_irae, pneumonitis_irae, pneumonitis_irae_including_effusion, gastro_irae, rheumatoid_irae, days_to_irae, thyroid_cat, cancer_type, cleaned_visit_info), names_to = "sort", values_to = "freq") %>%
  filter(group == "irAE/SAE") %>%
  group_by(sort) %>%
  summarize(cor_result = list(cor.test(days_to_irae, freq, method = "spearman")), .groups = 'drop') %>%
  mutate(
    estimate = map_dbl(cor_result, ~ .x$estimate),
    p.value = map_dbl(cor_result, ~ .x$p.value)
  ) %>%
  mutate(p.adj = p.adjust(p.value, method = "BH")) %>%
  select(sort, estimate, p.adj) %>%
  arrange(p.adj) %>%
  print()

```

# Determine clusters in PCA space, then test for enrichment of study groups in clusters

```{r}

# Elbow method to determine optimal number of clusters
set.seed(123)
wss <- sapply(1:10, function(k) {
  kmeans(pcaData[, c("PC1", "PC2", "PC3")], centers = k, nstart = 25)$tot.withinss
})

# Plot the Elbow curve
plot(1:10, wss, type = "b", pch = 19, frame = FALSE, xlab = "Number of clusters", ylab = "Total within-cluster sum of squares")

kmeans_result <- kmeans(pcaData[, c("PC1", "PC2", "PC3")], centers = 10, nstart = 25)

# Add cluster assignments to the data
pcaData$cluster <- factor(kmeans_result$cluster)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = cluster), size = 2, alpha = 0.8) +  # Color by cluster
  labs(color = "Cluster") +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

table_result <- table(pcaData$cluster, pcaData$group)

chisq_test <- chisq.test(table_result)
chisq_test
fisher_test <- fisher.test(table_result)
fisher_test

```

# Make VP of changes between irAE and no irAE groups

```{r}

df <- adjusted_data

irae_group <- df %>% dplyr::filter(group == "irAE/SAE")
no_irae_group <- df %>% dplyr::filter(group == "non-irAE")

non_feature_cols <- c("patient_id", "group", "specific_group", "irae_ex", "Batch", 
                      "age", "ctcae_grade", "thyroid_irae", "thyroid_irae_including_oor", "skin_irae", "days_to_irae", "thyroid_cat")
feature_columns <- setdiff(colnames(df), non_feature_cols)

# Calculate mean residuals for each feature
irae_means <- (irae_group %>% select(all_of(feature_columns)) %>% summarise_all(mean))
no_irae_means <- no_irae_group %>% select(all_of(feature_columns)) %>% summarise_all(mean)

abs_diff <- (as.numeric(irae_means) - as.numeric(no_irae_means))
#log2_fc <- sign(fc) * log2(abs(fc))

pvals <- sapply(feature_columns, function(feature) {
  wilcox.test(irae_group[[feature]], no_irae_group[[feature]])$p.value
})

padj <- p.adjust(pvals, method = "BH")

volcano_df <- data.frame(
  feature = feature_columns,
  abs_diff = abs_diff,
  padj = padj,
  neg_log10_padj = -log10(padj)
)

ggplot(volcano_df, aes(x = abs_diff, y = neg_log10_padj)) +
  geom_point(aes(color = padj < 0.1)) +
  theme_minimal() +
  labs(x = "irAE/SAE vs. no irAE (absolute difference in mean of residuals)", y = "-log10(padj)") +
  geom_vline(xintercept = 0, linetype = "dashed") + # Vertical line at 0 fold change +
  geom_hline(yintercept = -log10(0.1), linetype = "dashed") + # horizontal line at sig threshold
  geom_text_repel(data = subset(volcano_df, padj < 0.35), 
                  aes(label = feature), size = 3, box.padding = 0.5, max.overlaps = 10)

```

# Make a boxplot for features of interest (from literature) after regressing out batch

```{r}

# features of interest from literature
# DN of Bcells"                    "CD8 of Tcells"                   "CD38hiCD127neg of NN CD8 Tcells"

plot_data <- adjusted_data %>% select(group, DN.of.Bcells, CD8.of.Tcells, `CD38hiCD127neg of NN CD8 Tcells`) %>%
  pivot_longer(cols = c(DN.of.Bcells, CD8.of.Tcells, `CD38hiCD127neg of NN CD8 Tcells`), names_to = "sort", values_to = "freq") %>%
  mutate(sort = case_when(
    sort == "CD8.of.Tcells" ~ "CD8 of Tcells",
    sort == "`CD38hiCD127neg of NN CD8 Tcells`" ~ "CD38hiCD127-\nof NN CD8s",
    sort == "DN.of.Bcells" ~ "DN of Bcells"
  ))

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~ sort, ncol = 3) +
  geom_jitter(color = "grey", size = 0.5) +
  labs(x = "", y = "Residuals (batch\nregressed out)") +
  scale_fill_manual(values = c("Healthy_Control" = "purple", "AID_Patient" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

ggsave("../figures/batch_regressed_out_residuals_by_feature_hits.png", plot = p, width = 7, height = 3.5)

```

# Find optimal number of components for ICA

```{r}

### Show example of one splitting iteration
# Split the features into 2 ~equal sets
## Set seed for reproducibility
feats1 <- sample(colnames(wide_baseline_flow_num_data_confounders_regressed_out),round(ncol(wide_baseline_flow_num_data_confounders_regressed_out)/2) )
feats2 <- colnames(wide_baseline_flow_num_data_confounders_regressed_out)[!colnames(wide_baseline_flow_num_data_confounders_regressed_out) %in% feats1]
print( paste0("Num features: ", length(feats1), ", ", length(feats2)) )

# Generate 2 ICA models with the split genes with 8 components
ncomps <- 6
ica1 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats1], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
print(paste0("Sample ICA Weight Matrix Dimensions: ", nrow(ica1$S)," by ", ncol(ica1$S)) )
ica2 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats2], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)

## Correlate the components together
cormat <- cor(ica1$S, ica2$S,method="spearman")
rowMaxes <- apply(abs(cormat),1,max)
rownames(cormat) <- as.character( signif(rowMaxes,3))
Heatmap(abs(cormat), name="Pearson\nCorrelation",column_title="Pairwise Correlations Between Split ICA Models")
# Get the worst best correlation
minMaxR <- min( apply(abs(cormat),1,max) )
print( paste0("Worst best component correlation: ",minMaxR) )

## Function to compute worst best component correlation for a sequence of component numbers
getSplitMinMaxR <- function(nCompsSequence, data.tmp=wide_baseline_flow_num_data_confounders_regressed_out){ # get the minimum spearman correlation between the ICA components from the two splits
  
  # Split the features into 2 equal sets
  feats1 <- sample(colnames(wide_baseline_flow_num_data_confounders_regressed_out),round(ncol(wide_baseline_flow_num_data_confounders_regressed_out)/2) )
  feats2 <- colnames(wide_baseline_flow_num_data_confounders_regressed_out)[!colnames(wide_baseline_flow_num_data_confounders_regressed_out) %in% feats1]
  
  getMinMaxR <- function(ncomps){
    print(ncomps)
    ica1 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats1], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
    ica2 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats2], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
    cormat <- cor(ica1$S, ica2$S,method="spearman")
    vals <- c( minMaxR = min( apply(abs(cormat),2,max)), ncomps=ncomps )
  }
  
  minMaxRs <- data.frame( t(sapply( nCompsSequence, getMinMaxR)) )
  return(minMaxRs)
}

# Do two splits
nCompsSequence <- 2:15
numShuffles <- 2
minMaxRs <- lapply(1:numShuffles, function(i) getSplitMinMaxR(nCompsSequence, wide_baseline_flow_num_data_confounders_regressed_out) )
for( i in 1:length(minMaxRs) ){
  minMaxRs[[i]]$shuffleNumber <- i
}
print("Min Max Rs: ")
print(minMaxRs)
numShuffles <- length(minMaxRs)

getCorDiffs <- function( minMaxR ){
  corDiffs <- minMaxR$minMaxR[2:nrow(minMaxR)] - minMaxR$minMaxR[1:(nrow(minMaxR)-1) ]
  biggestDecline <- minMaxR$ncomps[ which( corDiffs == min(corDiffs)) ]
  print( paste0("Biggest Correlation Decline: ", biggestDecline, " to ", biggestDecline+1 ) )
  return(biggestDecline)
}

biggestDeclines <- sapply(minMaxRs,getCorDiffs)
biggestDeclineTab <- table(biggestDeclines)
ggplot() + geom_histogram( aes(x=biggestDeclines)) + labs(x="# of components before the largest decline")
optimalCompNum <- as.numeric( names(biggestDeclineTab)[biggestDeclineTab==max(biggestDeclineTab)] )
print(optimalCompNum)

## Make boxplot of results of correlations for all 50 subsamples
minMaxRsLong <- do.call(rbind,minMaxRs)
ggplot(minMaxRsLong,aes(x=ncomps,y=minMaxR)) + geom_boxplot(aes(group=ncomps)) + geom_line(aes(group=shuffleNumber), alpha=0.1,color="red") + labs(x="number of ICA components",y="Lowest Component\nSpearman Correlation",title=paste0( numShuffles," Feature 2-Way Splits\nMinMax Component Correlation")) + geom_vline(xintercept = optimalCompNum, linetype="dashed",color="blue")

```

# Run ICA with optimal num of components

```{r}

optimalCompNum <- 6  # or set to your identified number of components
ica_model <- icafast(wide_baseline_flow_num_data_confounders_regressed_out, optimalCompNum, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(optimalCompNum), alg = "par", fun = "logcosh", alpha = 1)

# Extract the ICA components
ica_components <- ica_model$S

wide_baseline_flow_metadata_confounders_regressed_out$patient_id_simple <- as.character(wide_baseline_flow_metadata_confounders_regressed_out$patient_id_simple)

# Create a data frame with the first 2 or 3 components for visualization
ica_df <- data.frame(Comp1 = ica_components[,1], Comp2 = ica_components[,2], patient_id_simple = as.character(rownames(wide_baseline_flow_num_data_confounders_regressed_out))) %>%
  left_join(wide_baseline_flow_metadata_confounders_regressed_out, by = "patient_id_simple") %>%
  # just look at cancer patients (baseline)
  filter(!(is.na(group)))

# Plot the first 2 components
ggplot(ica_df, aes(x=Comp1, y=Comp2)) +
  geom_point(aes(color=group), size=2) + 
  labs(x="ICA Component 1", y="ICA Component 2")

```

# Cluster baseline cancer samples in ICA space, test for enrichment of irAE groups

```{r}

wss <- sapply(1:10, function(k) {
  kmeans(ica_df[, c("Comp1", "Comp2")], centers = k, nstart = 25)$tot.withinss
})

# Plot the Elbow curve
plot(1:10, wss, type = "b", pch = 19, frame = FALSE, xlab = "Number of clusters", ylab = "Total within-cluster sum of squares")

kmeans_result <- kmeans(ica_df[, c("Comp1", "Comp2")], centers = 6, nstart = 25)

# Add cluster assignments to the data
ica_df$cluster <- factor(kmeans_result$cluster)

ggplot(ica_df, aes(x = Comp1, y = Comp2, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  labs(x = "ICA Component 1", y = "ICA Component 2", color = "Cluster") +
  theme_minimal()

# Create contingency table for clusters vs. group
table_result <- table(ica_df$cluster, ica_df$group)

# Perform Chi-square and Fisher's Exact tests
chisq_test <- chisq.test(table_result)
fisher_test <- fisher.test(table_result)

# Display results
chisq_test
fisher_test

```

# Find features associating with age in HC/AID groups (to see if those who develop irAEs have older immunotypes)

```{r}

non_cancer_data <- adjusted_data %>%
  mutate(age = as.numeric(as.character(age))) %>%
  filter(group %in% c("AID_Patient", "Healthy_Control"))

immune_features <- non_cancer_data[, 10:ncol(non_cancer_data)]

correlation_results <- immune_features %>%
  summarise(across(everything(), ~ cor.test(.x, non_cancer_data$age, method = "spearman")$estimate)) %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "correlation")

p_values <- immune_features %>%
  summarise(across(everything(), ~ cor.test(.x, non_cancer_data$age, method = "spearman")$p.value)) %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "p_value")

correlation_summary <- left_join(correlation_results, p_values, by = "feature") %>%
  mutate(padj = p.adjust(p_value, method = "BH")) %>%
  arrange(padj) %>%
  filter(padj < 0.05)

correlation_summary

ggplot(non_cancer_data, aes(x = age, y = naive.of.CD8.Tcells, color = group)) +
  geom_point(alpha = 0.6) +  # Scatter points
  geom_smooth(method = "lm", color = "black", se = FALSE)

```

# Use LMs from non-cancer group (with age as factor) on cancer data to predict immunotype scores for features associating with age in non-cancer group

```{r}

# Fit a linear model for each age-correlated feature
models <- lapply(correlation_summary$feature, function(feature) {
  lm(as.formula(paste(feature, "~ age")), data = non_cancer_data)
})
names(models) <- correlation_summary$feature  # Name each model with its corresponding feature

models

cancer_data <- adjusted_data %>%
  mutate(age = as.numeric(as.character(age))) %>%
  filter(!(group %in% c("AID_Patient", "Healthy_Control")))

predict_immunotype_score <- function(model, age) {
  intercept <- coef(model)[1]
  slope <- coef(model)[2]
  return(intercept + slope * age)
}

predicted_scores <- data.frame(patient_id = cancer_data$patient_id)

# Loop through each model and predict scores for cancer patients
for (feature in names(models)) {
  predicted_scores[[feature]] <- sapply(cancer_data$age, function(age) predict_immunotype_score(models[[feature]], age))
}

# Rename the scores column to a more descriptive name
colnames(predicted_scores)[-1] <- paste0("immunotype_age_score_", names(models))

predicted_scores_with_metadata <- left_join(cancer_data %>% select(patient_id, group), predicted_scores, by = "patient_id")

predicted_scores_with_metadata

# Reshape data to long format for ggplot
predicted_scores_with_metadata_long <- predicted_scores_with_metadata %>%
  pivot_longer(cols = starts_with("immunotype_age_score"), 
               names_to = "immunotype", 
               values_to = "score") %>%
  mutate(immunotype = gsub("immunotype_age_score_", "", immunotype))

ggplot(predicted_scores_with_metadata_long, aes(x = immunotype, y = score, color = group)) +
  geom_point(position = position_jitter(width = 0.2), size = 1) +  # Add jitter for better visibility
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  labs(x = "", y = "Predicted score based\non HC/AID data")

```

# Try random forest models instead of module approach, setup input data, preprocess

```{r}

# terminal
# source ~/.bash_profile
# conda activate pyRforest-conda

#reticulate::use_condaenv("pyRforest-conda", conda = '/Users/tybottorff/miniconda3/bin/conda', required = TRUE)

# data needs to be in list of 4 tibbles
# training, validation, and test tibbles (splits of data)
# each with columns: identifier (unique identifier for each row, sample/patient_id), target (non-continuous outcome/target to be predicted but coded as a numeric like 0 or 1 for yes/no group, so combined irAE group yes vs. no), rest of columns are just each feature and then values for those columns are freqs

# 4th tibble is identifier, target, and a new and target_categorical which is the pretty name for numerical target values

# split data ~ 60-80% training, rest split validation/testing

forest_df <- adjusted_data %>%
  rename(identifier = patient_id) %>%
  mutate(target = case_when(
           group == "non-irAE" ~ 0,
           group == "irAE/SAE" ~ 1
         )) %>%
  # deal with NAs with simple method first (impute with mean when < 5% values are NA, otherwise remove feature)
  select(-c(ctcae_grade, group, cancer_type, cleaned_visit_info, Batch, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, thyroid_irae, skin_irae, pneumonitis_irae, pneumonitis_irae_including_effusion, gastro_irae, rheumatoid_irae, na_ridden_features)) %>%
  select(identifier, target, everything()) %>%
  mutate(across(-c(identifier, target), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# split data
set.seed(123)
total_rows <- nrow(forest_df)

train_index <- sample(1:total_rows, size = 0.6 * total_rows)
remaining <- setdiff(1:total_rows, train_index)
val_index <- sample(remaining, size = 0.5 * length(remaining))  # 50% of remaining for validation
test_index <- setdiff(remaining, val_index)

training_df <- forest_df[train_index, ]
validation_df <- forest_df[val_index, ]
test_df <- forest_df[test_index, ]

target_categories <- forest_df %>%
  select(identifier, target) %>%
  mutate(target_categorical = case_when(
    target == 0 ~ "non-irAE",
    target == 1 ~ "irAE/SAE"
  ))
  
# create input object
cytof_data_for_forest <- list(
training_data = as_tibble(training_df),
validation_data = as_tibble(validation_df),
testing_data = as_tibble(test_df),
target_categories = as_tibble(target_categories)
)

# preprocess data
processed_training_data <- pyRforest::create_feature_matrix(
dataset = cytof_data_for_forest$training_data,
set_type = "training"
)
processed_validation_data <- pyRforest::create_feature_matrix(
dataset = cytof_data_for_forest$validation_data,
set_type = "validation"
)
processed_testing_data <- pyRforest::create_feature_matrix(
dataset = cytof_data_for_forest$testing_data,
set_type = "testing"
)

```

# Model tuning, fit/evaluate

```{r}

# edit some params manually given initial concerns of overfitting (test performance < training performance)
# maybe max_depth was too large (15), and min_samples_leaf too small (10), Ls here mean R integer?
custom_parameter_grid <- list(
  bootstrap = list(TRUE),
  class_weight = list(NULL),
  max_depth = list(5L, 20L, NULL),
  n_estimators = as.integer(seq(10, 90, 10)),
  max_features = list("sqrt", 0.2),
  criterion = list("gini"),
  warm_start = list(FALSE),
  min_samples_leaf = list(1, 50L),
  min_samples_split = list(2L, 200L)
)

# model tuning
# hyperparam tuning, training classifier
tuning_results <- pyRforest::tune_and_train_rf_model_grid(
X = processed_training_data$X_training_mat,
y = processed_training_data$y_training_vector,
cv_folds = 5,
scoring = 'roc_auc', #use 'roc_auc_ovr' for multiclass targets
seed = 123,
param_grid = NULL,
n_jobs = 1,
n_cores =-2
)

print(tuning_results$bayes_search$best_params_)
print(tuning_results$bayes_search$best_score_)
best_params<-tuning_results$best_params

best_params

# fit/evaluate model

fitting_results <- pyRforest::fit_and_evaluate_rf(
best_params = tuning_results$best_params,
X_train = processed_training_data$X_training_mat,
y_train = processed_training_data$y_training_vector,
X_val = processed_validation_data$X_validation_mat,
y_val = processed_validation_data$y_validation_vector)

print(fitting_results)

fitting_results_testing <- pyRforest::fit_and_evaluate_rf(
best_params = tuning_results$best_params,
X_train = processed_training_data$X_training_mat,
y_train = processed_training_data$y_training_vector,
X_val = processed_testing_data$X_testing_mat,
y_val = processed_testing_data$y_testing_vector
)

print(fitting_results_testing)

```

# Permute model, get feature importances, stats

```{r}

# permute model, get feature importances

feat_importances <- pyRforest::calculate_feature_importances(
model = fitting_results$model,
X_train = processed_training_data$X_training_mat,
y_train = processed_training_data$y_training_vector,
n_permutations = 1000
)

print(feat_importances$top_features)

# get stats for important features
# quantiles of permuted feature importance scores
quantile_data <- pyRforest::calculate_quantiles(
truevalues = feat_importances$true_importances,
permutedvalues = feat_importances$permuted_importances,
alpha = 0.05
)

# pvals for feature set
pvalue_set <- pyRforest::calculate_full_set_pvalue(
permutedvalues = feat_importances$permuted_importances,
quantiledata = quantile_data
)

# pvals for each rank

pvalues_ranks <- pyRforest::calculate_ranked_based_pvalues(
truevalues = feat_importances$true_importances,
permutedvalues = feat_importances$permuted_importances,
alpha = 0.05
)
print(pvalues_ranks)

fiplot_full <- pyRforest::generate_fi_rank_plot(
permutedvalues = feat_importances$permuted_importances,
quantiledata = quantile_data,
xlimitmin = 1,
xlimitmax = 10,
ylimitmin=-5,
ylimitmax = 0,
labelhorizontaladjust =-0.05,
labelverticaladjust = 1.5,
focusedView = FALSE,
logOn = TRUE
)

print(fiplot_full)

```

# Re-do but now for skin irAE comparison

```{r}

forest_df <- adjusted_data %>%
  rename(identifier = patient_id) %>%
  mutate(target = case_when(
           skin_irae == "No skin irAE" ~ 0,
           skin_irae == "Skin irAE" ~ 1
         )) %>%
  # deal with NAs with simple method first (impute with mean when < 5% values are NA, otherwise remove feature)
  select(-c(ctcae_grade, group, cancer_type, cleaned_visit_info, Batch, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, thyroid_irae, skin_irae, pneumonitis_irae, pneumonitis_irae_including_effusion, gastro_irae, rheumatoid_irae, na_ridden_features)) %>%
  select(identifier, target, everything()) %>%
  mutate(across(-c(identifier, target), ~ ifelse(is.na(.), mean(., na.rm = TRUE), .)))

# split data
set.seed(123)
total_rows <- nrow(forest_df)

train_index <- sample(1:total_rows, size = 0.6 * total_rows)
remaining <- setdiff(1:total_rows, train_index)
val_index <- sample(remaining, size = 0.5 * length(remaining))  # 50% of remaining for validation
test_index <- setdiff(remaining, val_index)

training_df <- forest_df[train_index, ]
validation_df <- forest_df[val_index, ]
test_df <- forest_df[test_index, ]

target_categories <- forest_df %>%
  select(identifier, target) %>%
  mutate(target_categorical = case_when(
    target == 0 ~ "No skin irAE",
    target == 1 ~ "Skin irAE"
  ))
  
# create input object
cytof_data_for_forest <- list(
training_data = as_tibble(training_df),
validation_data = as_tibble(validation_df),
testing_data = as_tibble(test_df),
target_categories = as_tibble(target_categories)
)

# preprocess data
processed_training_data <- pyRforest::create_feature_matrix(
dataset = cytof_data_for_forest$training_data,
set_type = "training"
)
processed_validation_data <- pyRforest::create_feature_matrix(
dataset = cytof_data_for_forest$validation_data,
set_type = "validation"
)
processed_testing_data <- pyRforest::create_feature_matrix(
dataset = cytof_data_for_forest$testing_data,
set_type = "testing"
)

# Model tuning, fit/evaluate

# edit some params manually given initial concerns of overfitting (test performance < training performance)
# maybe max_depth was too large (15), and min_samples_leaf too small (10), Ls here mean R integer?
custom_parameter_grid <- list(
  bootstrap = list(TRUE),
  class_weight = list(NULL),
  max_depth = list(5L, 20L, NULL),
  n_estimators = as.integer(seq(10, 90, 10)),
  max_features = list("sqrt", 0.2),
  criterion = list("gini"),
  warm_start = list(FALSE),
  min_samples_leaf = list(1, 50L),
  min_samples_split = list(2L, 200L)
)

# model tuning
# hyperparam tuning, training classifier
tuning_results <- pyRforest::tune_and_train_rf_model_grid(
X = processed_training_data$X_training_mat,
y = processed_training_data$y_training_vector,
cv_folds = 5,
scoring = 'roc_auc', #use 'roc_auc_ovr' for multiclass targets
seed = 123,
param_grid = NULL,
n_jobs = 1,
n_cores =-2
)

print(tuning_results$bayes_search$best_params_)
print(tuning_results$bayes_search$best_score_)
best_params<-tuning_results$best_params

best_params

# fit/evaluate model

fitting_results <- pyRforest::fit_and_evaluate_rf(
best_params = tuning_results$best_params,
X_train = processed_training_data$X_training_mat,
y_train = processed_training_data$y_training_vector,
X_val = processed_validation_data$X_validation_mat,
y_val = processed_validation_data$y_validation_vector)

print(fitting_results)

fitting_results_testing <- pyRforest::fit_and_evaluate_rf(
best_params = tuning_results$best_params,
X_train = processed_training_data$X_training_mat,
y_train = processed_training_data$y_training_vector,
X_val = processed_testing_data$X_testing_mat,
y_val = processed_testing_data$y_testing_vector
)

print(fitting_results_testing)

# Permute model, get feature importances, stats

feat_importances <- pyRforest::calculate_feature_importances(
model = fitting_results$model,
X_train = processed_training_data$X_training_mat,
y_train = processed_training_data$y_training_vector,
n_permutations = 1000
)

print(feat_importances$top_features)

# get stats for important features
# quantiles of permuted feature importance scores
quantile_data <- pyRforest::calculate_quantiles(
truevalues = feat_importances$true_importances,
permutedvalues = feat_importances$permuted_importances,
alpha = 0.05
)

# pvals for feature set
pvalue_set <- pyRforest::calculate_full_set_pvalue(
permutedvalues = feat_importances$permuted_importances,
quantiledata = quantile_data
)

# pvals for each rank

pvalues_ranks <- pyRforest::calculate_ranked_based_pvalues(
truevalues = feat_importances$true_importances,
permutedvalues = feat_importances$permuted_importances,
alpha = 0.05
)
print(pvalues_ranks)

fiplot_full <- pyRforest::generate_fi_rank_plot(
permutedvalues = feat_importances$permuted_importances,
quantiledata = quantile_data,
xlimitmin = 1,
xlimitmax = 10,
ylimitmin=-5,
ylimitmax = 0,
labelhorizontaladjust =-0.05,
labelverticaladjust = 1.5,
focusedView = FALSE,
logOn = TRUE
)

print(fiplot_full)

```