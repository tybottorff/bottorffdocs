---
title: "CyTOF analyses for NCI irAE project"
output: pdf_document
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(beeswarm)
library(Matrix)
library(ggplot2)
library(stringr)
library(scales)
library(tidyr)
library(ComplexHeatmap)
library(viridis)
library(readxl)
library(circlize)
library(factoextra)
library(lmerTest)
library(gtsummary)
library(ica)
library(dplyr)
library(ggrepel)
library(purrr)
library(compareGroups)
library(reshape2)
library(limma)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in all data

```{r}

flow_data <- read_excel("../raw_data/2024_10_17_flow_data.xlsx") %>%
  # CTCAE Grade (Highest) is the column for (ir)AE grade
  rename(patient_id = `Subject ID`, ctcae_grade = `CTCAE Grade (Highest)`, group = `General irAE Classification`, cancer_type = `Primary Cancer Type`, age = `Age at Draw`, thyroid_cat = `Thyroid Category (JB)`, data_source = `Data Source`, ici_drug = `Immune Checkpoint Inhibitor`) %>%
  mutate(`Infusion date` = as.Date(as.numeric(`Infusion date`), origin = "1899-12-30"),
         `First irAE Onset or Thyroid Test Date` = as.Date(as.numeric(`First irAE Onset or Thyroid Test Date`), origin = "1899-12-30"),
         days_to_irae = as.numeric(difftime(`First irAE Onset or Thyroid Test Date`, `Infusion date`, units = "days")),
         cleaned_visit_info = case_when(
          str_detect(`Visit Descriptor`, "Healthy") ~ "baseline",
          str_detect(`Visit Descriptor`, "AID") ~ "baseline",
          str_detect(`Visit Descriptor`, "(?i)visit 1") ~ "baseline",  # Case-insensitive match for "Visit 1"
          str_detect(`Visit Descriptor`, "\\d+") ~ str_extract(`Visit Descriptor`, "\\d+"),
          str_detect(`Visit Descriptor`, "F/U") ~ "irAE F/U",
          str_detect(`Visit Descriptor`, "irAE") ~ "irAE",
          TRUE ~ "Other"),
         # fix 1 patient with NA cancer type but looks like lung from other column info
         cancer_type = if_else(patient_id == "LinsleyLab732066", "Lung", cancer_type),
         # combine multiple irAE cols
         irae_ex = paste(`irAE Documented (if any)`, `Documented irAE's (9/6/2024)`, sep = "_"),
         # if CTCAE grade is not-NA, group should be irAE... (some grade 1-2 ctcae were in non-irAE group before using updated category 9/6/24, using `General irAE Classification` as its cleaner metadata though otherwise
         group = if_else(!is.na(ctcae_grade), "irAE/SAE", group),
         thyroid_cat = if_else(is.na(thyroid_cat), "None", thyroid_cat),
         thyroid_irae_including_oor = if_else(str_detect(irae_ex, regex("thyroid", ignore_case = TRUE)) | str_detect(thyroid_cat, regex("Abnormal", ignore_case = TRUE)),
                                "Thyroid irAE", 
                                "No thyroid irAE"),
         thyroid_irae = if_else(str_detect(irae_ex, regex("thyroid", ignore_case = TRUE)),
                                "Thyroid irAE", 
                                "No thyroid irAE"),
         skin_irae = if_else(str_detect(irae_ex, regex("rash|itch|skin|dermatitis|Pruritis|Pruritus", ignore_case = TRUE)),
                                "Skin irAE", 
                                "No skin irAE"),
         pneumonitis_irae = if_else(str_detect(irae_ex, regex("pneumonitis", ignore_case = TRUE)),
                                "Pneumonitis", 
                                "No pneumonitis"),
         pneumonitis_irae_including_effusion = if_else(str_detect(irae_ex, regex("pneumonitis|effusion", ignore_case = TRUE)),
                                "Pneumonitis", 
                                "No pneumonitis"),
         gastro_irae = if_else(str_detect(irae_ex, regex("nausea|esophagitis|diarrhea", ignore_case = TRUE)),
                                "Gastrointestinal irAE", 
                                "No gastrointestinal irAE"),
         rheumatoid_irae = if_else(str_detect(irae_ex, regex("arthritis|arthralgia|Arthalgia|edema", ignore_case = TRUE)),
                                "Rheumatoid irAE", 
                                "No rheumatoid irAE"),
         # clean up cancer types and ICI drugs
        cancer_type = case_when(
          cancer_type %in% c("head-neck", "head_and_neck") ~ "Head/neck",
          cancer_type %in% c("lung", "Lung") ~ "Lung",
          cancer_type == "urinary_tract" ~ "Urinary tract",
          cancer_type == "esophageal" ~ "Esophageal",
          cancer_type == "gastric" ~ "Gastric"),
               ici_drug = case_when(
                 ici_drug == "avelumab" ~ "Avelumab",
                 ici_drug == "cemiplimab" ~ "Cemiplimab",
                 ici_drug == "durvalumab" ~ "Durvalumab",
                 ici_drug %in% c("nivolumab", "nivolumab, other_antidpl") ~ "Nivolumab/other",
                 ici_drug == "pembrolizumab" ~ "Pembrolizumab",
         )) %>%
  select(patient_id, group, ctcae_grade, cancer_type, cleaned_visit_info, Batch, age, irae_ex, days_to_irae, thyroid_cat, thyroid_irae_including_oor, thyroid_irae, skin_irae, pneumonitis_irae, pneumonitis_irae_including_effusion, gastro_irae, rheumatoid_irae, data_source, ici_drug, starts_with("pct_")) %>%
  pivot_longer(
    cols = starts_with("pct_"), 
    names_to = "sort",
    values_to = "freq") %>%
  mutate(parent_population = gsub(".*_of_", "", sort),
         parent_population = gsub("_", " ", parent_population),
         parent_parent_population = str_extract(parent_population, "[^ ]+$"),
         sort = gsub("pct_", "", sort),
         sort = gsub("_", " ", sort)
  ) %>%
  dplyr::filter(freq > 0) %>%
  # get rid of technically variable features
  dplyr::filter(!(sort %in% c("granulocytes of live", "PD1pos of DN Bcells", "PD1pos of naive Bcells", "PD1pos of swMem Bcells", "PD1pos of unswMem Bcells", "basophils of nonGrans", "EMRA of Tconv Tcells", "CXCR6pos of NN CD8 Tcells", "CXCR6posGrzmBpos of NN CD8 Tcells")))
    
# only 2 patients with serious (grade > 2) irAEs

flow_data

```

# Summarize cancer cohort metadata

```{r}

cohort_metadata_long <- flow_data %>%
  # subset for cancer patients
  filter(group %in% c("non-irAE", "irAE/SAE")) %>%
  # ignore pivoted freq/longitudinal info, just get 1 metadata row/patient
  group_by(patient_id) %>%
  slice(1) %>%
  ungroup() %>%
  # standardize irae_ex for non-irAE group
  mutate(irae_ex = if_else(group == "non-irAE", "None", irae_ex)) %>%
  # Split irae_ex into multiple rows for multiple irAEs/patient
  separate_rows(irae_ex, sep = ";\\s*|_|,\\s*") %>%
  # standardize values for toxicities, here are irAE keywords
  # rash, Arthralgia, Fatigue, pneumonitis, esophagitis, nausea, itching, Hypothyroidism/hyper, edema, Pruritus, Arthritis, skin, Encephalitis, AKI, hepatitis, diarrhea, dermatitis, Pericardial/Pleural effusion
  mutate(
    irae_ex = case_when(
      grepl("rash|itch|skin|dermatitis|Pruritis|Pruritus", irae_ex, ignore.case = TRUE) ~ "Skin",
      grepl("Thyroid", irae_ex, ignore.case = TRUE) ~ "Thyroid",
      grepl("Arthritis", irae_ex, ignore.case = TRUE) ~ "Arthritis",
      grepl("Encephalitis", irae_ex, ignore.case = TRUE) ~ "Encephalitis",
      grepl("Pericardial/Pleural effusion", irae_ex, ignore.case = TRUE) ~ "Pericardial/pleural effusion",
      grepl("edema", irae_ex, ignore.case = TRUE) ~ "Edema",
      grepl("Arthalgia|Arthralgia", irae_ex, ignore.case = TRUE) ~ "Arthralgia",
      grepl("Fatigue", irae_ex, ignore.case = TRUE) ~ "Fatigue",      
      grepl("esophagitis", irae_ex, ignore.case = TRUE) ~ "Esophagitis",
      grepl("pneumonitis", irae_ex, ignore.case = TRUE) ~ "Pneumonitis",
      grepl("nausea", irae_ex, ignore.case = TRUE) ~ "Nausea",      
      grepl("AKI", irae_ex, ignore.case = TRUE) ~ "AKI",      
      grepl("hepatitis", irae_ex, ignore.case = TRUE) ~ "Hepatitis",    
      grepl("diarrhea", irae_ex, ignore.case = TRUE) ~ "Diarrhea",      
      # everything else is just redundant/useless info I believe
      TRUE ~ NA
    ),
    patient_id = gsub("LinsleyLab", "", patient_id),
    ctcae_grade = as.character(ctcae_grade),
    age = as.character(age),
    days_to_irae = as.character(days_to_irae)
  ) %>%
  # get rid of redundant/unnecessary irAE info
  group_by(patient_id, irae_ex) %>%
  slice(1) %>%
  ungroup() %>%
  # gather variables into long format for plotting
  pivot_longer(cols = c(cancer_type, irae_ex, ctcae_grade, data_source, ici_drug),
               names_to = "variable", values_to = "value") %>%
  dplyr::filter(!(is.na(value))) %>%
  mutate(variable = case_when(
    variable == "cancer_type" ~ "Cancer\ntype",
    variable == "irae_ex" ~ "irAE\ntype",
    variable == "ctcae_grade" ~ "CTCAE\ngrade",
    variable == "data_source" ~ "Data\nsource",
    variable == "ici_drug" ~ "ICI\ndrug",
    TRUE ~ variable
  ))

cohort_metadata_long$variable <- factor(
  cohort_metadata_long$variable, 
  levels = c("Data\nsource", "Cancer\ntype", "ICI\ndrug", "irAE\ntype", "CTCAE\ngrade")
)

p <- ggplot(cohort_metadata_long, aes(x = patient_id, y = value)) +
  geom_point(aes(color = group), size = 2) +
  facet_grid(variable ~ group, scales = "free", space = "free_y") +
  labs(x = "Patient ID", y = "") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6),
        strip.text = element_text(size = 10),
        legend.text = element_text(size = 12))

p

ggsave("../figures/metadata.png", p, width = 10, height = 9)

```

# Look at how many cancer patients are represented across multiple batches
 - if patients were split across batches, could try other batch effect tools/ideas

```{r}

flow_data %>%
  filter(group %in% c("non-irAE", "irAE/SAE")) %>%
  group_by(patient_id, group, cleaned_visit_info, Batch) %>%
  slice(1) %>%
  ungroup() %>%
  group_by(patient_id) %>%
  summarize(batch_count = n_distinct(Batch))

# all patients' longitudinal data are in the same batch

```

# Look at ages and group distributions by batch, seem to be pretty similar except for batch 7 (no non-irAE patients)

```{r}

flow_data %>%
  group_by(Batch) %>%
  summarize(avg_age = mean(age, na.rm = TRUE))

flow_data %>%
  # deal w/ pivoted format
  group_by(patient_id) %>%
  slice(1) %>%
  ungroup() %>%
  group_by(Batch, group) %>%
  summarize(count = n())

```

# Define logit transform func

```{r}

logitNorm <- function(v){
  newVals <- v
  # Check to see if it's 0 to 1 or 0 to 100, and then switch it to 0 to 1
  if( any(v>1) & all(v<=100) ){
    newVals <- v/100
  }
  # if there are 0s or 1s, add/subtract a small value
  # so the logit norm is defined
  epsilon <- min(newVals[newVals!=0])/2
  newVals[newVals==0] <- epsilon
  newVals[newVals==1] <- 1-epsilon
  # Do the logit norm
  newVals <- log2(newVals/(1-newVals))
  if( any(is.na(newVals))){
    print(head(data.frame(v,newVals)))
  }
  return(newVals)
}

```

# Look at DP (feature lost in regressing out covars) at baseline

```{r}

plot_data <- flow_data %>%
  # subset for baseline info
  filter(cleaned_visit_info == "baseline") %>%
  dplyr::filter(sort == "DP of Tcells") %>%
  # logit transform, Z-score across patients
  mutate(freq = scale(logitNorm(freq)))

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  #facet_wrap(~ sort, ncol = 3) +
  geom_jitter(color = "grey", size = 0.5) +
  labs(x = "", y = "DP of Tcells freq (logit-\ntransformed %\nof parent, Z-scored)") +
  scale_fill_manual(values = c("Healthy_Control" = "purple", "AID_Patient" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

```

# Compare how cancer patients' features frequencies correlatations differ in each batch
 - these look different, i.e. batch effects

```{r}

corr_df <- flow_data %>%
  filter(group %in% c("non-irAE", "irAE/SAE")) %>%
  mutate(freq = logitNorm(freq)) %>%
  select(patient_id, cleaned_visit_info, Batch, sort, freq) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(Batch = as.factor(Batch)) %>%
  mutate(across(where(is.numeric), ~ scale(.))) %>%
  select(-patient_id, -cleaned_visit_info) %>%
  group_by(Batch) %>%
  group_split() %>% 
  lapply(function(batch_data) {
    batch_id <- unique(batch_data$Batch)
    batch_corr <- cor(batch_data[,-1], use = "pairwise.complete.obs")
    list(Batch = batch_id, CorrelationMatrix = batch_corr)
  })

corr_df

heatmap_plots <- lapply(corr_df, function(corr_obj) {
  batch_id <- corr_obj$Batch
  corr_matrix <- corr_obj$CorrelationMatrix
  corr_melt <- melt(corr_matrix)
  
  ggplot(corr_melt, aes(x = Var1, y = Var2, fill = value)) +
    geom_tile() +
    scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = 0,
                         limit = c(-1, 1), name = "Correlation") +
    labs(title = paste("Batch", batch_id, "Correlation Heatmap")) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
})

for (i in seq_along(heatmap_plots)) {
  print(heatmap_plots[[i]])
}

```

# Plot PCA results before batch regressed out, color by batch
 - another way to see batch effects

```{r}

pca_df <- flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, irae_ex, ici_drug, data_source)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(Batch = as.factor(Batch),
         patient_id = as.factor(patient_id))

wide_baseline_flow_metadata <- pca_df[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data <- (pca_df)[, 17:ncol(pca_df)] %>%
  # Z-score normalize across samples for each feature
  mutate(across(where(is.numeric), ~ scale(.)))

# don't drop NA rows, instead remove features (cols) with an NA
# remove 22/71 features with NAs
na_count_per_feature <- colSums(is.na(wide_baseline_flow_num_data))
wide_baseline_flow_num_data <- wide_baseline_flow_num_data[, na_count_per_feature == 0]

#dim(wide_baseline_flow_num_data)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = Batch), size = 2, alpha = 0.8) + 
  #stat_ellipse(aes(x = PC1, y = PC2, color = Batch), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_color_by_batch_batch_not_regressed_out.png", plot = p, width = 3, height = 3.5)

```

# Look for significant features b/w irAE groups using limma & design matrix

```{r}

limma_df <- flow_data %>%
  # subet for baseline data
  filter(cleaned_visit_info == "baseline") %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, irae_ex, ici_drug, data_source)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(across(17:ncol(.), ~ scale(.)))

limma_df

# Convert group and Batch to factors
# using group as just skin_irae yes/no since that's the 1 contrast where I see results
limma_df$group <- factor(limma_df$skin_irae)
limma_df$Batch <- factor(limma_df$Batch)

# Create the design matrix with the formula and contrasts argument
design <- model.matrix(~0 + group + Batch, data = limma_df)

colnames(design) <- gsub("group", "", colnames(design))
# make colnames work, replace special chars with _
colnames(design) <- gsub("\\s|/|-", "_", colnames(design))

# Step 2: Contrast matrix for group comparisons
contrasts <- makeContrasts(
   irae_comparison = `Skin_irAE` - `No_skin_irAE`,
   levels = colnames(design)
)

# transpose
transposed_num_data <- limma_df[, 17:ncol(limma_df)] %>% t()

# Step 4: Linear modeling
# block batch here is redundant I think with design above, but keeping
corfit <- duplicateCorrelation(transposed_num_data, design, block=limma_df$Batch)
fit <- lmFit(transposed_num_data, design, block=limma_df$Batch, correlation=corfit$consensus)

# Step 5: Apply contrasts and compute statistics
fit2 <- contrasts.fit(fit, contrasts)
efit <- eBayes(fit2)

# results
topTable(efit, coef="irae_comparison", n=Inf)

# using this method...
# combined irAEs: no features w/ padj < 0.1

# skin irAEs: several hits with padj < 0.1
# padj < 0.01 CD11c+ of Bcells (this had padj just over 0.05 with limma::removeBatchEffects), Bcells of nongrans, Tcells of nongrans
# padj < 0.05: NKcells of nongrans, CXCR3+ of NN Tconv Tcells, CXCR3+CCR6+ of NN Tconv Tcells, naive of Treg Tcells, CCR4+ of NN CD8 Tcells
# padj < 0.05 & see these also with limma:removeBatchEffects & stats after that on adjusted data: CM of Tconv Tcells, DN of Bcells, CM of CD8 Tcells

# thyroid irAEs: no features w/ padj < 0.1
# pneumonitis: no features w/ padj < 0.1
# rheumatoid irAE: no features w/ padj < 0.1

```

# Try another approach: removeBatchEffect (limma), then stats on adjusted data

```{r}

remove_batch_effects_df <- flow_data %>%
  # filter for baseline data as not sure how to use this function with longitudinal data
  filter(cleaned_visit_info == "baseline") %>%
  mutate(freq = logitNorm(freq),
       ctcae_grade = as.factor(coalesce(ctcae_grade, 0))) %>%
  select(patient_id, group, ctcae_grade, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, cleaned_visit_info, Batch, sort, freq) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(Batch = as.factor(Batch)) %>%
  mutate(across(where(is.numeric), ~ scale(.)))

remove_batch_effects_df_t <- remove_batch_effects_df %>%
  select(-c(patient_id, group, ctcae_grade, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, cleaned_visit_info, Batch)) %>%
  t()

#patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, cleaned_visit_info, Batch

colnames(remove_batch_effects_df_t) <- paste(remove_batch_effects_df$patient_id, remove_batch_effects_df$group, remove_batch_effects_df$ctcae_grade, remove_batch_effects_df$skin_irae, remove_batch_effects_df$thyroid_irae, remove_batch_effects_df$pneumonitis_irae, remove_batch_effects_df$rheumatoid_irae, remove_batch_effects_df$cleaned_visit_info, remove_batch_effects_df$Batch, sep = "_")

# no longer need visit_info here
design_mat <- model.matrix(~ 0 + group, data = remove_batch_effects_df)

adjusted_data <- limma::removeBatchEffect(
  x = remove_batch_effects_df_t,
  batch = remove_batch_effects_df$Batch,
  design = design_mat
) %>%
  t()

metadata <- rownames(adjusted_data) %>%
  str_split_fixed("_", 9) %>%
  as.data.frame() %>%
  setNames(c("patient_id", "group", "ctcae_grade", "skin_irae", "thyroid_irae", "pneumonitis_irae", "rheumatoid_irae", "cleaned_visit_info", "Batch"))

adjusted_data <- adjusted_data %>%
  bind_cols(metadata) %>%
  # although using all data to remove batch effect, will be focusing on baseline cancer data for now
  filter(cleaned_visit_info == "baseline", group %in% c("non-irAE", "irAE/SAE"))

adjusted_data

```

# Try another approach (lmer of all data with batch as fixed effect, patient_id as fixed effect)
 - this feels best, using most data to regress out batch effects, will just use this adjusted_data downstream

```{r}

lmer_df <- flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, irae_ex, ici_drug, data_source)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  mutate(Batch = as.factor(Batch)) %>%
  filter(!(is.na(patient_id)))

lmer_df

metadata_cols <- lmer_df[, 1:16]
feature_cols <- lmer_df[, 17:ncol(lmer_df)] %>%
  mutate(across(where(is.numeric), ~ scale(.)))

# remove 26/71 features with NAs
na_count_per_feature <- colSums(is.na(feature_cols))
feature_cols_filtered <- feature_cols[, na_count_per_feature == 0]

# Function to regress out confounders (batch) for each feature
regress_out_confounders <- function(feature, batch, patient_id) {
  # Build the linear model and get residuals
  model <- lmer(feature ~ batch + (1|patient_id))
  residuals(model)
}

adjusted_features <- as.data.frame(lapply(feature_cols_filtered, 
                                          regress_out_confounders, 
                                          batch = lmer_df$Batch,
                                          patient_id = lmer_df$patient_id))

adjusted_data <- cbind(metadata_cols, adjusted_features)

write.csv(adjusted_data, "../saved_data/batch_effect_removed_data.csv")

adjusted_data <- adjusted_data %>%
  filter(cleaned_visit_info == "baseline", group %in% c("non-irAE", "irAE/SAE"))

```

# Plot PCA results for baseline data with batch regressed out, color by batch

```{r}

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(where(~ sum(is.na(.)) <= 1))

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = Batch), size = 2, alpha = 0.8) + 
  #stat_ellipse(aes(x = PC1, y = PC2, color = Batch), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_color_by_batch_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

```

# Baseline data with batch regressed out, test combined irAE yes vs. no

```{r}

stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[group == "non-irAE"])$p.value > 0.05,
                       shapiro.test(value[group == "irAE/SAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ group)$p.value else wilcox.test(value ~ group)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(padj) %>%
  filter(pval < 0.25)

stats_df

plot_data <- adjusted_data %>% select(group, SCM.of.Tconv.Tcells	) %>%
  pivot_longer(cols = c(SCM.of.Tconv.Tcells	), names_to = "sort", values_to = "freq")

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color = "black", size = 0.5) +
  labs(x = "", y = "SCM of Tconv\nTcells (residuals)") +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

ggsave("../figures/batch_regressed_out_residuals_by_feature_hit_combined.png", plot = p, width = 6, height = 4)

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(where(~ sum(is.na(.)) <= 1)) %>% select(stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1 <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2 <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = group), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = group), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_combined_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      group = pcaData$group)
res <- compareGroups(group ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

```

# Plot PCA results for baseline data with batch regressed out, thyroid irAEs specifically (using top features given lack of significant result, not able to separate here though)

```{r}

thyroid_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[thyroid_irae == "Thyroid irAE"])$p.value > 0.05,
                       shapiro.test(value[thyroid_irae == "No thyroid irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ thyroid_irae)$p.value else wilcox.test(value ~ thyroid_irae)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(padj) %>%
  filter(padj < 0.2)

thyroid_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(where(~ sum(is.na(.)) <= 1)) %>% select(thyroid_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_thyroid <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_thyroid <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

# switch colors
pcaData$thyroid_irae <- factor(pcaData$thyroid_irae, levels = c("Thyroid irAE", "No thyroid irAE"))
                                 
p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = thyroid_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = thyroid_irae), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_thyroid_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      thyroid_irae = pcaData$thyroid_irae)
res <- compareGroups(thyroid_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

```

# Plot PCA results for baseline data with batch regressed out, thyroid irAEs (including OOR) specifically

```{r}

thyroid_including_oor_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[thyroid_irae_including_oor == "Thyroid irAE"])$p.value > 0.05,
                       shapiro.test(value[thyroid_irae_including_oor == "No thyroid irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ thyroid_irae_including_oor)$p.value else wilcox.test(value ~ thyroid_irae_including_oor)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(padj) %>%
  filter(padj < 0.3)

thyroid_including_oor_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(where(~ sum(is.na(.)) <= 1)) %>% select(thyroid_including_oor_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_thyroid_with_oor <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_thyroid_with_oor <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3_thyroid_with_oor <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC3, color = thyroid_irae_including_oor), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC3, color = thyroid_irae_including_oor), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[3])

p

ggsave("../figures/baseline_pca_thyroid_irae_with_oor_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      thyroid_irae_including_oor = pcaData$thyroid_irae_including_oor)
res <- compareGroups(thyroid_irae_including_oor ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

```

# Plot PCA results for baseline data with batch regressed out, skin irAEs specifically

```{r}

skin_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[skin_irae == "Skin irAE"])$p.value > 0.05,
                       shapiro.test(value[skin_irae == "No skin irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ skin_irae)$p.value else wilcox.test(value ~ skin_irae)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(padj) %>%
  filter(padj < 0.85)

skin_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(where(~ sum(is.na(.)) <= 1))

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_skin <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_skin <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3_skin <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

# switch colors
pcaData$skin_irae <- factor(pcaData$skin_irae, levels = c("Skin irAE", "No skin irAE"))

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC3, color = skin_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC3, color = skin_irae), size = 1, linetype = 2) +
  #scale_color_manual(values = c("HC" = "purple", "AID" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  #scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = median(pcaData$age, na.rm = TRUE), limits = c(min(pcaData$age), max(pcaData$age))) +  # Blue-White-Red gradient with median age as white
  #xlim(-limits[1], limits[1]) +
  #ylim(-limits[2], limits[2]) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[3])

p

ggsave("../figures/baseline_pca_skin_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      skin_irae = pcaData$skin_irae)
res <- compareGroups(skin_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# using "top" features, PC1 pops out as differential:

p <- ggplot(pcaData, aes(x = skin_irae, y = PC1, color = skin_irae)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.6) +
  labs(y = "PC1", x = "")

p

ggsave("../figures/baseline_pc1_boxplot_skin_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 5, height = 3.5)

```

# Results for baseline data with batch regressed out, pneumonitis specifically

```{r}

pneumonitis_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[pneumonitis_irae == "Pneumonitis"])$p.value > 0.05,
                       shapiro.test(value[pneumonitis_irae == "No pneumonitis"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ pneumonitis_irae)$p.value else wilcox.test(value ~ pneumonitis_irae)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(padj)

pneumonitis_stats_df

adjusted_data$pneumonitis_irae <- factor(
  adjusted_data$pneumonitis_irae, 
  levels = c("Pneumonitis", "No pneumonitis")
)

plot_data <- adjusted_data %>% select(pneumonitis_irae, CD56bright.of.NKcells) %>%
  pivot_longer(cols = c(CD56bright.of.NKcells), names_to = "sort", values_to = "freq")

p <- plot_data %>%
  ggplot(aes(x = pneumonitis_irae, y = freq, fill = pneumonitis_irae)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(color = "black", size = 0.5) +
  labs(x = "", y = "CD56bright of NK\ncells (residuals)", fill = "Pneumonitis group") +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

ggsave("../figures/batch_regressed_out_residuals_by_feature_hit_pneumonitis.png", plot = p, width = 6, height = 4)

```

# Results for baseline data with batch regressed out, pneumonitis specifically (including effusion)

```{r}

pneumonitis_including_effusion_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[pneumonitis_irae_including_effusion == "Pneumonitis"])$p.value > 0.05,
                       shapiro.test(value[pneumonitis_irae_including_effusion == "No pneumonitis"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ pneumonitis_irae_including_effusion)$p.value else wilcox.test(value ~ pneumonitis_irae_including_effusion)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(padj)

pneumonitis_including_effusion_stats_df

```

# Plot PCA results for baseline data with batch regressed out, rheumatoid irAEs

```{r}

rheumatoid_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, skin_irae, thyroid_irae, pneumonitis_irae, rheumatoid_irae, ctcae_grade, Batch, cleaned_visit_info, cancer_type, age, days_to_irae, thyroid_cat, thyroid_irae_including_oor, pneumonitis_irae_including_effusion, gastro_irae), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[rheumatoid_irae == "Rheumatoid irAE"])$p.value > 0.05,
                       shapiro.test(value[rheumatoid_irae == "No rheumatoid irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ rheumatoid_irae)$p.value else wilcox.test(value ~ rheumatoid_irae)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  arrange(padj) %>%
  filter(padj < 0.2)

rheumatoid_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:16] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 17:ncol(adjusted_data)] %>% select(where(~ sum(is.na(.)) <= 1)) %>% select(rheumatoid_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1_rheumatoid_irae <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1)

top_contributing_features_PC2_rheumatoid_irae <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2)

top_contributing_features_PC3_rheumatoid_irae <- pca_contributions %>%
    arrange(desc(Dim.3)) %>%
    select(Dim.3)

pcaData$rheumatoid_irae <- factor(pcaData$rheumatoid_irae, levels = c("Rheumatoid irAE", "No rheumatoid irAE"))

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = rheumatoid_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = rheumatoid_irae), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_rhematoid_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      rheumatoid_irae = pcaData$rheumatoid_irae)
res <- compareGroups(rheumatoid_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

```

# Plot PCA results for baseline data with batch regressed out, gastrointestinal irAEs
 - only 2 patients with gastrointestinal irAEs...

# Find features contributing most to variance for general and specific irAEs and compare

```{r}

all_features <- unique(c(
  rownames(top_contributing_features_PC1_thyroid),
  rownames(top_contributing_features_PC1_general),
  rownames(top_contributing_features_PC1_skin),
  rownames(top_contributing_features_PC1_pneumonitis),
  rownames(top_contributing_features_PC1_rheumatoid_irae),
  rownames(top_contributing_features_PC2_thyroid),
  rownames(top_contributing_features_PC2_general),
  rownames(top_contributing_features_PC2_skin),
  rownames(top_contributing_features_PC2_pneumonitis),
  rownames(top_contributing_features_PC2_rheumatoid_irae),
  rownames(top_contributing_features_PC3_thyroid),
  rownames(top_contributing_features_PC3_general),
  rownames(top_contributing_features_PC3_skin),
  rownames(top_contributing_features_PC3_pneumonitis),
  rownames(top_contributing_features_PC3_rheumatoid_irae)
  ))

merged_data <- data.frame(
  PC1_general = top_contributing_features_PC1_general$Dim.1[match(all_features, rownames(top_contributing_features_PC1_general))],
  PC2_general = top_contributing_features_PC2_general$Dim.2[match(all_features, rownames(top_contributing_features_PC2_general))],
  PC3_general = top_contributing_features_PC3_general$Dim.3[match(all_features, rownames(top_contributing_features_PC3_general))],

  PC1_skin = top_contributing_features_PC1_skin$Dim.1[match(all_features, rownames(top_contributing_features_PC1_skin))],
  PC2_skin = top_contributing_features_PC2_skin$Dim.2[match(all_features, rownames(top_contributing_features_PC2_skin))],
  PC3_skin = top_contributing_features_PC3_skin$Dim.3[match(all_features, rownames(top_contributing_features_PC3_skin))],

  PC1_thyroid = top_contributing_features_PC1_thyroid$Dim.1[match(all_features, rownames(top_contributing_features_PC1_thyroid))],
  PC2_thyroid = top_contributing_features_PC2_thyroid$Dim.2[match(all_features, rownames(top_contributing_features_PC2_thyroid))],
  PC3_thyroid = top_contributing_features_PC3_thyroid$Dim.3[match(all_features, rownames(top_contributing_features_PC3_thyroid))],
  
  PC1_pneumonitis = top_contributing_features_PC1_pneumonitis$Dim.1[match(all_features, rownames(top_contributing_features_PC1_pneumonitis))],
  PC2_pneumonitis = top_contributing_features_PC2_pneumonitis$Dim.2[match(all_features, rownames(top_contributing_features_PC2_pneumonitis))],
  PC3_pneumonitis = top_contributing_features_PC3_pneumonitis$Dim.3[match(all_features, rownames(top_contributing_features_PC3_pneumonitis))],
  
  PC1_rheumatoid = top_contributing_features_PC1_rheumatoid_irae$Dim.1[match(all_features, rownames(top_contributing_features_PC1_rheumatoid_irae))],
  PC2_rheumatoid = top_contributing_features_PC2_rheumatoid_irae$Dim.2[match(all_features, rownames(top_contributing_features_PC2_rheumatoid_irae))],
  PC3_rheumatoid = top_contributing_features_PC3_rheumatoid_irae$Dim.3[match(all_features, rownames(top_contributing_features_PC3_rheumatoid_irae))]
)

rownames(merged_data) <- all_features

# Replace any NA values with 0
#merged_data[is.na(merged_data)] <- 0

merged_data <- merged_data %>%
  mutate(MaxValue = apply(., 1, function(x) max(x, na.rm = TRUE))) %>%  # Compute the max value per row, ignoring NA values
  arrange(desc(MaxValue)) %>%   # Order rows by the max value in descending order
  select(-MaxValue)  # Remove the temporary MaxValue column

# Clean up feature names (replace dots with spaces for clarity)
rownames(merged_data) <- gsub("\\.", " ", rownames(merged_data))

# Create a dataframe for column annotations (for irAE types and PC number)
column_annotations <- data.frame(
  irAE_type = c(rep("general", 3), rep("skin", 3), rep("thyroid", 3), rep("pneumonitis", 3), rep("rheumatoid", 3)),
  PC = rep(1:3, 5)  # Each type has PC1, PC2, and PC3
)

column_annotations$irAE_type <- factor(column_annotations$irAE_type, 
                                       levels = c("general", "skin", "thyroid", "pneumonitis", "rheumatoid"))

# Define colors for column annotations
annotation_colors <- list(
  irAE_type = c("general" = "black", "skin" = "red", "thyroid" = "blue", "pneumonitis" = "green", "rheumatoid" = "pink"),
  PC = c("1" = "#440154FF", "2" = "#21908CFF", "3" = "#FDE725FF")
)

# Ensure column annotations are in the correct order for merged_data
rownames(column_annotations) <- colnames(merged_data)

# Create HeatmapAnnotation for columns with color annotations
col_anno <- HeatmapAnnotation(
  irAE_type = column_annotations$irAE_type,
  PC = column_annotations$PC,
  col = annotation_colors
)

highlight_columns <- c(
  # For general, PC1
  "PC1_general", 
  
  # For thyroid, PC1 and PC3
  "PC1_thyroid", "PC3_thyroid", 
  
  # For skin, PC1 and PC2
  "PC1_skin", "PC2_skin", 
  
  # For pneumonitis, PC3
  "PC3_pneumonitis", 
  
  # For rheumatoid, all three PCs
  "PC1_rheumatoid", "PC2_rheumatoid", "PC3_rheumatoid"
)

# Create the heatmap with annotations for both the irAE type and PC number
p <- Heatmap(merged_data, 
        name = "Contribution (%)", 
        row_names_gp = gpar(fontsize = 10),
        column_names_gp = gpar(fontsize = 10),
        cluster_rows = FALSE, 
        cluster_columns = FALSE,
        show_column_names = FALSE, 
        top_annotation = col_anno,
        heatmap_legend_param = list(title = "Contribution (%)"),
        # Add box annotations around significant columns
        column_split = ifelse(colnames(merged_data) %in% highlight_columns, "p < 0.05", "p > 0.05"),  # Separate highlighted columns
        show_row_names = TRUE)

# Save the heatmap to a PDF file
pdf(file = "../figures/irae_types_contributing_features_highlighted.pdf", width = 10, height = 8)  # Adjust width and height as needed
draw(p)  # Render the heatmap
dev.off()  # Close the PDF device

```

# Look for correlation b/w irAE grade/time to irAE and freq for each feature/subset (baseline)

```{r}

ctcae_cor_df <- adjusted_data %>%
  filter(cleaned_visit_info == "baseline", group %in% c("non-irAE", "irAE/SAE")) %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, Batch, age, thyroid_irae, thyroid_irae_including_oor, skin_irae, pneumonitis_irae, pneumonitis_irae_including_effusion, gastro_irae, rheumatoid_irae, days_to_irae, thyroid_cat, cancer_type, cleaned_visit_info), names_to = "sort", values_to = "freq") %>%
  # replace non-irAE CTCAE grade (NA) with 0 to include in analysis
  mutate(ctcae_grade = if_else(is.na(ctcae_grade), 0, ctcae_grade)) %>%
  group_by(sort) %>%
  summarize(kruskal_result = list(kruskal.test(freq ~ as.factor(ctcae_grade))), .groups = 'drop') %>%
  mutate(
    p.value = map_dbl(kruskal_result, ~ .x$p.value)
  ) %>%
  mutate(p.adj = p.adjust(p.value, method = "BH")) %>%
  select(sort, p.value, p.adj) %>%
  arrange(p.adj) %>%
  print()

time_to_irae_df <- adjusted_data %>%
  filter(cleaned_visit_info == "baseline", group %in% c("non-irAE", "irAE/SAE")) %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, Batch, age, thyroid_irae, thyroid_irae_including_oor, skin_irae, pneumonitis_irae, pneumonitis_irae_including_effusion, gastro_irae, rheumatoid_irae, days_to_irae, thyroid_cat, cancer_type, cleaned_visit_info), names_to = "sort", values_to = "freq") %>%
  filter(group == "irAE/SAE") %>%
  group_by(sort) %>%
  summarize(cor_result = list(cor.test(days_to_irae, freq, method = "spearman")), .groups = 'drop') %>%
  mutate(
    estimate = map_dbl(cor_result, ~ .x$estimate),
    p.value = map_dbl(cor_result, ~ .x$p.value)
  ) %>%
  mutate(p.adj = p.adjust(p.value, method = "BH")) %>%
  select(sort, estimate, p.adj) %>%
  arrange(p.adj) %>%
  print()

```

# Determine clusters in PCA space, then test for enrichment of study groups in clusters

```{r}

# Elbow method to determine optimal number of clusters
set.seed(123)
wss <- sapply(1:10, function(k) {
  kmeans(pcaData[, c("PC1", "PC2", "PC3")], centers = k, nstart = 25)$tot.withinss
})

# Plot the Elbow curve
plot(1:10, wss, type = "b", pch = 19, frame = FALSE, xlab = "Number of clusters", ylab = "Total within-cluster sum of squares")

kmeans_result <- kmeans(pcaData[, c("PC1", "PC2", "PC3")], centers = 10, nstart = 25)

# Add cluster assignments to the data
pcaData$cluster <- factor(kmeans_result$cluster)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = cluster), size = 2, alpha = 0.8) +  # Color by cluster
  labs(color = "Cluster") +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

table_result <- table(pcaData$cluster, pcaData$group)

chisq_test <- chisq.test(table_result)
chisq_test
fisher_test <- fisher.test(table_result)
fisher_test

```

# Make VP of changes between irAE and no irAE groups

```{r}

df <- adjusted_data

irae_group <- df %>% dplyr::filter(group == "irAE/SAE")
no_irae_group <- df %>% dplyr::filter(group == "non-irAE")

non_feature_cols <- c("patient_id", "group", "specific_group", "irae_ex", "Batch", 
                      "age", "ctcae_grade", "thyroid_irae", "thyroid_irae_including_oor", "skin_irae", "days_to_irae", "thyroid_cat")
feature_columns <- setdiff(colnames(df), non_feature_cols)

# Calculate mean residuals for each feature
irae_means <- (irae_group %>% select(all_of(feature_columns)) %>% summarise_all(mean))
no_irae_means <- no_irae_group %>% select(all_of(feature_columns)) %>% summarise_all(mean)

abs_diff <- (as.numeric(irae_means) - as.numeric(no_irae_means))
#log2_fc <- sign(fc) * log2(abs(fc))

pvals <- sapply(feature_columns, function(feature) {
  wilcox.test(irae_group[[feature]], no_irae_group[[feature]])$p.value
})

padj <- p.adjust(pvals, method = "BH")

volcano_df <- data.frame(
  feature = feature_columns,
  abs_diff = abs_diff,
  padj = padj,
  neg_log10_padj = -log10(padj)
)

ggplot(volcano_df, aes(x = abs_diff, y = neg_log10_padj)) +
  geom_point(aes(color = padj < 0.1)) +
  theme_minimal() +
  labs(x = "irAE/SAE vs. no irAE (absolute difference in mean of residuals)", y = "-log10(padj)") +
  geom_vline(xintercept = 0, linetype = "dashed") + # Vertical line at 0 fold change +
  geom_hline(yintercept = -log10(0.1), linetype = "dashed") + # horizontal line at sig threshold
  geom_text_repel(data = subset(volcano_df, padj < 0.35), 
                  aes(label = feature), size = 3, box.padding = 0.5, max.overlaps = 10)

```

# Make a boxplot for features of interest (from literature) after regressing out batch

```{r}

# features of interest from literature
# DN of Bcells"                    "CD8 of Tcells"                   "CD38hiCD127neg of NN CD8 Tcells"

plot_data <- adjusted_data %>% select(group, DN.of.Bcells, CD8.of.Tcells, CD38hiCD127neg.of.NN.CD8.Tcells) %>%
  pivot_longer(cols = c(DN.of.Bcells, CD8.of.Tcells, CD38hiCD127neg.of.NN.CD8.Tcells), names_to = "sort", values_to = "freq") %>%
  mutate(sort = case_when(
    sort == "CD8.of.Tcells" ~ "CD8 of Tcells",
    sort == "CD38hiCD127neg.of.NN.CD8.Tcells" ~ "CD38hiCD127-\nof NN CD8s",
    sort == "DN.of.Bcells" ~ "DN of Bcells"
  ))

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~ sort, ncol = 3) +
  geom_jitter(color = "grey", size = 0.5) +
  labs(x = "", y = "Residuals (batch\nregressed out)") +
  scale_fill_manual(values = c("Healthy_Control" = "purple", "AID_Patient" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

ggsave("../figures/batch_regressed_out_residuals_by_feature_hits.png", plot = p, width = 7, height = 3.5)

```

# Find optimal number of components for ICA

```{r}

### Show example of one splitting iteration
# Split the features into 2 ~equal sets
## Set seed for reproducibility
feats1 <- sample(colnames(wide_baseline_flow_num_data_confounders_regressed_out),round(ncol(wide_baseline_flow_num_data_confounders_regressed_out)/2) )
feats2 <- colnames(wide_baseline_flow_num_data_confounders_regressed_out)[!colnames(wide_baseline_flow_num_data_confounders_regressed_out) %in% feats1]
print( paste0("Num features: ", length(feats1), ", ", length(feats2)) )

# Generate 2 ICA models with the split genes with 8 components
ncomps <- 6
ica1 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats1], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
print(paste0("Sample ICA Weight Matrix Dimensions: ", nrow(ica1$S)," by ", ncol(ica1$S)) )
ica2 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats2], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)

## Correlate the components together
cormat <- cor(ica1$S, ica2$S,method="spearman")
rowMaxes <- apply(abs(cormat),1,max)
rownames(cormat) <- as.character( signif(rowMaxes,3))
Heatmap(abs(cormat), name="Pearson\nCorrelation",column_title="Pairwise Correlations Between Split ICA Models")
# Get the worst best correlation
minMaxR <- min( apply(abs(cormat),1,max) )
print( paste0("Worst best component correlation: ",minMaxR) )

## Function to compute worst best component correlation for a sequence of component numbers
getSplitMinMaxR <- function(nCompsSequence, data.tmp=wide_baseline_flow_num_data_confounders_regressed_out){ # get the minimum spearman correlation between the ICA components from the two splits
  
  # Split the features into 2 equal sets
  feats1 <- sample(colnames(wide_baseline_flow_num_data_confounders_regressed_out),round(ncol(wide_baseline_flow_num_data_confounders_regressed_out)/2) )
  feats2 <- colnames(wide_baseline_flow_num_data_confounders_regressed_out)[!colnames(wide_baseline_flow_num_data_confounders_regressed_out) %in% feats1]
  
  getMinMaxR <- function(ncomps){
    print(ncomps)
    ica1 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats1], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
    ica2 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats2], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
    cormat <- cor(ica1$S, ica2$S,method="spearman")
    vals <- c( minMaxR = min( apply(abs(cormat),2,max)), ncomps=ncomps )
  }
  
  minMaxRs <- data.frame( t(sapply( nCompsSequence, getMinMaxR)) )
  return(minMaxRs)
}

# Do two splits
nCompsSequence <- 2:15
numShuffles <- 2
minMaxRs <- lapply(1:numShuffles, function(i) getSplitMinMaxR(nCompsSequence, wide_baseline_flow_num_data_confounders_regressed_out) )
for( i in 1:length(minMaxRs) ){
  minMaxRs[[i]]$shuffleNumber <- i
}
print("Min Max Rs: ")
print(minMaxRs)
numShuffles <- length(minMaxRs)

getCorDiffs <- function( minMaxR ){
  corDiffs <- minMaxR$minMaxR[2:nrow(minMaxR)] - minMaxR$minMaxR[1:(nrow(minMaxR)-1) ]
  biggestDecline <- minMaxR$ncomps[ which( corDiffs == min(corDiffs)) ]
  print( paste0("Biggest Correlation Decline: ", biggestDecline, " to ", biggestDecline+1 ) )
  return(biggestDecline)
}

biggestDeclines <- sapply(minMaxRs,getCorDiffs)
biggestDeclineTab <- table(biggestDeclines)
ggplot() + geom_histogram( aes(x=biggestDeclines)) + labs(x="# of components before the largest decline")
optimalCompNum <- as.numeric( names(biggestDeclineTab)[biggestDeclineTab==max(biggestDeclineTab)] )
print(optimalCompNum)

## Make boxplot of results of correlations for all 50 subsamples
minMaxRsLong <- do.call(rbind,minMaxRs)
ggplot(minMaxRsLong,aes(x=ncomps,y=minMaxR)) + geom_boxplot(aes(group=ncomps)) + geom_line(aes(group=shuffleNumber), alpha=0.1,color="red") + labs(x="number of ICA components",y="Lowest Component\nSpearman Correlation",title=paste0( numShuffles," Feature 2-Way Splits\nMinMax Component Correlation")) + geom_vline(xintercept = optimalCompNum, linetype="dashed",color="blue")

```

# Run ICA with optimal num of components

```{r}

optimalCompNum <- 6  # or set to your identified number of components
ica_model <- icafast(wide_baseline_flow_num_data_confounders_regressed_out, optimalCompNum, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(optimalCompNum), alg = "par", fun = "logcosh", alpha = 1)

# Extract the ICA components
ica_components <- ica_model$S

wide_baseline_flow_metadata_confounders_regressed_out$patient_id_simple <- as.character(wide_baseline_flow_metadata_confounders_regressed_out$patient_id_simple)

# Create a data frame with the first 2 or 3 components for visualization
ica_df <- data.frame(Comp1 = ica_components[,1], Comp2 = ica_components[,2], patient_id_simple = as.character(rownames(wide_baseline_flow_num_data_confounders_regressed_out))) %>%
  left_join(wide_baseline_flow_metadata_confounders_regressed_out, by = "patient_id_simple") %>%
  # just look at cancer patients (baseline)
  filter(!(is.na(group)))

# Plot the first 2 components
ggplot(ica_df, aes(x=Comp1, y=Comp2)) +
  geom_point(aes(color=group), size=2) + 
  labs(x="ICA Component 1", y="ICA Component 2")

```

# Cluster baseline cancer samples in ICA space, test for enrichment of irAE groups

```{r}

wss <- sapply(1:10, function(k) {
  kmeans(ica_df[, c("Comp1", "Comp2")], centers = k, nstart = 25)$tot.withinss
})

# Plot the Elbow curve
plot(1:10, wss, type = "b", pch = 19, frame = FALSE, xlab = "Number of clusters", ylab = "Total within-cluster sum of squares")

kmeans_result <- kmeans(ica_df[, c("Comp1", "Comp2")], centers = 6, nstart = 25)

# Add cluster assignments to the data
ica_df$cluster <- factor(kmeans_result$cluster)

ggplot(ica_df, aes(x = Comp1, y = Comp2, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  labs(x = "ICA Component 1", y = "ICA Component 2", color = "Cluster") +
  theme_minimal()

# Create contingency table for clusters vs. group
table_result <- table(ica_df$cluster, ica_df$group)

# Perform Chi-square and Fisher's Exact tests
chisq_test <- chisq.test(table_result)
fisher_test <- fisher.test(table_result)

# Display results
chisq_test
fisher_test

```

# Find features associating with age in HC/AID groups (to see if those who develop irAEs have older immunotypes)

```{r}

non_cancer_data <- adjusted_data %>%
  mutate(age = as.numeric(as.character(age))) %>%
  filter(group %in% c("AID_Patient", "Healthy_Control"))

immune_features <- non_cancer_data[, 10:ncol(non_cancer_data)]

correlation_results <- immune_features %>%
  summarise(across(everything(), ~ cor.test(.x, non_cancer_data$age, method = "spearman")$estimate)) %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "correlation")

p_values <- immune_features %>%
  summarise(across(everything(), ~ cor.test(.x, non_cancer_data$age, method = "spearman")$p.value)) %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "p_value")

correlation_summary <- left_join(correlation_results, p_values, by = "feature") %>%
  mutate(padj = p.adjust(p_value, method = "BH")) %>%
  arrange(padj) %>%
  filter(padj < 0.05)

correlation_summary

ggplot(non_cancer_data, aes(x = age, y = naive.of.CD8.Tcells, color = group)) +
  geom_point(alpha = 0.6) +  # Scatter points
  geom_smooth(method = "lm", color = "black", se = FALSE)

```

# Use LMs from non-cancer group (with age as factor) on cancer data to predict immunotype scores for features associating with age in non-cancer group

```{r}

# Fit a linear model for each age-correlated feature
models <- lapply(correlation_summary$feature, function(feature) {
  lm(as.formula(paste(feature, "~ age")), data = non_cancer_data)
})
names(models) <- correlation_summary$feature  # Name each model with its corresponding feature

models

cancer_data <- adjusted_data %>%
  mutate(age = as.numeric(as.character(age))) %>%
  filter(!(group %in% c("AID_Patient", "Healthy_Control")))

predict_immunotype_score <- function(model, age) {
  intercept <- coef(model)[1]
  slope <- coef(model)[2]
  return(intercept + slope * age)
}

predicted_scores <- data.frame(patient_id = cancer_data$patient_id)

# Loop through each model and predict scores for cancer patients
for (feature in names(models)) {
  predicted_scores[[feature]] <- sapply(cancer_data$age, function(age) predict_immunotype_score(models[[feature]], age))
}

# Rename the scores column to a more descriptive name
colnames(predicted_scores)[-1] <- paste0("immunotype_age_score_", names(models))

predicted_scores_with_metadata <- left_join(cancer_data %>% select(patient_id, group), predicted_scores, by = "patient_id")

predicted_scores_with_metadata

# Reshape data to long format for ggplot
predicted_scores_with_metadata_long <- predicted_scores_with_metadata %>%
  pivot_longer(cols = starts_with("immunotype_age_score"), 
               names_to = "immunotype", 
               values_to = "score") %>%
  mutate(immunotype = gsub("immunotype_age_score_", "", immunotype))

ggplot(predicted_scores_with_metadata_long, aes(x = immunotype, y = score, color = group)) +
  geom_point(position = position_jitter(width = 0.2), size = 1) +  # Add jitter for better visibility
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  labs(x = "", y = "Predicted score based\non HC/AID data")

```