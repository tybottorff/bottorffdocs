---
title: "NCI irAE - IMPACD analysis"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: true
editor_options: 
  chunk_output_type: console
---   

# Dataset notes from Alice W.

 - higher level subset identification gating and some QC metrics
 - FlowJo workspace file with the gates
 - NCI ICI data Batches 1-9 (or just 1-6?)
 - set of 6 samples (Batch05_TubeB_....) that have a few edited gates which was applied to the appropriate tubes and the group "Batch05 TubeB"; the rest of the samples (all other Batch05 samples and all other batches) have the same gates as each other applied to the "All Samples" group
 - exported the counts for all internal control samples (1 per tube, 4-5 per batch) and all samples in Batch05 Tube B. There is a spreadsheet containing this info in there
 - README doc just emphasizing the different gates for Batch05 TubeB

# Notes from shadowing Stephan
 - immunologist manually gates markers of interest for each batch on a subset of data
 - then we run IMPACD (high performance gating that generates counts-like object kind of like RNAseq)
 - each cell ends up in multiple buckets (like CD16+, CD16+ICOS+, and CD16+ICOS+CD25+ for example could all be true for 1 cell)
 - consensus gates: identify gates with diverging definitions and devise one consensus gate set/batch
 - level 1: automated gating, gating of single markers and report findings (no permutations)
 - level 2: do all permutations and gate them
 - level 3: modifier analysis (iterate over all possible permutations up to deptbh 3 under root path, remove redundant subsets i.e. root/A+/B+ = root/B+/A+, select significant level 2/3 nodes, test information gain with each modifier using ranksum test on background subtracted % values between subsets with/without modifier i.e. if root/A+/C+ scores significant test it vs. root/C+ and if root/A+/B+/C+ scores then test it vs. root/A+/C+ and root/B+/C+, select significant modifiers, adjust paths with 2 modifiers but only 1 winning node like if root/A+/B+/C+ modified significantly only by A+ then reduce to root/A+/C+)
 - need gates (.fcs files)
 - gating set is R equivalent of flowjo workspace, need to make this to make comparison, take gates and transformations from flowjo workspace and apply to .fcs files to make R gating set, to make correlation plot (to see if we can pull out gates correctly)
 - need to build (some) boolean gates (like not CD16+, CD16+ being a gate with coordinates) from scratch to not include parent
 - create gates separately for each batch
 - may run into issues with duplicate batches if script crashes then re-runs, or different root paths
 - transformations: light intensities (raw data, ~log scale), use transformations for each marker (some hyperbolic trig function) to transform data, also different for different batches/samples

# Set up directories

```{r}

# local work
baseDir = "~/mounts/workspace/tbottorff/nci_irae"

# cluster work
#baseDir = "/nfs/bioinformatics/workspace/tbottorff/nci_irae"
dataDir = file.path(baseDir,'saved_data')
plotsDir = file.path(baseDir,'figures')
fcsDir = file.path(baseDir, "raw_data/all_fcs_files")

# subdirectories
rawCountsDir = file.path(dataDir, "raw_counts")
processedCountsDir = file.path(dataDir, "counts")

dir.create(dataDir, recursive = T, showWarnings = F)
dir.create(plotsDir, recursive = T, showWarnings = F)
dir.create(fcsDir, recursive = T, showWarnings = F)
dir.create(rawCountsDir, recursive = T, showWarnings = F)
dir.create(processedCountsDir, recursive = T, showWarnings = F)

```

# Load libraries

```{r}

library(tidyverse)
library(data.table)
library(knitr)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(ggrepel)

library(readxl) # open excels
library(circlize) # color gradients

library(flowWorkspace)
library(CytoML)
library(IMPACD)

library(UpSetR)
library(tidyverse)
library(betareg)
library(limma)
library(emmeans)
library(circlize)
library(ComplexHeatmap)
library(openxlsx)
library(VennDiagram)
library(flowCore)

```

# Set up settings

```{r knitr defaults}

# opts_chunk$set(fig.width=6, fig.height=4.0, cache = TRUE, echo=FALSE, warning=FALSE, message=FALSE, results='hide')
opts_chunk$set(fig.width=6, fig.height=5, cache = TRUE, warning=FALSE, message=FALSE, fig.align = 'center')

```

# Explore vignette

```{r}

vignette("IMPACD")

# notes
# Load gate definitions from manual gating for markers of interest
# - this gating step is usually done in flowJo but can be done in R/other tools
# - data table must have these 4 columns: Annotation, Name, Marker Type, Gate Position, like below
# head(gate_definitions)
# A tibble: 6 × 4
#   Annotation Name    `Marker Type` `Gate Position`   
#   <chr>      <chr>   <chr>         <chr>             
# 1 CD49b      Dy161Di 1D            76.400000000000006
# 2 ICOS       Dy163Di 1D            48.1              

# - here are logical gates from flowJo
# A tibble: 6 × 4
#   Annotation Name                `Marker Type` `Gate Position`                  
#   <chr>      <chr>               <chr>         <chr>                            
# 1 Teff       Tm169Di vs. Sm149Di 2D            (NOT) {96.4, 19.5} {23.9, 8.05} …
# 2 Tregs      Tm169Di vs. Sm149Di 2D            {96.4, 19.5} {23.9, 8.05} {9.37,…

# - coordinates usually in untransformed space, we need to transfer them into same space that gating was initially done in (IMPACD takes care of this but need to inform what transformations are for each marker, transformations stored in transformList object)
 
# - can extract transformations from flowJo workspace file...
# ws = open_flowjo_xml("path/to/flowJo_workspace.wsp")
# gs_flowJo = flowjo_to_gatingset(ws)
# trans = gh_get_transformations(gs_flowJo[[1]])
# transList_wsp = transformList(from = names(trans), trans)

# - ask IMPACD to process table with gates with processGates function (returns list, first entry is df listing all gates created and has info on gate types, positions in transformed space, kinds of subgates required for logical gates, 2nd entry has actual gate objects later applied to flow data)

#output = processGates(gate_definitions, transList_wsp) 

#gate_data = output[[1]]
#head(gate_data)

```

# Some .fcs files have a width channel/col that others don't, remove it (doesn't seem important) and save as new .fcs files (only needs to be run 1X)

```{r}

# Batch01/03 files not being worked/copied/edited, just copy these over manually...

#fcs_files <- list.files(fcsDir, pattern = "\\.fcs$", full.names = TRUE)

# Directory to save the updated .fcs files
#output_dir <- file.path(dataDir, "no_width_fcs_files/")

#adjusted_files <- lapply(fcs_files, function(f) {
#  # don't truncate
#  fcs <- read.FCS(f, transformation = FALSE, truncate_max_range = FALSE)
#  if ("Width" %in% colnames(fcs)) {
#    expr <- exprs(fcs)
#    expr <- expr[, colnames(expr) != "Width"]
#    new_fcs <- flowFrame(expr, description = description(fcs))
#    output_file <- file.path(output_dir, basename(f))
#    write.FCS(new_fcs, output_file)
#    return(output_file)
#  }
#  return(f) # If no 'Width' channel, just return the original file path
#})

```

# Load flowjo workspace, plot gating set

```{r}

ws = open_flowjo_xml(file.path(baseDir, "raw_data/manual_gating_subsets_ics_and_batch5.wsp"))

gs_flowJo = flowjo_to_gatingset(ws, 
                                  skip_faulty_gate = TRUE, 
                                  # name designates which group of samples to import, 2 here being the Batch05_Tube with different subset gates and 1 being all (other?) samples
                                  name = 1,
                                  # use updated (no width channel/col) .fcs files (Batch01/03 copied over manually)
                                  path = file.path(baseDir, "saved_data/no_width_fcs_files/"))

plot(gs_flowJo)

```

# Print nodelist

```{r}

nodelist = gs_get_pop_paths(gs_flowJo, path = "full")

print(nodelist)

```

# Extract transformations from flowJo workspace

```{r}

trans = gh_get_transformations(gs_flowJo[[1]])

transList_wsp = transformList(from = names(trans), trans)

```

# Create the design matrix

```{r}

# use adjusted .fcs files
adjusted_fcs_files = list.files(file.path(dataDir, "no_width_fcs_files/"), pattern = ".fcs$", full.names = TRUE)

design = data.frame(fcsFiles = adjusted_fcs_files)

design$fcsName = basename(design$fcsFiles)
design$sampleName = gsub(".fcs", "", design$fcsName)

design$control = str_detect(design$sampleName, "Control")

# add batch ID to design matrix:
design$batch = as.numeric(gsub(".*Batch([0-9]+).*", "\\1", design$sampleName))

table(design$batch)
table(design$control)

```

# Apply gates/transformations from flowjo workspace to .fcs files to make R gating set (then test for perfect correlation to counts from Alice W.)
- gating set is R equivalent of flowjo workspace, need to make this to make comparison, take gates and transformations from flowjo workspace and apply to .fcs files to make R gating set, to make correlation plot (to see if we can pull out gates correctly)

# Setup gates

```{r}

gateList = data.frame(flowJoName = nodelist)

# There appear to be multiple "levels" of nodes. We start with a topLevel path
# /Non-granulocytes that most of our populations relate to
topLevel = c("/root")
# after that comes a set of X nodes that are all applied to that level

# For gating now, the easiest path is going to be to start at the top of the list, and subsequently add the next level of nodes to the path

# str split flowJoName by "/" and take the last element as the node
gateList$node = sapply(strsplit(gateList$flowJoName, "/"), function(x) x[length(x)])
gateList$parent = sapply(strsplit(gateList$flowJoName, "/"), function(x) paste0(x[1:(length(x) - 1)], collapse = "/"))
gateList$parent[gateList$parent == ""] = "/root"

# get rid of root, useless?
gateList <- gateList %>%
  dplyr::filter(node != "root")

gateList

```

# Get controls

```{r}

samples = data.frame(flowJoName = sampleNames(gs_flowJo))
samples$fcsName = gsub(".fcs_.*", ".fcs", samples$flowJoName)
samples = merge(samples, design, by = "fcsName")

table(samples$batch)

```

# Generate gate and transformer lists

```{r}

# start building out gates

gates = list()
trans = list()

# Loop through all samples
for (iControl in 1:nrow(samples)) {
  batch_ = samples$batch[iControl]  # Get the batch for the current sample

  # Get the gates for the current sample
  gates_ = list()
  for (i in 1:nrow(gateList)) {
    # Apply gates from FlowJo to the sample
    gates_[[i]] = gs_pop_get_gate(gs_flowJo, gateList$flowJoName[i])[[iControl]]
  }
  
  # Store gates based on batch
  gates[[batch_]] = gates_
  
  # Get transformations for the current sample
  trans_ = gh_get_transformations(gs_flowJo[[iControl]])
  
  # Store transformations based on batch
  trans[[batch_]] <- transformList(from = names(trans_), trans_)
}

```

# Explore the T cell gate

```{r}

# The first pass of the validation
gateList$flowJoName[gateList$node == "T cells"]
idx = which(gateList$node == "T cells")

# same for all batches (first [[]] here)?
gate_ = gates[[1]][[idx]]
gate_

```

# Transform fcs and setup validation gating sets

```{r}

fcs_transformed_directory = file.path(dataDir, "transformed_flow_data")

design$transformedFcs = file.path(fcs_transformed_directory, design$fcsName)

paths_ = unique(dirname(design$transformedFcs))
for (path_ in paths_) {
  dir.create(path_, showWarnings = F, recursive = T)
}

# Everytime we get a new gating set/workspace, we need to transform the fcs files again.
for (iRow in 1:nrow(design)) {
  print(iRow)
  if (file.exists(design$transformedFcs[iRow])) {
    next
  }
  ff = read.FCS(design$fcsFiles[iRow], truncate_max_range = FALSE)
  ff_t = flowCore::transform(ff, trans[[design$batch[iRow]]])
  
  write.FCS(ff_t, file = design$transformedFcs[iRow])
}

```

# Read in counts from Alice W.

```{r}

counts_alice_w = read_xlsx("raw_data/manual_gating_subsets_ics_and_batch5_counts.xlsx")

# fix sample names
counts_alice_w$`Sample:` <- gsub(" 19-Jan-2024", "", counts_alice_w$`Sample:`)

```

# Setup gating sets

```{r}

# After organizing the gates, we need to organize the fcs files into gating sets
# instead of making folders and using symboling links (cyto_setup needs a folder to read files in)
# let's see if we can build the gs objects with flowCore (flowSet() and GatingSet() )

gs = list()

  for (batch_ in unique(design$batch)) {
    samples_ = dplyr::filter(design, batch == batch_)
    # add a second filtering step to only keep files that Alice W. tested on
    samples_ = dplyr::filter(samples_, fcsName %in% counts_alice_w$`Sample:`)
    
    
    print(paste0(" batch: ", batch_, " samples: ", nrow(samples_)))
    flowSet = read.flowSet(samples_$transformedFcs,
                           truncate_max_range = FALSE)
    
    gs[[batch_]] = GatingSet(flowSet)
  }

```

# Do gating (on all gates Alice W. provided)

```{r}

# this is a bit different than in previous iterations - now, instead of going by "hierarchical" and 
# "leafs" I am going to just step through sequentially

for (batch_ in unique(design$batch)) {
  for (i in 1:nrow(gateList) ) {
    gs_pop_add(gs[[batch_]], gates[[batch_]][[i]], parent = gateList$parent[i])
    }
  }

```

# Summarize event counts

```{r}

pop_counts = c()

for (batch_ in unique(design$batch)) {
  recompute(gs[[batch_]])
    
  pop_counts = rbind(pop_counts, 
                     gs_pop_get_count_fast(gs[[batch_]], format = "long")
                     )
  }

save(pop_counts, file = "saved_data/counts_all_pars_gating.Rdata")

```

# Validation with flowjo counts: compare the results to Alice W.'s counts

```{r}

merged_pop_counts_ = dplyr::select(pop_counts, fcsName = name, population = Population, countR = Count) %>%
  mutate(population = gsub("/Non-granulocytes", "Non-granulocytes", population))

counts_alice_w_long = counts_alice_w %>% 
  pivot_longer(-`Sample:`, names_to = "population", values_to = "count_alice_w") %>%
  mutate(population = gsub(" \\| Count", "", population))

counts_alice_w_long = dplyr::select(counts_alice_w_long, fcsName = `Sample:`, population, count_alice_w = count_alice_w )

merged_pop_counts = left_join(merged_pop_counts_, counts_alice_w_long, by = c("fcsName", "population"))

merged_pop_counts = dplyr::filter(merged_pop_counts, !is.na(count_alice_w))

```

# Visualize results

```{r}

ggplot(merged_pop_counts, aes(x = countR, y = count_alice_w, color = fcsName)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "grey") +
  facet_wrap(~population, scales = "free") +
  theme_bw() +
  # reduce fontsize
  theme(text = element_text(size = 6)) +
  labs(x = "Counts (Ty)", y = "Counts (Alice W.)") + 
  # dont show legend
  theme(legend.position = "none")

#ggsave("plots/Tcells/validation/hierarchical_and_all_pars.pdf", width = 25, height = 15, units = "in")
#ggsave("plots/Tcells/validation/hierarchical_and_all_pars.png", width = 25, height = 15, units = "in")

```

# IMPACD gating: setup functions

```{r}

# setup gating set
getGatingSet = function(design) {
  gs = list()
  for (condition_ in unique(design$condition)) {
    gs[[condition_]] = list()
  }
  
  for (condition_ in unique(design$condition)) {
    for (batch_ in unique(design$batch)) {
      samples_ = dplyr::filter(design, condition == condition_, batch == batch_)
      
      print(paste0("group: ", condition_, " batch: ", batch_, " samples: ", nrow(samples_)))
      flowSet = read.flowSet(samples_$transformedFcs,
                             truncate_max_range = FALSE)
      
      gs[[condition_]][[batch_]] = GatingSet(flowSet)
    }
  }
  
  return(gs)
}

# gate for the rootpath - rootPathGates must be in the same order that you want the rootpath to be in
getRootPathTcells = function(gs, design, gates, rootPathGates) {
  
  for (condition_ in unique(design$condition)) {
    for (batch_ in unique(design$batch)) {
      for (i in 1:nrow(rootPathGates) ) {
        gs_pop_add(gs[[condition_]][[batch_]], gates[[condition_]][[batch_]][[rootPathGates$idx[i]]], parent = rootPathGates$parent[i])
      }
    }
  }
  
  return(gs)
}

# level1 gating
gateLevel1 = function(gs, design, level1_gates, level1_nodes, gatemetadata, root_path) {
  # do the stage 1 gating
  for (condition_ in unique(design$condition)) {
    for (batch_ in unique(design$batch)) {
      message(paste0("Stage 1 gating for batch ", batch_, " in group ", condition_))
      level1_paths = level1Gating(gs[[condition_]][[batch_]], 
                                  level1_nodes, 
                                  gatemetadata, level1_gates[[condition_]][[batch_]], 
                                  root_path) 
    }
  }
  
  return(gs)
}

# permutational gating
gateIMPACD = function(gs, design, level1_gates, level1_nodes, gatemetadata, root_path) {
  population_counts = list()
  for (condition_ in unique(design$condition)) {
    # population_counts[[condition_]] = list()
    
    for (batch_ in unique(design$batch)) {
      message(paste0("Stage 2 gating for batch ", batch_, " in group ", condition_))
      level2_paths = level2Gating(gs[[condition_]][[batch_]], 
                                  level1_nodes, gatemetadata, level1_gates[[condition_]][[batch_]], 
                                  root_path,
                                  max_depth = 3,
                                  level1_nodes = level1_nodes,
                                  cellcountCutoff = 0) 
      
      # pop_counts_ = gs_pop_get_count_fast(gs[[condition_]][[batch_]], format = "long")
      # population_counts[[condition_]][[batch_]] = pop_counts_
    }
  }
  
  return(gs)
}

getRawCounts = function(gs, design) {
  population_counts = list()
  for (condition_ in unique(design$condition)) {
    population_counts[[condition_]] = list()
    for (batch_ in unique(design$batch)) {
      pop_counts_ = gs_pop_get_count_fast(gs[[condition_]][[batch_]], format = "long")
      population_counts[[condition_]][[batch_]] = pop_counts_
    }
  }
  
  counts = c()
  for (condition_ in unique(design$condition)) {
    counts_ = bind_rows(population_counts[[condition_]])
    counts_$condition = condition_
    counts = rbind(counts, counts_)
  }
  counts$PercentParent = counts$Count/counts$ParentCount*100
  counts$PercentParent[is.na(counts$PercentParent)] = NA

  return(counts)
}

processGatingPaths = function(summary, max_depth = 1) {

  columns = colnames(summary)

  if (!"path" %in% columns) {
    summary$path = summary$Population
  }

  # determine gating depth for each population
  summary$depth = str_count(summary$path, "/")

  # determine gating depth of the root path
  root_path_length = max(summary$depth)-max_depth

  # split all gating paths into a matrix so that gating results can be more
  # easily extracted later
  pathing = str_split(str_remove(summary$path, '^/'), "/", simplify = TRUE)

  # determine the root path
  # root_path = paste(pathing[nrow(summary), 1:root_path_length], collapse = "/")
  # summary$root_node = root_path

  # determine terminal node
  summary$terminal_node = pathing[cbind(1:nrow(pathing), summary$depth)]

  # determine gating depth after root path
  summary$depth = summary$depth - root_path_length

  # No need to extract modifiers if max_depth is 1
  if (max_depth == 1) {return(summary)}

  # determine what the maximum number of modifiers must have been
  max_modifiers = max_depth -1

  # determine all modifiers and add columns for them, will generate columns of
  # the type modifier_1, modifier_2, ... up to the maximum number of modifiers
  for (i_modifier in 1:max_modifiers ){
    column_name = paste0("modifier", "_", i_modifier)

    summary[[column_name]] = ""

    idx = which(summary$depth>i_modifier)

    summary[idx, column_name] = pathing[cbind(idx, root_path_length+i_modifier)]
  }

  return(summary)
}

assignRoot = function(nodes, rootPaths) {
  # Escape both + and - signs in rootPaths
  escaped_rootPaths <- sapply(rootPaths, function(path) {
      path <- str_replace_all(path, "\\+", "\\\\+")  # Escape +
      path <- str_replace_all(path, "\\-", "\\\\-")  # Escape -
      return(path)
    })
  
  # Create a new column in counts
  nodes <- nodes %>%
    rowwise() %>%  # rowwise to evaluate for each row
    mutate(
      rootPath = {
        match <- sapply(names(escaped_rootPaths), function(x) {
          # Match complete paths (followed by a '/' or end of string '$')
          str_detect(path, paste0(escaped_rootPaths[[x]], "(/|$)"))
        })
        if(any(match)) {
          names(escaped_rootPaths)[which(match)[1]]  # Return the first match's name from rootPaths
        } else {
          NA  # No match found
        }
      },
      # Remove the rootPath portion from Population to get pathInCompartment
      pathInCompartment = ifelse(!is.na(rootPath), 
                                 str_remove(path, paste0(escaped_rootPaths[rootPath], "(/|$)")), 
                                 NA)
    ) %>%
    ungroup()  # undo rowwise
  
  return (nodes)
  
} 


convertToMatrix = function(counts, depths = c(1, 2, 3)) {
  counts = dplyr::filter(counts, depth %in% depths)
  
  pctParent =     spread(dplyr::select(counts, sampleName, PercentParent, subset), key = sampleName, value = PercentParent)
  parentCounts =  spread(dplyr::select(counts, sampleName, ParentCount,   subset), key = sampleName, value = ParentCount)
  popCounts =     spread(dplyr::select(counts, sampleName, Count,         subset), key = sampleName, value = Count)
  
  rownames(pctParent) = pctParent$subset
  rownames(parentCounts) = parentCounts$subset
  rownames(popCounts) = popCounts$subset
  
  pctParent = dplyr::select(pctParent, -subset)
  parentCounts = dplyr::select(parentCounts, -subset)
  popCounts = dplyr::select(popCounts, -subset)
  
  return(list(pctParent = pctParent, parentCounts = parentCounts, popCounts = popCounts))
}

```

# Apply stage 1 gating

```{r}

level1_nodes = gate_definitions$Annotation[1:22]

level1_paths = level1Gating(gs, level1_nodes, gate_data, gates, root_node)

# level1_paths should look something like this
#>      node                  parent                     population
#> 1  CD49b+ root/Teff+/CD45RO+/TEM+ root/Teff+/CD45RO+/TEM+/CD49b+
#> 2   ICOS+ root/Teff+/CD45RO+/TEM+  root/Teff+/CD45RO+/TEM+/ICOS+
#> 3  TIGIT+ root/Teff+/CD45RO+/TEM+ root/Teff+/CD45RO+/TEM+/TIGIT+

```

# Get counts of cell populations for lvl 1 gating

```{r}

counts = gs_pop_get_count_fast(gs, format = "long")

# Add percent parent
counts$PercentParent = counts$Count/counts$ParentCount*100

# Filter down to populations from stage 1 gating
counts = dplyr::filter(counts, Population %in% level1_paths$gs_path)
head(counts)

# should see sample name (.fcs), pop, parent, count, parent count, % parent

```

# Compare counts in lvl 1 nodes by irAE group

```{r}

# Merge the annotation data into the counts frame
counts = merge(counts, annotation, by.x = "name", by.y = "fcsName")

summary = summarizePopulations(counts)
stats = generateStatistics(counts, summary, "Control", c("Type 1 Diabetes", "DSRegistry"))

stats$fdr[stats$condition == "DSRegistry"] = p.adjust(stats$pvalue[stats$condition == "DSRegistry"], method = "BH")

stats$fdr[stats$condition == "Type 1 Diabetes"] = p.adjust(stats$pvalue[stats$condition == "Type 1 Diabetes"], method = "BH")

head(stats)

stats = processGatingPaths(stats, max_depth = 1)

head(stats)

```

# Visualize significant hits

```{r}

gg_vp_stage1 = stats %>%
  ggplot(aes(x = log2Fold, y = -log10(fdr), color = terminal_node)) + 
  geom_point(alpha=0.7, size=2.5, shape = 19) +
  facet_grid(. ~ condition, scales = "fixed") + 
  theme_bw()
  
gg_vp_stage1

# pick only populations with significant fdrs in at least one of the experimental groups
stats_significant = dplyr::filter(stats, fdr < 0.5) 

# process the gating paths
counts = processGatingPaths(counts, max_depth = 1)

gg_box_stage1 = counts %>% 
    dplyr::filter(Population %in% stats_significant$path) %>%
    ggplot(aes(x = condition, y = PercentParent, fill = condition) ) +
    geom_boxplot(outlier.shape = NA) +
    geom_jitter(aes(color = condition), position = position_jitter(0.15)) +
    theme_bw() +
    theme(axis.text.x = element_blank()) + 
    ylab("Percent of parent population") + 
    facet_wrap(.~ terminal_node, scales = "free", ncol = 3)

gg_box_stage1

```

# Repeat above for stage 2, and stage 3 (after that, diminished returns for new info)