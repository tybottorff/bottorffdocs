---
title: "CyTOF analyses for NCI irAE project"
output: pdf_document
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(beeswarm)
library(Matrix)
library(ggplot2)
library(stringr)
library(scales)
library(tidyr)
library(ComplexHeatmap)
library(viridis)
library(readxl)
library(circlize)
library(Seurat)
library(factoextra)
library(lmerTest)
library(gtsummary)
library(ica)
library(CytoExploreR)
library(dplyr)
library(ggrepel)
library(purrr)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in baseline data to look at group differences
 - may want to work with dates later, use as.Date(date, origin = "1899-12-30")

```{r}

baseline_flow_data <- read_excel("../raw_data/2024_10_17_flow_data.xlsx") %>%
  # subset for only baseline visits
  mutate(cleaned_visit_num = str_extract(`Visit Descriptor`, "\\d+")) %>%
  # CTCAE Grade (Highest) is the column for (ir)AE grade
  rename(patient_id = `Subject ID`, ctcae_grade = `CTCAE Grade (Highest)`, group = `General irAE Classification`, specific_group = `Patient Type`, age = `Age at Draw`, irae_ex = `irAE Documented (if any)`) %>%
  # if CTCAE grade is not-NA, group should be irAE... (some grade 1-2 ctcae were in non-irAE group before using updated category 9/6/24, using `General irAE Classification` as its cleaner metadata though otherwise
  mutate(group = if_else(!is.na(ctcae_grade), "irAE/SAE", group)) %>%
  dplyr::filter(cleaned_visit_num == 1 | is.na(cleaned_visit_num) & group %in% c("AID_Patient", "Healthy_Control")) %>%
  select(patient_id, group, ctcae_grade, specific_group, cleaned_visit_num, Batch, age, irae_ex, starts_with("pct_")) %>%
  pivot_longer(
    cols = starts_with("pct_"), 
    names_to = "sort",
    values_to = "freq") %>%
  mutate(parent_population = gsub(".*_of_", "", sort),
         parent_population = gsub("_", " ", parent_population),
         parent_parent_population = str_extract(parent_population, "[^ ]+$"),
         sort = gsub("pct_", "", sort),
         sort = gsub("_", " ", sort)
  ) %>%
  dplyr::filter(freq > 0) %>%
  dplyr::filter(!(sort %in% c("granulocytes of live", "PD1pos of DN Bcells", "PD1pos of naive Bcells", "PD1pos of swMem Bcells", "PD1pos of unswMem Bcells", "basophils of nonGrans", "EMRA of Tconv Tcells", "CXCR6pos of NN CD8 Tcells", "CXCR6posGrzmBpos of NN CD8 Tcells"))) %>%
  mutate(irae_severity_based_on_ctcae = case_when(
    group == "irAE/SAE" & ctcae_grade > 2 ~ "Serious irAE/SAE",
    group == "irAE/SAE" & ctcae_grade < 3 ~ "Non-serious irAE/SAE",
    group == "non-irAE" ~ "Non-irAE",
    TRUE ~ NA),
    thyroid_irae = if_else(str_detect(irae_ex, regex("thyroid", ignore_case = TRUE)),
                                "Thyroid irAE", 
                                "No thyroid irAE"),
    skin_irae = if_else(str_detect(irae_ex, regex("rash|Rash|Pruritus", ignore_case = TRUE)),
                                "Skin irAE", 
                                "No skin irAE"))
    
# only 2 patients with serious (grade > 2) irAEs

baseline_flow_data

```

# Define logit transform func

```{r}

logitNorm <- function(v){
  newVals <- v
  # Check to see if it's 0 to 1 or 0 to 100, and then switch it to 0 to 1
  if( any(v>1) & all(v<=100) ){
    newVals <- v/100
  }
  # if there are 0s or 1s, add/subtract a small value
  # so the logit norm is defined
  epsilon <- min(newVals[newVals!=0])/2
  newVals[newVals==0] <- epsilon
  newVals[newVals==1] <- 1-epsilon
  # Do the logit norm
  newVals <- log2(newVals/(1-newVals))
  if( any(is.na(newVals))){
    print(head(data.frame(v,newVals)))
  }
  return(newVals)
}

```

# Stats tests for baseline data

```{r}

stats_test <- baseline_flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  group_by(sort) %>%
  summarize(
    # Perform Shapiro-Wilk test for normality in each group
    shapiro_non_irae = shapiro.test(freq[group == "non-irAE"])$p.value,
    shapiro_irae = shapiro.test(freq[group == "irAE/SAE"])$p.value,
    
    # Choose between t-test and Wilcoxon test based on normality
    pval = ifelse(
      shapiro_non_irae > 0.05 & shapiro_irae > 0.05,
      t.test(freq[group == "non-irAE"], 
             freq[group == "irAE/SAE"], 
             paired = FALSE)$p.value,
      wilcox.test(freq[group == "non-irAE"], 
                  freq[group == "irAE/SAE"], 
                  paired = FALSE, exact = FALSE)$p.value
    )
  ) %>%
  # Adjust p-values using BH method
  mutate(adj_pval = p.adjust(pval, method = "BH")) %>%
  arrange(adj_pval)

stats_test

# no sig results for different pairwise comparisons b/w cancer irAE/no irAE subgroups (grade > 2 irAE vs. < 2 for example)

```

# Prepare data for PCA from baseline data (logit transformed freqs)

```{r}

wide_baseline_flow_num_data <- baseline_flow_data %>%
  #filter(group %in% c("AID_Patient")) %>%
  dplyr::filter(group %in% c("non-irAE", "irAE/SAE")) %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, cleaned_visit_num)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  select(-c(patient_id, group, specific_group, Batch, age, irae_severity_based_on_ctcae, ctcae_grade, irae_ex, thyroid_irae, skin_irae)) %>%
  # have to get rid of patients with > 1 NA in any feature for PCA (could also get rid of features instead...)
  drop_na() #%>%
  # just look at features most discriminatory between irAE and no irAE groups
  #select("unswMem of Bcells", "CM of Tconv Tcells", "PD1pos of CM Tconv Tcells", "CCR6pos of NN Tconv Tcells", "DN of Bcells", "pDC of nonGrans")

wide_baseline_flow_num_data

wide_baseline_flow_metadata <- baseline_flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  #filter(group %in% c("AID_Patient")) %>%
  dplyr::filter(group %in% c("non-irAE", "irAE/SAE")) %>%
  mutate(specific_group = case_when(
         group == "AID_Patient" & specific_group == "Type 1 Diabetes" ~ "T1D",
         group == "AID_Patient" & specific_group == "RA" ~ "RA",
         group == "AID_Patient" & !(is.na(specific_group)) ~ "Gut",
         group == "Healthy_Control" ~ "HC",
         TRUE ~ specific_group)) %>%
  #mutate(specific_group = case_when(
  #       specific_group %in% c("Renal Cancer, Bladder Cancer", "Bladder Cancer") ~ "Bladder/\nrenal\ncancer",
  #       specific_group %in% c("Urinary Tract Cancer", "Urethral Cancer") ~ "Urinary\ntract/\nurethral\ncancer",
  #       specific_group %in% c("Lung Disease, Lung Cancer", "Lung Cancer") ~ "Lung\ncancer/\ndisease",
  #       specific_group == "Head and Neck Cancer, Lung Cancer" ~ "Head\nand\nneck/\nlung\ncancer",
  #       specific_group == "Head and Neck Cancer" ~ "Head\nand\nneck\ncancer",
  #       specific_group == "Gastric cancer" ~ "Gastric\ncancer",
  #       TRUE ~ specific_group)) %>%
  select(-c(parent_population, parent_parent_population, cleaned_visit_num)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  drop_na(-c(group, patient_id, Batch, age, irae_severity_based_on_ctcae, ctcae_grade, irae_ex, thyroid_irae, skin_irae)) %>%
  select(c(patient_id, group, specific_group, Batch, age, irae_severity_based_on_ctcae, ctcae_grade, irae_ex, thyroid_irae, skin_irae)) %>%
  mutate(patient_id_simple = row_number()) %>%
  mutate(group = case_when(
    group == "Healthy_Control" ~ "HC",
    group == "AID_Patient" ~ "AID",
    TRUE ~ group
  ))

wide_baseline_flow_metadata

```

# Look at DP (feature lost in regressing out covars)

```{r}

plot_data <- baseline_flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  dplyr::filter(sort == "DP of Tcells")

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  #facet_wrap(~ sort, ncol = 3) +
  geom_jitter(color = "grey", size = 0.5) +
  labs(x = "", y = "DP of Tcells freq (logit-\ntransformed % of parent)") +
  scale_fill_manual(values = c("Healthy_Control" = "purple", "AID_Patient" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

```

# Make PCA plots for baseline data

```{r}

#dim(wide_baseline_flow_num_data)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores= as.data.frame(pca$x)

pcaScores

pcaScores$patient_id_simple = row.names(pcaScores)

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1 <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1) %>%
    head(10)

top_contributing_features_PC2 <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2) %>%
    head(10)

# Plot PCA with ellipses around clusters
p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 0, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = group), size = 2, alpha = 0.8) +
  stat_ellipse(aes(x = PC1, y = PC2, color = group), size = 1, linetype = 2) +
  xlim(-limits[1], limits[1]) +
  ylim(-limits[2], limits[2]) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2], color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),
    legend.spacing.y = unit(0.1, 'cm'),
    legend.spacing.x = unit(0.3, 'cm')
  ) +
  guides(color = guide_legend(nrow = 2, byrow = TRUE))

p

# Statistical comparison of clusters using compareGroups
compVar <- pcaData %>%
  select(PC1, PC2, PC3, group, treatment) %>%
  mutate(group = factor(group, levels = c("HC", "T1D")))  # Adjust levels as needed

# Run statistical test on PCA components by group
res <- compareGroups(group ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 2)
summary(res)

# Display comparison table
createTable(res, show.p.overall = TRUE)

#ggsave("../figures/baseline_pca_specific_irae_group.png", plot = p, width = 3, height = 3.5)
#ggsave("../figures/baseline_pca_group.png", plot = p, width = 3, height = 3.5)
#ggsave("../figures/baseline_pca_batch.png", plot = p, width = 3.5, height = 3.5)
#ggsave("../figures/baseline_pca_specific_aid_and_hc.png", plot = p, width = 3, height = 3.5)

```

# Look for correlation b/w irAE grade and freq for each feature/subset (baseline)

```{r}

ctcae_cor_df <- baseline_flow_data %>%
  filter(!(is.na(ctcae_grade))) %>%
  group_by(sort) %>%
  summarize(cor_result = list(cor.test(ctcae_grade, freq, method = "spearman")), .groups = 'drop') %>%
  mutate(
    estimate = map_dbl(cor_result, ~ .x$estimate),
    p.value = map_dbl(cor_result, ~ .x$p.value)
  ) %>%
  mutate(p.adj = p.adjust(p.value, method = "BH")) %>%
  select(sort, estimate, p.adj) %>%
  arrange(p.adj) %>%
  print()

```

# Heatmap (using Z scores of freqs in subsets across patients) for cancer subgroups (baseline)

```{r}

flow_data_filtered <- baseline_flow_data %>%
  filter(group %in% c("non-irAE", "irAE/SAE"))

# Define the order of groups
group_order <- c("Non-irAE", "Non-serious irAE/SAE", "Serious irAE/SAE")

# Reorder the patient_group factor by irae_severity_based_on_ctcae
flow_data_filtered$irae_severity_based_on_ctcae <- factor(flow_data_filtered$irae_severity_based_on_ctcae, levels = group_order)

# Recreate the patient_group column to reflect the new order
flow_data_filtered$patient_group <- paste(flow_data_filtered$patient_id, flow_data_filtered$irae_severity_based_on_ctcae, sep = "_")

# Reshape the data to wide format (rows: sort, cols: patient_id + irae_severity_based_on_ctcae)
heatmap_data <- reshape2::dcast(flow_data_filtered, sort ~ patient_group, value.var = "freq")

# Convert to matrix format for the heatmap
mat <- as.matrix(heatmap_data[, -1])
rownames(mat) <- heatmap_data$sort

# Compute Z-scores for the matrix
mat_z <- t(scale(t(mat)))  # Scale (across rows)

# Extract patient ID and group from column names
col_names <- colnames(mat)
patient_ids <- sub("_(.*)", "", col_names)  # Extract patient ID
groups <- sub("^[^_]*_", "", col_names)     # Extract group

# Create a dataframe for sorting columns
col_info <- data.frame(
  patient_id = patient_ids,
  group = factor(groups, levels = group_order),
  col_name = col_names
)

# Order by group first and then by patient ID
sorted_col_info <- col_info %>%
  arrange(group, patient_id)

# Reorder the matrix based on sorted columns
sorted_columns <- sorted_col_info$col_name
mat_z <- mat_z[, sorted_columns]

# Create column annotations
col_annotations <- data.frame(Group = sorted_col_info$group)

# Define colors for column annotations
annotation_colors <- list(
  Group = c("Non-irAE" = "black", "Non-serious irAE/SAE" = "green", "Serious irAE/SAE" = "red")
)

# Create HeatmapAnnotation for columns
col_anno <- HeatmapAnnotation(
  Group = col_annotations$Group,
  col = annotation_colors
)

# Create a dataframe for sorting rows
row_info <- data.frame(
  sort = rownames(mat_z),
  parent_pop = gsub(".* of ", "", rownames(mat)),
  parent_parent_population = str_extract(gsub(".* of ", "", rownames(mat)), "[^ ]+$")
) %>%
  # Reorder rows based on parent pop
  arrange(parent_parent_population)

sorted_rows <- row_info$sort
mat_z <- mat_z[match(sorted_rows, rownames(mat_z)), ]

# Create row annotations
row_annotations <- data.frame(ParentparentPop = row_info$parent_parent_population)

# Alphabetize the unique parent_parent_population values
sorted_parent_parent_pops <- sort(unique(row_info$parent_parent_population))

# Define Viridis colors for the alphabetized parent_parent_population values
viridis_colors <- viridis::viridis(length(sorted_parent_parent_pops))

# Map colors to alphabetized ParentPop values
row_annotation_colors <- setNames(viridis_colors, sorted_parent_parent_pops)

# Ensure ParentPop factor levels are ordered alphabetically
row_annotations$ParentparentPop <- factor(row_annotations$ParentparentPop, levels = sorted_parent_parent_pops)

# Create HeatmapAnnotation for rows
row_anno <- rowAnnotation(
  ParentparentPop = row_annotations$ParentparentPop,
  col = list(ParentparentPop = row_annotation_colors)
)

# Plot the heatmap
heatmap_obj <- Heatmap(
  mat_z,
  cluster_rows = TRUE,
  cluster_columns = FALSE,
  row_names_gp = gpar(fontsize = 7),  # Adjust font size if needed
  top_annotation = col_anno,  # Annotation for columns
  right_annotation = row_anno,  # Annotation for rows
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")),
  show_row_names = TRUE,
  show_column_names = FALSE,
  heatmap_legend_param = list(title = "Z-score")
)

# Save the heatmap to a PDF file
pdf(file = "../figures/heatmap_z_scores_baseline_cancer.pdf", width = 10, height = 8)  # Adjust width and height as needed
draw(heatmap_obj)  # Render the heatmap
dev.off()  # Close the PDF device

```

# Heatmap (using Z scores of freqs in subsets across patients) for all baseline groups

```{r}

flow_data_filtered <- baseline_flow_data

# Define the order of groups
group_order <- c("Healthy_Control", "AID_Patient", "irAE/SAE", "non-irAE")

# Reorder the patient_group factor by group
flow_data_filtered$group <- factor(flow_data_filtered$group, levels = group_order)

# Recreate the patient_group column to reflect the new order
flow_data_filtered$patient_group <- paste(flow_data_filtered$patient_id, flow_data_filtered$group, sep = "_")

# Reshape the data to wide format (rows: sort, cols: patient_id + group)
heatmap_data <- reshape2::dcast(flow_data_filtered, sort ~ patient_group, value.var = "freq")

# Convert to matrix format for the heatmap
mat <- as.matrix(heatmap_data[, -1])
rownames(mat) <- heatmap_data$sort

# Compute Z-scores for the matrix
mat_z <- t(scale(t(mat)))  # Scale (across rows)

# Extract patient ID and group from column names
col_names <- colnames(mat)
patient_ids <- sub("_(.*)", "", col_names)  # Extract patient ID
groups <- sub("^[^_]*_", "", col_names)     # Extract group

# Create a dataframe for sorting columns
col_info <- data.frame(
  patient_id = patient_ids,
  group = factor(groups, levels = group_order),
  col_name = col_names
)

# Order by group first and then by patient ID
sorted_col_info <- col_info %>%
  arrange(group, patient_id)

# Reorder the matrix based on sorted columns
sorted_columns <- sorted_col_info$col_name
mat_z <- mat_z[, sorted_columns]

# Create column annotations
col_annotations <- data.frame(Group = sorted_col_info$group)

# Define colors for column annotations
annotation_colors <- list(
  Group = c("Healthy_Control" = "black", "AID_Patient" = "blue", "irAE/SAE" = "red", "non-irAE" = "green")
)

# Create HeatmapAnnotation for columns
col_anno <- HeatmapAnnotation(
  Group = col_annotations$Group,
  col = annotation_colors
)

# Create a dataframe for sorting rows
row_info <- data.frame(
  sort = rownames(mat_z),
  parent_pop = gsub(".* of ", "", rownames(mat)),
  parent_parent_population = str_extract(gsub(".* of ", "", rownames(mat)), "[^ ]+$")
) %>%
  mutate(top_var = if_else(sort %in% rownames(top_contributing_features_PC1) | sort %in% rownames(top_contributing_features_PC2), "top_var", "not_top_var")) %>%
  # Reorder rows based on parent pop
  arrange(top_var, parent_parent_population)

sorted_rows <- row_info$sort
mat_z <- mat_z[match(sorted_rows, rownames(mat_z)), ]

# Create row annotations
row_annotations <- data.frame(ParentparentPop = row_info$parent_parent_population)

# Alphabetize the unique parent_parent_population values
sorted_parent_parent_pops <- sort(unique(row_info$parent_parent_population))

# Define Viridis colors for the alphabetized parent_parent_population values
viridis_colors <- viridis::viridis(length(sorted_parent_parent_pops))

# Map colors to alphabetized ParentPop values
row_annotation_colors <- setNames(viridis_colors, sorted_parent_parent_pops)

# Ensure ParentPop factor levels are ordered alphabetically
row_annotations$ParentparentPop <- factor(row_annotations$ParentparentPop, levels = sorted_parent_parent_pops)

# Create HeatmapAnnotation for rows
row_anno <- rowAnnotation(
  ParentparentPop = row_annotations$ParentparentPop,
  col = list(ParentparentPop = row_annotation_colors)
)

row.subsections <- c(53, 18)

# Plot the heatmap
heatmap_obj <- Heatmap(
  mat_z,
  cluster_rows = TRUE,
  cluster_columns = FALSE,
  row_names_gp = gpar(fontsize = 8),  # Adjust font size if needed
  top_annotation = col_anno,  # Annotation for columns
  right_annotation = row_anno,  # Annotation for rows
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")),
  show_row_names = TRUE,
  show_column_names = FALSE,
  heatmap_legend_param = list(title = "Z-score"),
  row_split = data.frame(rep(c("Not top contributor to PCs 1-2", "Top contributor to PCs 1-2"), row.subsections))
)

# Save the heatmap to a PDF file
pdf(file = "../figures/heatmap_z_scores_all_baseline.pdf", width = 10, height = 8)  # Adjust width and height as needed
draw(heatmap_obj)  # Render the heatmap
dev.off()  # Close the PDF device

```

# Heatmap (using Z scores of freqs in subsets across patients) for significant hits for AID vs. cancer (baseline)

```{r}

flow_data_filtered <- baseline_flow_data %>%
  filter(group != "HC")

# Define the order of groups
group_order <- c("AID", "irAE/SAE", "non-irAE")

# Reorder the patient_group factor by group
flow_data_filtered$group <- factor(flow_data_filtered$group, levels = group_order)

# Recreate the patient_group column to reflect the new order
flow_data_filtered$patient_group <- paste(flow_data_filtered$patient_id, flow_data_filtered$group, sep = "_")

# Reshape the data to wide format (rows: sort, cols: patient_id + group)
heatmap_data <- reshape2::dcast(flow_data_filtered, sort ~ patient_group, value.var = "freq")

# Convert to matrix format for the heatmap
mat <- as.matrix(heatmap_data[, -1])
rownames(mat) <- heatmap_data$sort

# Compute Z-scores for the matrix
mat_z <- t(scale(t(mat)))  # Scale (across rows)

# Extract patient ID and group from column names
col_names <- colnames(mat)
patient_ids <- sub("_(.*)", "", col_names)  # Extract patient ID
groups <- sub("^[^_]*_", "", col_names)     # Extract group

# Create a dataframe for sorting columns
col_info <- data.frame(
  patient_id = patient_ids,
  group = factor(groups, levels = group_order),
  col_name = col_names
)

# Order by group first and then by patient ID
sorted_col_info <- col_info %>%
  arrange(group, patient_id)

# Reorder the matrix based on sorted columns
sorted_columns <- sorted_col_info$col_name
mat_z <- mat_z[, sorted_columns]

# Create column annotations
col_annotations <- data.frame(Group = sorted_col_info$group)

# Define colors for column annotations
annotation_colors <- list(
  Group = c("AID" = "blue", "irAE/SAE" = "red", "non-irAE" = "green")
)

# Create HeatmapAnnotation for columns
col_anno <- HeatmapAnnotation(
  Group = col_annotations$Group,
  col = annotation_colors
)

# significant populations (AID vs. cancer, 13)
sig_list <- c("Treg of CD4 Tcells", "naive of CD8 Tcells", "Tcells of nonGrans", "NKcells of nonGrans", "Tfh of NN Tconv Tcells", "CXCR3pos of NN CD8 Tcells", "CD11cpos of Bcells", "MAIT of NN CD8 Tcells", "naive of Treg Tcells", "CRTH2pos of NN CD8 Tcells", "unswMem of Bcells", "Bcells of nonGrans", "CCR4pos of NN Tconv Tcells")

# Create a dataframe for sorting rows based on if significant for AID vs. cancer
row_info <- data.frame(
  sort = rownames(mat_z),
  parent_pop = gsub(".* of ", "", rownames(mat))
) %>%
  mutate(special = if_else(sort %in% sig_list, "Yes", "No"),
        # Trim leading/trailing spaces and standardize capitalization
        parent_pop = trimws(parent_pop),
        parent_pop = tolower(parent_pop)) %>%
  # Reorder rows based on if in significant list above + parent pop
  arrange(special, parent_pop)

sorted_rows <- row_info$sort
mat_z <- mat_z[match(sorted_rows, rownames(mat_z)), ]

# Create row annotations
row_annotations <- data.frame(ParentPop = row_info$parent_pop)

# Alphabetize the unique parent_pop values
sorted_parent_pops <- sort(unique(row_info$parent_pop))

# Define Viridis colors for the alphabetized parent_pop values
viridis_colors <- viridis::viridis(length(sorted_parent_pops))

# Map colors to alphabetized ParentPop values
row_annotation_colors <- setNames(viridis_colors, sorted_parent_pops)

# Ensure ParentPop factor levels are ordered alphabetically
row_annotations$ParentPop <- factor(row_annotations$ParentPop, levels = sorted_parent_pops)

# Create HeatmapAnnotation for rows
row_anno <- rowAnnotation(
  ParentPop = row_annotations$ParentPop,
  col = list(ParentPop = row_annotation_colors)
)

row.subsections <- c(58, 13)

# Plot the heatmap
heatmap_obj <- Heatmap(
  mat_z,
  cluster_rows = TRUE,
  cluster_columns = FALSE,
  row_names_gp = gpar(fontsize = 8),  # Adjust font size if needed
  top_annotation = col_anno,  # Annotation for columns
  right_annotation = row_anno,  # Annotation for rows
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")),
  show_row_names = TRUE,
  show_column_names = FALSE,
  heatmap_legend_param = list(title = "Z-score"),
  row_split = data.frame(rep(c("Not significant\nAID vs. cancer", "Significant AID\nvs. cancer"), row.subsections)),
  border = FALSE  # remove borders between splits
)

# Save the heatmap to a PDF file
pdf(file = "../figures/heatmap_z_scores_AID_vs_cancer.pdf", width = 10, height = 8)  # Adjust width and height as needed
draw(heatmap_obj)  # Render the heatmap
dev.off()  # Close the PDF device

```

# Heatmap (using Z scores of freqs in subsets across patients) for significant hits for irAE vs. AID (baseline)

```{r}

flow_data_filtered <- baseline_flow_data %>%
  filter(group %in% c("AID_Patient", "irAE/SAE"))

# Define the order of groups
group_order <- c("AID_Patient", "irAE/SAE")

# Reorder the patient_group factor by group
flow_data_filtered$group <- factor(flow_data_filtered$group, levels = group_order)

# Recreate the patient_group column to reflect the new order
flow_data_filtered$patient_group <- paste(flow_data_filtered$patient_id, flow_data_filtered$group, sep = "_")

# Reshape the data to wide format (rows: sort, cols: patient_id + group)
heatmap_data <- reshape2::dcast(flow_data_filtered, sort ~ patient_group, value.var = "freq")

# Convert to matrix format for the heatmap
mat <- as.matrix(heatmap_data[, -1])
rownames(mat) <- heatmap_data$sort

# Compute Z-scores for the matrix
mat_z <- t(scale(t(mat)))  # Scale (across rows)

# Extract patient ID and group from column names
col_names <- colnames(mat)
patient_ids <- sub("_(.*)", "", col_names)  # Extract patient ID
groups <- sub("^[^_]*_", "", col_names)     # Extract group

# Create a dataframe for sorting columns
col_info <- data.frame(
  patient_id = patient_ids,
  group = factor(groups, levels = group_order),
  col_name = col_names
)

# Order by group first and then by patient ID
sorted_col_info <- col_info %>%
  arrange(group, patient_id)

# Reorder the matrix based on sorted columns
sorted_columns <- sorted_col_info$col_name
mat_z <- mat_z[, sorted_columns]

# Create column annotations
col_annotations <- data.frame(Group = sorted_col_info$group)

# Define colors for column annotations
annotation_colors <- list(
  Group = c("AID_Patient" = "blue", "irAE/SAE" = "red")
)

# Create HeatmapAnnotation for columns
col_anno <- HeatmapAnnotation(
  Group = col_annotations$Group,
  col = annotation_colors
)

# significant populations (AID vs. irAE/SAE, 11)
sig_list <- c("CD11cpos of Bcells", "NKcells of nonGrans", "Tcells of nonGrans", "Tfh of NN Tconv Tcells", "Tfh of NN Tconv Tcells", "naive of CD8 Tcells", "unswMem of Bcells", "Bcells of nonGrans", "CXCR3pos of NN CD8 Tcells", "naive of Treg Tcells", "DN of Bcells")

# Create a dataframe for sorting rows based on if significant for AID vs. irAE/SAE
row_info <- data.frame(
  sort = rownames(mat_z),
  parent_pop = gsub(".* of ", "", rownames(mat))
) %>%
  mutate(special = if_else(sort %in% sig_list, "Yes", "No"),
        # Trim leading/trailing spaces and standardize capitalization
        parent_pop = trimws(parent_pop),
        parent_pop = tolower(parent_pop)) %>%
  # Reorder rows based on if in significant list above + parent pop
  arrange(special, parent_pop)

sorted_rows <- row_info$sort
mat_z <- mat_z[match(sorted_rows, rownames(mat_z)), ]

# Create row annotations
row_annotations <- data.frame(ParentPop = row_info$parent_pop)

# Alphabetize the unique parent_pop values
sorted_parent_pops <- sort(unique(row_info$parent_pop))

# Define Viridis colors for the alphabetized parent_pop values
viridis_colors <- viridis::viridis(length(sorted_parent_pops))

# Map colors to alphabetized ParentPop values
row_annotation_colors <- setNames(viridis_colors, sorted_parent_pops)

# Ensure ParentPop factor levels are ordered alphabetically
row_annotations$ParentPop <- factor(row_annotations$ParentPop, levels = sorted_parent_pops)

# Create HeatmapAnnotation for rows
row_anno <- rowAnnotation(
  ParentPop = row_annotations$ParentPop,
  col = list(ParentPop = row_annotation_colors)
)

row.subsections <- c(69, 11)

# Plot the heatmap
heatmap_obj <- Heatmap(
  mat_z,
  cluster_rows = TRUE,
  cluster_columns = FALSE,
  row_names_gp = gpar(fontsize = 8),  # Adjust font size if needed
  top_annotation = col_anno,  # Annotation for columns
  right_annotation = row_anno,  # Annotation for rows
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")),
  show_row_names = TRUE,
  show_column_names = FALSE,
  heatmap_legend_param = list(title = "Z-score"),
  row_split = data.frame(rep(c("Not significant\nAID vs. irAE", "Significant AID\nvs. irAE"), row.subsections)),
  border = FALSE  # remove borders between splits
)

# Save the heatmap to a PDF file
pdf(file = "../figures/heatmap_z_scores_AID_vs_irAE.pdf", width = 10, height = 8)  # Adjust width and height as needed
draw(heatmap_obj)  # Render the heatmap
dev.off()  # Close the PDF device

```

# Heatmap (using Z scores of freqs in subsets across patients) for significant hits for non-irAE vs. AID (baseline)

```{r}

flow_data_filtered <- baseline_flow_data %>%
  filter(group %in% c("AID_Patient", "non-irAE"))

# Define the order of groups
group_order <- c("AID_Patient", "non-irAE")

# Reorder the patient_group factor by group
flow_data_filtered$group <- factor(flow_data_filtered$group, levels = group_order)

# Recreate the patient_group column to reflect the new order
flow_data_filtered$patient_group <- paste(flow_data_filtered$patient_id, flow_data_filtered$group, sep = "_")

# Reshape the data to wide format (rows: sort, cols: patient_id + group)
heatmap_data <- reshape2::dcast(flow_data_filtered, sort ~ patient_group, value.var = "freq")

# Convert to matrix format for the heatmap
mat <- as.matrix(heatmap_data[, -1])
rownames(mat) <- heatmap_data$sort

# Compute Z-scores for the matrix
mat_z <- t(scale(t(mat)))  # Scale (across rows)

# Extract patient ID and group from column names
col_names <- colnames(mat)
patient_ids <- sub("_(.*)", "", col_names)  # Extract patient ID
groups <- sub("^[^_]*_", "", col_names)     # Extract group

# Create a dataframe for sorting columns
col_info <- data.frame(
  patient_id = patient_ids,
  group = factor(groups, levels = group_order),
  col_name = col_names
)

# Order by group first and then by patient ID
sorted_col_info <- col_info %>%
  arrange(group, patient_id)

# Reorder the matrix based on sorted columns
sorted_columns <- sorted_col_info$col_name
mat_z <- mat_z[, sorted_columns]

# Create column annotations
col_annotations <- data.frame(Group = sorted_col_info$group)

# Define colors for column annotations
annotation_colors <- list(
  Group = c("AID_Patient" = "blue", "non-irAE" = "green")
)

# Create HeatmapAnnotation for columns
col_anno <- HeatmapAnnotation(
  Group = col_annotations$Group,
  col = annotation_colors
)

# significant populations (AID vs. non-irAE, 10)
sig_list <- c("Treg of CD4 Tcells", "naive of CD8 Tcells", "CCR4pos of NN Tconv Tcells", "CRTH2pos of NN CD8 Tcells", "ICOSpos of Tfh Tconv Tcells", "CRTH2pos of NN Tconv Tcells", "SCM of Tconv Tcells", "EMRA of CD8 Tcells", "KLRG1posTIGITpos of CD8 Tcells", "Tcells of nonGrans")

# Create a dataframe for sorting rows based on if significant for AID vs. irAE/SAE
row_info <- data.frame(
  sort = rownames(mat_z),
  parent_pop = gsub(".* of ", "", rownames(mat))
) %>%
  mutate(special = if_else(sort %in% sig_list, "Yes", "No"),
        # Trim leading/trailing spaces and standardize capitalization
        parent_pop = trimws(parent_pop),
        parent_pop = tolower(parent_pop)) %>%
  # Reorder rows based on if in significant list above + parent pop
  arrange(special, parent_pop)

sorted_rows <- row_info$sort
mat_z <- mat_z[match(sorted_rows, rownames(mat_z)), ]

# Create row annotations
row_annotations <- data.frame(ParentPop = row_info$parent_pop)

# Alphabetize the unique parent_pop values
sorted_parent_pops <- sort(unique(row_info$parent_pop))

# Define Viridis colors for the alphabetized parent_pop values
viridis_colors <- viridis::viridis(length(sorted_parent_pops))

# Map colors to alphabetized ParentPop values
row_annotation_colors <- setNames(viridis_colors, sorted_parent_pops)

# Ensure ParentPop factor levels are ordered alphabetically
row_annotations$ParentPop <- factor(row_annotations$ParentPop, levels = sorted_parent_pops)

# Create HeatmapAnnotation for rows
row_anno <- rowAnnotation(
  ParentPop = row_annotations$ParentPop,
  col = list(ParentPop = row_annotation_colors)
)

row.subsections <- c(70, 10)

# Plot the heatmap
heatmap_obj <- Heatmap(
  mat_z,
  cluster_rows = TRUE,
  cluster_columns = FALSE,
  row_names_gp = gpar(fontsize = 8),  # Adjust font size if needed
  top_annotation = col_anno,  # Annotation for columns
  right_annotation = row_anno,  # Annotation for rows
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")),
  show_row_names = TRUE,
  show_column_names = FALSE,
  heatmap_legend_param = list(title = "Z-score"),
  row_split = data.frame(rep(c("Not significant\nAID vs. non-irAE", "Significant AID\nvs. non-irAE"), row.subsections)),
  border = FALSE  # remove borders between splits
)

# Save the heatmap to a PDF file
pdf(file = "../figures/heatmap_z_scores_AID_vs_non_irAE.pdf", width = 10, height = 8)  # Adjust width and height as needed
draw(heatmap_obj)  # Render the heatmap
dev.off()  # Close the PDF device

```

# Heatmap (using Z scores of freqs in subsets across patients) for significant hits for non-irAE vs. HC (baseline)

```{r}

flow_data_filtered <- baseline_flow_data %>%
  filter(group %in% c("Healthy_Control", "non-irAE"))

# Define the order of groups
group_order <- c("Healthy_Control", "non-irAE")

# Reorder the patient_group factor by group
flow_data_filtered$group <- factor(flow_data_filtered$group, levels = group_order)

# Recreate the patient_group column to reflect the new order
flow_data_filtered$patient_group <- paste(flow_data_filtered$patient_id, flow_data_filtered$group, sep = "_")

# Reshape the data to wide format (rows: sort, cols: patient_id + group)
heatmap_data <- reshape2::dcast(flow_data_filtered, sort ~ patient_group, value.var = "freq")

# Convert to matrix format for the heatmap
mat <- as.matrix(heatmap_data[, -1])
rownames(mat) <- heatmap_data$sort

# Compute Z-scores for the matrix
mat_z <- t(scale(t(mat)))  # Scale (across rows)

# Extract patient ID and group from column names
col_names <- colnames(mat)
patient_ids <- sub("_(.*)", "", col_names)  # Extract patient ID
groups <- sub("^[^_]*_", "", col_names)     # Extract group

# Create a dataframe for sorting columns
col_info <- data.frame(
  patient_id = patient_ids,
  group = factor(groups, levels = group_order),
  col_name = col_names
)

# Order by group first and then by patient ID
sorted_col_info <- col_info %>%
  arrange(group, patient_id)

# Reorder the matrix based on sorted columns
sorted_columns <- sorted_col_info$col_name
mat_z <- mat_z[, sorted_columns]

# Create column annotations
col_annotations <- data.frame(Group = sorted_col_info$group)

# Define colors for column annotations
annotation_colors <- list(
  Group = c("Healthy_Control" = "black", "non-irAE" = "green")
)

# Create HeatmapAnnotation for columns
col_anno <- HeatmapAnnotation(
  Group = col_annotations$Group,
  col = annotation_colors
)

# significant populations (HC vs. non-irAE, 5)
sig_list <- c("CRTH2pos of NN Tconv Tcells", "Treg of CD4 Tcells", "CD38hiCD127neg of NN CD8 Tcells", "CRTH2pos of NN CD8 Tcells", "SCM of Tconv Tcells")

# Create a dataframe for sorting rows based on if significant for AID vs. irAE/SAE
row_info <- data.frame(
  sort = rownames(mat_z),
  parent_pop = gsub(".* of ", "", rownames(mat))
) %>%
  mutate(special = if_else(sort %in% sig_list, "Yes", "No"),
        # Trim leading/trailing spaces and standardize capitalization
        parent_pop = trimws(parent_pop),
        parent_pop = tolower(parent_pop)) %>%
  # Reorder rows based on if in significant list above + parent pop
  arrange(special, parent_pop)

sorted_rows <- row_info$sort
mat_z <- mat_z[match(sorted_rows, rownames(mat_z)), ]

# Create row annotations
row_annotations <- data.frame(ParentPop = row_info$parent_pop)

# Alphabetize the unique parent_pop values
sorted_parent_pops <- sort(unique(row_info$parent_pop))

# Define Viridis colors for the alphabetized parent_pop values
viridis_colors <- viridis::viridis(length(sorted_parent_pops))

# Map colors to alphabetized ParentPop values
row_annotation_colors <- setNames(viridis_colors, sorted_parent_pops)

# Ensure ParentPop factor levels are ordered alphabetically
row_annotations$ParentPop <- factor(row_annotations$ParentPop, levels = sorted_parent_pops)

# Create HeatmapAnnotation for rows
row_anno <- rowAnnotation(
  ParentPop = row_annotations$ParentPop,
  col = list(ParentPop = row_annotation_colors)
)

row.subsections <- c(75, 5)

# Plot the heatmap
heatmap_obj <- Heatmap(
  mat_z,
  cluster_rows = TRUE,
  cluster_columns = FALSE,
  row_names_gp = gpar(fontsize = 8),  # Adjust font size if needed
  top_annotation = col_anno,  # Annotation for columns
  right_annotation = row_anno,  # Annotation for rows
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")),
  show_row_names = TRUE,
  show_column_names = FALSE,
  heatmap_legend_param = list(title = "Z-score"),
  row_split = data.frame(rep(c("Not significant\nHC vs. non-irAE", "Significant HC\nvs. non-irAE"), row.subsections)),
  border = FALSE  # remove borders between splits
)

# Save the heatmap to a PDF file
pdf(file = "../figures/heatmap_z_scores_HC_vs_non_irAE.pdf", width = 10, height = 8)  # Adjust width and height as needed
draw(heatmap_obj)  # Render the heatmap
dev.off()  # Close the PDF device

```

# PCA from all visits of cancer patients + AID baseline

```{r}

longitudinal_data <- read_excel("../raw_data/2024_10_17_flow_data.xlsx") %>%
  # subset for only cancer + AID patients
  filter(`General Patient Type` %in% c("Cancer_Patient", "AID_Patient")) %>%
  rename(patient_id = `Subject ID`, ctcae_grade = `CTCAE Grade (Highest)`, group = `General irAE Classification`, specific_group = `Patient Type`, age = `Age at Draw`, visit_info = `Visit Descriptor`) %>%
  # if CTCAE grade is not-NA, group should be irAE... (some grade 1-2 ctcae were in non-irAE group before using updated category 9/6/24, using `General irAE Classification` as its cleaner metadata though otherwise
  mutate(group = if_else(!is.na(ctcae_grade), "irAE/SAE", group)) %>%
  mutate(irae_severity_based_on_ctcae = case_when(
    group == "irAE/SAE" & ctcae_grade > 2 ~ "Serious irAE/SAE",
    group == "irAE/SAE" & ctcae_grade < 3 ~ "Non-serious irAE/SAE",
    group == "non-irAE" ~ "Non-irAE",
    TRUE ~ NA
  )) %>%
  dplyr::select(patient_id, group, specific_group, visit_info, ctcae_grade, irae_severity_based_on_ctcae, starts_with("pct_")) %>%
  pivot_longer(
    cols = starts_with("pct_"), 
    names_to = "sort",
    values_to = "freq") %>%
  mutate(parent_population = gsub(".*_of_", "", sort),
         parent_population = gsub("_", " ", parent_population),
         parent_parent_population = str_extract(parent_population, "[^ ]+$"),
         sort = gsub("pct_", "", sort),
         sort = gsub("_", " ", sort)
  ) %>%
  mutate(visit_info = case_when(
    str_detect(visit_info, "1") | visit_info == "AID_Patient" ~ "Baseline",
    visit_info %in% c("other", "Other") ~ "Other",
    #visit_info != "irAE F/U" & str_detect(visit_info, "irAE") ~ "irAE",
    #visit_info == "irAE F/U" ~ "irAE F/U",
    TRUE ~ visit_info
    )) %>%
  filter(!(sort %in% c("granulocytes of live", "PD1pos of DN Bcells", "PD1pos of naive Bcells", "PD1pos of swMem Bcells", "PD1pos of unswMem Bcells", "basophils of nonGrans", "EMRA of Tconv Tcells", "CXCR6pos of NN CD8 Tcells", "CXCR6posGrzmBpos of NN CD8 Tcells")),
         !str_detect(sort, "PD"))

longitudinal_data
  
```

# Prepare data for PCA from longitudinal + AID data

```{r}

wide_longitudinal_num_data <- longitudinal_data %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  drop_na(-c(group, patient_id, visit_info, ctcae_grade, irae_severity_based_on_ctcae)) %>%
  select(-c(patient_id, group, specific_group, visit_info, ctcae_grade, irae_severity_based_on_ctcae))

wide_longitudinal_num_data

wide_longitudinal_metadata <- longitudinal_data %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  drop_na(-c(group, patient_id, ctcae_grade, irae_severity_based_on_ctcae)) %>%
  select(c(patient_id, group, specific_group, visit_info, ctcae_grade, irae_severity_based_on_ctcae)) %>%
  mutate(patient_id_simple = row_number())

wide_longitudinal_metadata

```

# Make PCA plots for longitudinal + AID data

```{r}

#dim(wide_longitudinal_num_data)

pca = prcomp(as.data.frame((na.omit(wide_longitudinal_num_data)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores= as.data.frame(pca$x)

pcaScores

pcaScores$patient_id_simple = row.names(pcaScores)

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_longitudinal_metadata, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

pcaData$visit_info <- factor(pcaData$visit_info, 
                             levels = c("Baseline", "Visit 2", "Visit 2, irAE", "Visit 3", "Visit 3, irAE", "Visit 3, irAE F/U", "irAE", "irAE F/U", "Other"))

p <- ggplot(data = pcaData %>% filter(irae_severity_based_on_ctcae == "Serious irAE/SAE" | group == "AID_Patient")) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, shape = group, color = visit_info), size = 1.5, alpha = 0.8) + 
  scale_color_manual(values = c("Baseline" = "#440154FF", "Visit 2" = "#414487FF", "Visit 2, irAE" = "#414487FF", "Visit 3" = "#2A788EFF", "Visit 3, irAE" = "#2A788EFF", "Visit 3, irAE F/U" = "#2A788EFF", "irAE" = "#22A884FF", "irAE F/U" = "#7AD151FF", "Other" = "#FDE725FF")) +  # Set custom colors
  xlim(-limits[1], limits[1]) +
  ylim(-limits[2], limits[2]) +
  #labs(color = "Visit") +
  theme_bw() +
  theme(
    legend.position = "right", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  #guides(
  #  color = guide_legend(nrow = 1, byrow = TRUE),  # Use 2 rows for color legend
  #  shape = guide_legend(nrow = 1, byrow = TRUE)
  #) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

#ggsave("../figures/longitudinal_pca_general_group.png", plot = p, width = 4.5, height = 3.5)

```

# Try mixed effects modeling (linear first, then GAMs if nonlinear) like in https://www.biorxiv.org/content/10.1101/2022.06.05.494592v1.full.pdf from longitudinal data

 - need to reduce correlating variables? group and visit likely don't correlate so no worries

```{r}

mixed_effects_model_df <- read_excel("../raw_data/2024_10_17_flow_data.xlsx") %>%
  mutate(cleaned_visit_num = str_extract(`Visit Descriptor`, "\\d+")) %>%
  # CTCAE Grade (Highest) is the column for (ir)AE grade
  rename(patient_id = `Subject ID`, ctcae_grade = `CTCAE Grade (Highest)`, group = `General irAE Classification`, specific_group = `Patient Type`, age = `Age at Draw`, visit_info = `Visit Descriptor`) %>%
  # if CTCAE grade is not-NA, group should be irAE... (some grade 1-2 ctcae were in non-irAE group before using updated category 9/6/24, using `General irAE Classification` as its cleaner metadata though otherwise
  mutate(group = if_else(!is.na(ctcae_grade), "irAE/SAE", group)) %>%
  mutate(irae_severity_based_on_ctcae = case_when(
    group == "irAE/SAE" & ctcae_grade > 2 ~ "Serious irAE/SAE",
    group == "irAE/SAE" & ctcae_grade < 3 ~ "Non-serious irAE/SAE",
    group == "non-irAE" ~ "Non-irAE",
    TRUE ~ NA
  )) %>%
  select(patient_id, group, specific_group, irae_severity_based_on_ctcae, visit_info, ctcae_grade, Batch, starts_with("pct_")) %>%
  pivot_longer(
    cols = starts_with("pct_"), 
    names_to = "sort",
    values_to = "freq") %>%
  mutate(parent_population = gsub(".*_of_", "", sort),
         parent_population = gsub("_", " ", parent_population),
         parent_parent_population = str_extract(parent_population, "[^ ]+$"),
         sort = gsub("pct_", "", sort),
         sort = gsub("_", " ", sort)
  ) %>%
  mutate(visit_info = case_when(
          str_detect(visit_info, "1") | visit_info %in% c("AID_Patient", "Healthy_Control") ~ 1,
          visit_info %in% c("other", "Other") ~ 6,
          visit_info %in% c("Visit 2", "Visit 2, irAE") ~ 2,
          visit_info %in% c("Visit 3", "Visit 3, irAE", "Visit 3, irAE F/U") ~ 3,
          visit_info != "irAE F/U" & str_detect(visit_info, "irAE") ~ 4,
          visit_info == "irAE F/U" ~ 5
    )) %>%
  filter(!(sort %in% c("granulocytes of live", "PD1pos of DN Bcells", "PD1pos of naive Bcells", "PD1pos of swMem Bcells", "PD1pos of unswMem Bcells", "basophils of nonGrans", "EMRA of Tconv Tcells", "CXCR6pos of NN CD8 Tcells", "CXCR6posGrzmBpos of NN CD8 Tcells")),
         !str_detect(sort, "PD")) %>%
  filter(freq > 0,
         visit_info != 6) %>%
  # getting rid of any sorts with any NA freqs gets rid of some sorts
  mutate(freq = logitNorm(freq)) %>%
  filter(!(is.na(patient_id))) %>%
  # give ctcae grade of 0 for HC, AID, non-irAE
  mutate(ctcae_grade = if_else(is.na(ctcae_grade), 0, ctcae_grade)) %>%
  # filter for cancer patients if doing CTCAE-grade based approach (want 0 score ref to only be cancer patients)
  filter(group %in% c("non-irAE", "irAE/SAE"))

unique(mixed_effects_model_df$visit_info)

visit_levels <- c(1, 2, 3, 4, 5)
ctcae_levels <- c(0, 1, 2, 3)
#group_levels <- c("non-irAE", "irAE/SAE", "Healthy_Control", "AID_Patient")

mixed_effects_model_df$visit_info <- factor(mixed_effects_model_df$visit_info, levels = visit_levels)
#mixed_effects_model_df$group <- factor(mixed_effects_model_df$group, levels = group_levels)
mixed_effects_model_df$ctcae_grade <- factor(mixed_effects_model_df$ctcae_grade, levels = ctcae_levels)

# mixed effects model, allow for variation between subjects in ref, 1|patient_id doesn't account for variation b/w subjects in response but group*time does (variation between irAE groups in response to ICI over time)

sorts <- unique(mixed_effects_model_df$sort)

results <- list()
residuals_combined <- list()

library(broom.mixed)

for (s in sorts) {
  subset_data <- mixed_effects_model_df %>% filter(sort == s)
  
  # Get unique combinations of patient_id and visit_info to combine as metadata w/ residuals df
  unique_combinations <- subset_data %>%
    select(patient_id, visit_info, ctcae_grade)
  
  # Fit the mixed-effects model
  fit <- lmer(freq ~ visit_info*ctcae_grade + Batch + (1 | patient_id), data = subset_data)
  # visit_info + visit_info:ctcae_grade to allow ctcae_grade as main effect (for baseline temporally stable effects)
  # visit_info*ctcae_grade otherwise
  
  # Extract residuals
  residuals_data <- residuals(fit)
  
  # Combine residuals with unique_combinations
  residuals_df <- cbind(unique_combinations, residuals = residuals_data)
  
  # Store in the list
  residuals_combined[[s]] <- residuals_df
  
  # Capture the model summary using broom.mixed
  model_summary <- tidy(fit, effects = "fixed")
  
  # Store the summary in the results list
  results[[s]] <- model_summary
}

combined_residuals_df <- bind_rows(lapply(names(residuals_combined), function(s) {
  residuals_combined[[s]] %>%
    mutate(sort = s)

}))

combined_results_df <- bind_rows(results, .id = "sort")

```

# Look for baseline effects subtracting group/time effects, observe 1 hit (SCM of Tconv Tcells)
 - for this, important to NOT include group in model specification, only visit_info, batch, and donorID

```{r}

combined_residuals_df %>%
  filter(visit_info == 1) %>%
  group_by(sort) %>%
  summarize(pval = wilcox.test(residuals[ctcae_grade == "0"], residuals[ctcae_grade %in% c("1", "2", "3")], paired = FALSE, exact = FALSE)$p.value) %>%
  mutate(adj_pval = p.adjust(pval, method = "BH")) %>%
  arrange(adj_pval) %>%
  print()

```

# Plot significant results from LM

```{r}

# CCR6pos of NN Tconv Tcells & swMem of Bcells for possible ctcae level effects, others for possible interaction effects

"yes vs. no irAE over time
CD56bright of NKcells"

p <- ggplot(mixed_effects_model_df %>% filter(sort %in% c("CCR6pos of NN Tconv Tcells", "swMem of Bcells")), aes(x = interaction(visit_info, ctcae_grade), y = (freq), color = ctcae_grade)) +
  geom_boxplot(aes(group = interaction(visit_info, ctcae_grade)), outlier.shape = NA, position = position_dodge(width = 0.75)) +  # Boxplots dodge by group
  geom_point(size = 0.5, alpha = 0.5) +
  geom_line(aes(group = interaction(patient_id, ctcae_grade)), color = "grey", alpha = 0.25) +
  geom_smooth(aes(group = ctcae_grade, color = ctcae_grade), method = "lm", se = FALSE, linetype = "dashed") +
  facet_wrap(~ sort, ncol = 2) +
  labs(x = "Visit Information", y = "Percent of parent (logit)", color = "CTCAE grade") +
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        strip.text = element_text(size = 12)) +
  scale_color_manual(values = c("0" = "#440154FF", "1" = "#31688EFF", "2" = "#35B779FF", "3" = "#FDE725FF"))

p

#ggsave("../figures/mixed_modeling_hits.png", plot = p, width = 8, height = 5)

```

# Prepare for ICA on baseline data (logit transform)

```{r}

# Transform data (logit) to be more normally distributed

logit_baseline_flow_data <- baseline_flow_data %>%
  mutate(logit_freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, cleaned_visit_num, freq)) %>%
  pivot_wider(names_from = sort, values_from = logit_freq) %>%
  drop_na(-c(group, patient_id, irae_ex, irae_severity_category, pneumonitis, thyroid_irae, skin_irae, Batch, age, radiation, chemoradiation, intravesicular_bcg, intravesicular_chemo)) %>%
  select(-c(patient_id, group, specific_group, irae_ex, irae_severity_category, pneumonitis, thyroid_irae, skin_irae, Batch, age, radiation, chemoradiation, intravesicular_bcg, intravesicular_chemo))

logit_baseline_flow_data

logit_baseline_flow_data_metadata <- baseline_flow_data %>%
  mutate(logit_freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, cleaned_visit_num, freq)) %>%
  pivot_wider(names_from = sort, values_from = logit_freq) %>%
  drop_na(-c(group, patient_id, irae_ex, irae_severity_category, pneumonitis, thyroid_irae, skin_irae, Batch, age, radiation, chemoradiation, intravesicular_bcg, intravesicular_chemo)) %>%
  select(c(patient_id, group, specific_group, irae_ex, irae_severity_category, pneumonitis, thyroid_irae, skin_irae, Batch, age, radiation, chemoradiation, intravesicular_bcg, intravesicular_chemo)) %>%
  mutate(patient_id_simple = row_number())

logit_baseline_flow_data_metadata

```

# Find optimal number of components for ICA

```{r}

library(ggplot2);theme_set(theme_bw(20) + theme(panel.grid.major = element_blank(),
                                                panel.grid.minor = element_blank(),
                                                panel.border = element_rect(colour="black", fill=NA, size=1),
                                                axis.text=element_text(colour="black"),
                                                axis.ticks=element_line(colour="black"))+
                             theme(legend.key = element_blank()))

# below is how to infer the appropriate number of components in ICA

### Show example of one splitting iteration
# Split the features into 2 ~equal sets
## Set seed for reproducibility
feats1 <- sample(colnames(logit_baseline_flow_data),round(ncol(logit_baseline_flow_data)/2) )
feats2 <- colnames(logit_baseline_flow_data)[!colnames(logit_baseline_flow_data) %in% feats1]
print( paste0("Num features: ", length(feats1), ", ", length(feats2)) )

# Generate 2 ICA models with the split genes with 8 components
ncomps <- 8
ica1 <- icafast(logit_baseline_flow_data[,feats1], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
print(paste0("Sample ICA Weight Matrix Dimensions: ", nrow(ica1$S)," by ", ncol(ica1$S)) )
ica2 <- icafast(logit_baseline_flow_data[,feats2], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)

## Correlate the components together
cormat <- cor(ica1$S, ica2$S,method="spearman")
rowMaxes <- apply(abs(cormat),1,max)
rownames(cormat) <- as.character( signif(rowMaxes,3))
Heatmap(abs(cormat), name="Pearson\nCorrelation",column_title="Pairwise Correlations Between Split ICA Models")
# Get the worst best correlation
minMaxR <- min( apply(abs(cormat),1,max) )
print( paste0("Worst best component correlation: ",minMaxR) )

## Function to compute worst best component correlation for a sequence of component numbers
getSplitMinMaxR <- function(nCompsSequence, data.tmp=logit_baseline_flow_data){ # get the minimum spearman correlation between the ICA components from the two splits
  
  # Split the features into 2 equal sets
  feats1 <- sample(colnames(logit_baseline_flow_data),round(ncol(logit_baseline_flow_data)/2) )
  feats2 <- colnames(logit_baseline_flow_data)[!colnames(logit_baseline_flow_data) %in% feats1]
  
  getMinMaxR <- function(ncomps){
    print(ncomps)
    ica1 <- icafast(logit_baseline_flow_data[,feats1], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
    ica2 <- icafast(logit_baseline_flow_data[,feats2], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
    cormat <- cor(ica1$S, ica2$S,method="spearman")
    vals <- c( minMaxR = min( apply(abs(cormat),2,max)), ncomps=ncomps )
  }
  
  minMaxRs <- data.frame( t(sapply( nCompsSequence, getMinMaxR)) )
  return(minMaxRs)
}

# Do two splits
nCompsSequence <- 2:15
numShuffles <- 2
minMaxRs <- lapply(1:numShuffles, function(i) getSplitMinMaxR(nCompsSequence, logit_baseline_flow_data) )
for( i in 1:length(minMaxRs) ){
  minMaxRs[[i]]$shuffleNumber <- i
}
print("Min Max Rs: ")
print(minMaxRs)
numShuffles <- length(minMaxRs)

getCorDiffs <- function( minMaxR ){
  corDiffs <- minMaxR$minMaxR[2:nrow(minMaxR)] - minMaxR$minMaxR[1:(nrow(minMaxR)-1) ]
  biggestDecline <- minMaxR$ncomps[ which( corDiffs == min(corDiffs)) ]
  print( paste0("Biggest Correlation Decline: ", biggestDecline, " to ", biggestDecline+1 ) )
  return(biggestDecline)
}

biggestDeclines <- sapply(minMaxRs,getCorDiffs)
biggestDeclineTab <- table(biggestDeclines)
ggplot() + geom_histogram( aes(x=biggestDeclines)) + labs(x="# of components before the largest decline")
optimalCompNum <- as.numeric( names(biggestDeclineTab)[biggestDeclineTab==max(biggestDeclineTab)] )
print(optimalCompNum)

## Make boxplot of results of correlations for all 50 subsamples
minMaxRsLong <- do.call(rbind,minMaxRs)
ggplot(minMaxRsLong,aes(x=ncomps,y=minMaxR)) + geom_boxplot(aes(group=ncomps)) + geom_line(aes(group=shuffleNumber), alpha=0.1,color="red") + labs(x="number of ICA components",y="Lowest Component\nSpearman Correlation",title=paste0( numShuffles," Feature 2-Way Splits\nMinMax Component Correlation")) + geom_vline(xintercept = optimalCompNum, linetype="dashed",color="blue")

```

# Run ICA with optimal num of components

```{r}

optimalCompNum <- 8  # or set to your identified number of components
ica_model <- icafast(logit_baseline_flow_data, optimalCompNum, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(optimalCompNum), alg = "par", fun = "logcosh", alpha = 1)

# Extract the ICA components
ica_components <- ica_model$S

logit_baseline_flow_data_metadata$patient_id_simple <- as.character(logit_baseline_flow_data_metadata$patient_id_simple)

# Create a data frame with the first 2 or 3 components for visualization
ica_df <- data.frame(Comp1 = ica_components[,1], Comp2 = ica_components[,2], patient_id_simple = as.character(rownames(logit_baseline_flow_data))) %>%
  left_join(logit_baseline_flow_data_metadata, by = "patient_id_simple")

# Plot the first 2 components
ggplot(ica_df, aes(x=Comp1, y=Comp2)) +
  geom_point(aes(color=group), size=2) + 
  labs(x="ICA Component 1", y="ICA Component 2")

```

# Try regressing out confounders in baseline data

```{r}

# lose some features because of NA (don't drop patients, drop features) due to 0 freq in parent

regressing_out_confounders_df <- baseline_flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, cleaned_visit_num, irae_severity_based_on_ctcae)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  # don't drop NA rows, instead remove features (cols) with an NA
  mutate(Batch = as.factor(Batch),
         age = as.factor(age)) %>%
  dplyr::filter(!(is.na(patient_id)))

regressing_out_confounders_df

metadata_cols <- regressing_out_confounders_df[, 1:9]
feature_cols <- regressing_out_confounders_df[, 10:ncol(regressing_out_confounders_df)] %>%
  # Z-score normalize across patients for each feature
  mutate(across(where(is.numeric), ~ scale(.)))

# remove 14/71 features with NAs instead of removing the patients
na_count_per_feature <- colSums(is.na(feature_cols))
feature_cols_filtered <- feature_cols[, na_count_per_feature == 0]

# Function to regress out confounders (batch) for each feature
regress_out_confounders <- function(feature, batch) {
  # Build the linear model and get residuals
  model <- lm(feature ~ batch)
  residuals(model)
}

adjusted_features <- as.data.frame(lapply(feature_cols_filtered, 
                                          regress_out_confounders, 
                                          batch = regressing_out_confounders_df$Batch))

adjusted_data <- cbind(metadata_cols, adjusted_features)

```

# Try module approach from "top" features

```{r}

wide_baseline_flow_data_confounders_regressed_out <- adjusted_data %>%
  mutate(group = case_when(
    group == "Healthy_Control" ~ "HC",
    group == "AID_Patient" ~ "AID",
    TRUE ~ group
  ),
  age = as.numeric(as.character(age)),
  subgroup = case_when(
    group == "AID" & specific_group == "Type 1 Diabetes" ~ "T1D",
    group == "AID" & specific_group == "RA" ~ "RA",
    group == "AID" & str_detect(specific_group, "Ulcer") ~ "Gut",
    group %in% c("non-irAE", "irAE/SAE") & specific_group %in% c("Renal Cancer, Bladder Cancer", "Bladder Cancer") ~ "Bladder/\nrenal\ncancer",
    group %in% c("non-irAE", "irAE/SAE") & specific_group %in% c("Urinary Tract Cancer", "Urethral Cancer") ~ "Urinary\ntract/\nurethral\ncancer",
    group %in% c("non-irAE", "irAE/SAE") & specific_group %in% c("Lung Disease, Lung Cancer", "Lung Cancer") ~ "Lung\ncancer/\ndisease",
    group %in% c("non-irAE", "irAE/SAE") & specific_group == "Head and Neck Cancer, Lung Cancer" ~ "Head\nand\nneck/\nlung\ncancer",
    group %in% c("non-irAE", "irAE/SAE") & specific_group == "Head and Neck Cancer" ~ "Head\nand\nneck\ncancer",
    group %in% c("non-irAE", "irAE/SAE") & specific_group == "Gastric Cancer" ~ "Gastric\ncancer",
    TRUE ~ specific_group
  )) %>%
  dplyr::filter((group %in% c("non-irAE", "irAE/SAE"))) %>%
  select("patient_id", "group", "unswMem.of.Bcells", "CM.of.Tconv.Tcells", "PD1pos.of.CM.Tconv.Tcells", "CCR6pos.of.NN.Tconv.Tcells", "DN.of.Bcells", "pDC.of.nonGrans") %>%
  rowwise() %>%
  mutate(mean_value = mean(c_across(starts_with("unswMem.of.Bcells"):last_col()), na.rm = TRUE)) %>%
  ungroup() %>%
  select(patient_id, group, mean_value)

wide_baseline_flow_data_confounders_regressed_out

wide_baseline_flow_data_confounders_regressed_out %>%
  summarize(
    # Perform Shapiro-Wilk test for normality in each group
    shapiro_non_irae = shapiro.test(mean_value[group == "non-irAE"])$p.value,
    shapiro_irae = shapiro.test(mean_value[group == "irAE/SAE"])$p.value,
    
    # Choose between t-test and Wilcoxon test based on normality
    pval = ifelse(
      shapiro_non_irae > 0.05 & shapiro_irae > 0.05,
      t.test(mean_value[group == "non-irAE"], 
             mean_value[group == "irAE/SAE"], 
             paired = FALSE)$p.value,
      wilcox.test(mean_value[group == "non-irAE"], 
                  mean_value[group == "irAE/SAE"], 
                  paired = FALSE, exact = FALSE)$p.value
    )
  ) %>%
  print()

ggplot(wide_baseline_flow_data_confounders_regressed_out, aes(x = group, y = mean_value, color = group)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.6) +
  labs(y = "Top feature module score", x = "")

```

# Plot PCA results for baseline data with batch (+/- age) regressed out

```{r}

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:9] %>%
  mutate(patient_id_simple = row_number()) %>%
  mutate(group = case_when(
    group == "Healthy_Control" ~ "HC",
    group == "AID_Patient" ~ "AID",
    TRUE ~ group
  ),
  age = as.numeric(as.character(age)),
  subgroup = case_when(
    group == "AID" & specific_group == "Type 1 Diabetes" ~ "T1D",
    group == "AID" & specific_group == "RA" ~ "RA",
    group == "AID" & str_detect(specific_group, "Ulcer") ~ "Gut",
    group %in% c("non-irAE", "irAE/SAE") & specific_group %in% c("Renal Cancer, Bladder Cancer", "Bladder Cancer") ~ "Bladder/\nrenal\ncancer",
    group %in% c("non-irAE", "irAE/SAE") & specific_group %in% c("Urinary Tract Cancer", "Urethral Cancer") ~ "Urinary\ntract/\nurethral\ncancer",
    group %in% c("non-irAE", "irAE/SAE") & specific_group %in% c("Lung Disease, Lung Cancer", "Lung Cancer") ~ "Lung\ncancer/\ndisease",
    group %in% c("non-irAE", "irAE/SAE") & specific_group == "Head and Neck Cancer, Lung Cancer" ~ "Head\nand\nneck/\nlung\ncancer",
    group %in% c("non-irAE", "irAE/SAE") & specific_group == "Head and Neck Cancer" ~ "Head\nand\nneck\ncancer",
    group %in% c("non-irAE", "irAE/SAE") & specific_group == "Gastric Cancer" ~ "Gastric\ncancer",
    TRUE ~ specific_group
  )) %>%
 dplyr::filter((group %in% c("non-irAE", "irAE/SAE")))

wide_baseline_flow_num_data_confounders_regressed_out <- adjusted_data[, 10:ncol(adjusted_data)] #%>% select("unswMem.of.Bcells", "CM.of.Tconv.Tcells", "PD1pos.of.CM.Tconv.Tcells", "CCR6pos.of.NN.Tconv.Tcells", "DN.of.Bcells", "pDC.of.nonGrans")

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores= as.data.frame(pca$x)

pcaScores

pcaScores$patient_id_simple = row.names(pcaScores)

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1 <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1) %>%
    head(10)

top_contributing_features_PC2 <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2) %>%
    head(10)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = group), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = group), size = 1, linetype = 2) +
  #scale_color_manual(values = c("HC" = "purple", "AID" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  #scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = median(pcaData$age, na.rm = TRUE), limits = c(min(pcaData$age), max(pcaData$age))) +  # Blue-White-Red gradient with median age as white
  xlim(-limits[1], limits[1]) +
  ylim(-limits[2], limits[2]) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

#ggsave("../figures/baseline_pca_aid_subgroup_batch_regressed_out.png", plot = p, width = 3.5, height = 3.5)
#ggsave("../figures/baseline_pca_irae_groups_all_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)
#ggsave("../figures/baseline_pca_age_age_and_batch_regressed_out.png", plot = p, width = 3, height = 3.5)
#ggsave("../figures/baseline_pca_age_batch_regressed_out.png", plot = p, width = 3, height = 3.5)
#ggsave("../figures/baseline_pca_cancer_type_batch_regressed_out.png", plot = p, width = 3.5, height = 3.5)
#ggsave("../figures/baseline_pca_aid_subgroup_age_and_batch_regressed_out.png", plot = p, width = 3, height = 3.5)
#ggsave("../figures/baseline_pca_general_group_batch_regressed_out.png", plot = p, width = 3, height = 3.5)
#ggsave("../figures/baseline_pca_batch_batch_regressed_out.png", plot = p, width = 3.5, height = 3.5)

```

# Determine clusters in PCA space, then test for enrichment of study groups in clusters

```{r}

# Elbow method to determine optimal number of clusters
set.seed(123)
wss <- sapply(1:10, function(k) {
  kmeans(pcaData[, c("PC1", "PC2", "PC3")], centers = k, nstart = 25)$tot.withinss
})

# Plot the Elbow curve
plot(1:10, wss, type = "b", pch = 19, frame = FALSE, xlab = "Number of clusters", ylab = "Total within-cluster sum of squares")

kmeans_result <- kmeans(pcaData[, c("PC1", "PC2", "PC3")], centers = 6, nstart = 25)

# Add cluster assignments to the data
pcaData$cluster <- factor(kmeans_result$cluster)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = cluster), size = 2, alpha = 0.8) +  # Color by cluster
  labs(color = "Cluster") +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

table_result <- table(pcaData$cluster, pcaData$group)

chisq_test <- chisq.test(table_result)

fisher_test <- fisher.test(table_result)

```

# Plot cancer baseline data on AID PCA

```{r}

cancer_data <- adjusted_data %>% 
  filter(group %in% c("non-irAE", "irAE/SAE")) %>% 
  select(10:ncol(adjusted_data))

cancer_metadata <- adjusted_data %>% 
  filter(group %in% c("non-irAE", "irAE/SAE")) %>% 
  select(1:9)

# Scale and center cancer data to match the original PCA scaling
cancer_projected_scores <- as.data.frame(scale(cancer_data, center = pca$center, scale = pca$scale) %*% pca$rotation)
cancer_projected_scores$patient_id_simple <- row.names(cancer_projected_scores)
cancer_projected_scores$group <- cancer_metadata$group

ggplot(data = cancer_projected_scores) +
  geom_hline(yintercept = 0, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = group), size = 2, alpha = 0.8) + 
  xlim(-limits[1], limits[1]) +
  ylim(-limits[2], limits[2]) +
  labs(color = "", shape = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),
    legend.spacing.y = unit(0.1, 'cm'), 
    legend.spacing.x = unit(0.3, 'cm')
  ) +
  guides(color = guide_legend(nrow = 2, byrow = TRUE)) +
  labs(x = pcaLabels[[1]][1], y = pcaLabels[[1]][2])

```

# Make VP of changes between irAE and no irAE groups

```{r}

df <- adjusted_data

irae_group <- df %>% dplyr::filter(group == "irAE/SAE")
no_irae_group <- df %>% dplyr::filter(group == "non-irAE")

non_feature_cols <- c("patient_id", "group", "specific_group", "irae_ex", "Batch", 
                      "age", "ctcae_grade", "thyroid_irae", "skin_irae")
feature_columns <- setdiff(colnames(df), non_feature_cols)

# Calculate mean residuals for each feature
irae_means <- (irae_group %>% select(all_of(feature_columns)) %>% summarise_all(mean))
no_irae_means <- no_irae_group %>% select(all_of(feature_columns)) %>% summarise_all(mean)

abs_diff <- (as.numeric(irae_means) - as.numeric(no_irae_means))
#log2_fc <- sign(fc) * log2(abs(fc))

pvals <- sapply(feature_columns, function(feature) {
  wilcox.test(irae_group[[feature]], no_irae_group[[feature]])$p.value
})

padj <- p.adjust(pvals, method = "BH")

volcano_df <- data.frame(
  feature = feature_columns,
  abs_diff = abs_diff,
  padj = padj,
  neg_log10_padj = -log10(padj)
)

ggplot(volcano_df, aes(x = abs_diff, y = neg_log10_padj)) +
  geom_point(aes(color = padj < 0.1)) +
  theme_minimal() +
  labs(x = "irAE/SAE vs. no irAE (absolute difference in mean of residuals)", y = "-log10(padj)") +
  geom_vline(xintercept = 0, linetype = "dashed") + # Vertical line at 0 fold change +
  geom_hline(yintercept = -log10(0.1), linetype = "dashed") + # horizontal line at sig threshold
  geom_text_repel(data = subset(volcano_df, padj < 0.35), 
                  aes(label = feature), size = 3, box.padding = 0.5, max.overlaps = 10)

```

# Make a boxplot for features of interest after regressing out batch

```{r}

# features of interest from literature
# DN of Bcells"                    "CD8 of Tcells"                   "CD38hiCD127neg of NN CD8 Tcells"

plot_data <- adjusted_data %>% select(group, DN.of.Bcells, CD8.of.Tcells, CD38hiCD127neg.of.NN.CD8.Tcells) %>%
  pivot_longer(cols = c(DN.of.Bcells, CD8.of.Tcells, CD38hiCD127neg.of.NN.CD8.Tcells), names_to = "sort", values_to = "freq") %>%
  mutate(sort = case_when(
    sort == "CD8.of.Tcells" ~ "CD8 of Tcells",
    sort == "CD38hiCD127neg.of.NN.CD8.Tcells" ~ "CD38hiCD127-\nof NN CD8s",
    sort == "DN.of.Bcells" ~ "DN of Bcells"
  ))

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~ sort, ncol = 3) +
  geom_jitter(color = "grey", size = 0.5) +
  labs(x = "", y = "Residuals (batch\nregressed out)") +
  scale_fill_manual(values = c("Healthy_Control" = "purple", "AID_Patient" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

ggsave("../figures/batch_regressed_out_residuals_by_feature_hits.png", plot = p, width = 7, height = 3.5)

```

# Re-do stats old way after regressing out batch to resolve discrepancy b/w methods

```{r}

# Define feature columns
feature_columns <- colnames(adjusted_data)[!(colnames(adjusted_data) %in% non_feature_cols)]

# Filter groups
irae_group <- adjusted_data %>% filter(group == "irAE/SAE")
non_irae_group <- adjusted_data %>% filter(group == "non-irAE")

# Initialize lists for p-values and test types used
pvals <- c()
test_type <- c()

# Loop over features and decide on test based on normality
for (feature in feature_columns) {
  # Perform Shapiro-Wilk test for normality
  shapiro_irae <- shapiro.test(irae_group[[feature]])$p.value
  shapiro_non_irae <- shapiro.test(non_irae_group[[feature]])$p.value
  
  # If both groups are normally distributed (p > 0.05), use t-test
  if (shapiro_irae > 0.05 & shapiro_non_irae > 0.05) {
    pval <- t.test(irae_group[[feature]], non_irae_group[[feature]], paired = FALSE)$p.value
    test_type <- c(test_type, "t-test")
  } else {
    # Otherwise, use Wilcoxon test
    pval <- wilcox.test(irae_group[[feature]], non_irae_group[[feature]], paired = FALSE, exact = FALSE)$p.value
    test_type <- c(test_type, "wilcox")
  }
  
  pvals <- c(pvals, pval)
}

# Adjust p-values using BH method
padj <- p.adjust(pvals, method = "BH")

# Create results data frame with the test type
stats_test <- data.frame(
  feature = feature_columns,
  pval = pvals,
  adj_pval = padj,
  test_type = test_type
) %>% arrange(adj_pval)

stats_test

```

# Find features associating with age in HC/AID groups (to see if those who develop irAEs have older immunotypes)

```{r}

non_cancer_data <- adjusted_data %>%
  mutate(age = as.numeric(as.character(age))) %>%
  filter(group %in% c("AID_Patient", "Healthy_Control"))

immune_features <- non_cancer_data[, 10:ncol(non_cancer_data)]

correlation_results <- immune_features %>%
  summarise(across(everything(), ~ cor.test(.x, non_cancer_data$age, method = "spearman")$estimate)) %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "correlation")

p_values <- immune_features %>%
  summarise(across(everything(), ~ cor.test(.x, non_cancer_data$age, method = "spearman")$p.value)) %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "p_value")

correlation_summary <- left_join(correlation_results, p_values, by = "feature") %>%
  mutate(padj = p.adjust(p_value, method = "BH")) %>%
  arrange(padj) %>%
  filter(padj < 0.05)

correlation_summary

ggplot(non_cancer_data, aes(x = age, y = naive.of.CD8.Tcells, color = group)) +
  geom_point(alpha = 0.6) +  # Scatter points
  geom_smooth(method = "lm", color = "black", se = FALSE)

```

# Use LMs from non-cancer group (with age as factor) on cancer data to predict immunotype scores for features associating with age in non-cancer group

```{r}

# Fit a linear model for each age-correlated feature
models <- lapply(correlation_summary$feature, function(feature) {
  lm(as.formula(paste(feature, "~ age")), data = non_cancer_data)
})
names(models) <- correlation_summary$feature  # Name each model with its corresponding feature

models

cancer_data <- adjusted_data %>%
  mutate(age = as.numeric(as.character(age))) %>%
  filter(!(group %in% c("AID_Patient", "Healthy_Control")))

predict_immunotype_score <- function(model, age) {
  intercept <- coef(model)[1]
  slope <- coef(model)[2]
  return(intercept + slope * age)
}

predicted_scores <- data.frame(patient_id = cancer_data$patient_id)

# Loop through each model and predict scores for cancer patients
for (feature in names(models)) {
  predicted_scores[[feature]] <- sapply(cancer_data$age, function(age) predict_immunotype_score(models[[feature]], age))
}

# Rename the scores column to a more descriptive name
colnames(predicted_scores)[-1] <- paste0("immunotype_age_score_", names(models))

predicted_scores_with_metadata <- left_join(cancer_data %>% select(patient_id, group), predicted_scores, by = "patient_id")

predicted_scores_with_metadata

# Reshape data to long format for ggplot
predicted_scores_with_metadata_long <- predicted_scores_with_metadata %>%
  pivot_longer(cols = starts_with("immunotype_age_score"), 
               names_to = "immunotype", 
               values_to = "score") %>%
  mutate(immunotype = gsub("immunotype_age_score_", "", immunotype))

ggplot(predicted_scores_with_metadata_long, aes(x = immunotype, y = score, color = group)) +
  geom_point(position = position_jitter(width = 0.2), size = 1) +  # Add jitter for better visibility
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  labs(x = "", y = "Predicted score based\non HC/AID data")

```