---
title: "CyTOF analyses for NCI irAE project"
output: pdf_document
---
 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load necessary libraries

```{r}

library(beeswarm)
library(Matrix)
library(ggplot2)
library(stringr)
library(scales)
library(tidyr)
library(ComplexHeatmap)
library(viridis)
library(readxl)
library(circlize)
library(Seurat)
library(factoextra)
library(lmerTest)
library(gtsummary)
library(ica)
library(CytoExploreR)
library(dplyr)
library(ggrepel)
library(purrr)

```

# Set theme

```{r}

theme_set(
  theme_bw(20) +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_rect(colour="black", fill = NA, size = 1),
          axis.text = element_text(colour="black"),
          axis.ticks = element_line(colour="black"),
          axis.text.x = element_text(angle=0),
          legend.title = element_text(size = 10),
          legend.text = element_text(size = 7)))

```

# Read in baseline data to look at group differences
 - may want to work with dates later, use as.Date(date, origin = "1899-12-30")

```{r}

baseline_flow_data <- read_excel("../raw_data/2024_10_17_flow_data.xlsx") %>%
  rename(thyroid_cat = `Thyroid Category (JB)`) %>%
  mutate(`Infusion date` = as.Date(as.numeric(`Infusion date`), origin = "1899-12-30"),
         `First irAE Onset or Thyroid Test Date` = as.Date(as.numeric(`First irAE Onset or Thyroid Test Date`), origin = "1899-12-30"),
         days_to_irae = as.numeric(difftime(`First irAE Onset or Thyroid Test Date`, `Infusion date`, units = "days"))) %>%
  # subset for only baseline visits
  mutate(cleaned_visit_num = str_extract(`Visit Descriptor`, "\\d+")) %>%
  # CTCAE Grade (Highest) is the column for (ir)AE grade
  rename(patient_id = `Subject ID`, ctcae_grade = `CTCAE Grade (Highest)`, group = `General irAE Classification`, specific_group = `Patient Type`, age = `Age at Draw`, irae_ex = `irAE Documented (if any)`) %>%
  # if CTCAE grade is not-NA, group should be irAE... (some grade 1-2 ctcae were in non-irAE group before using updated category 9/6/24, using `General irAE Classification` as its cleaner metadata though otherwise
  mutate(group = if_else(!is.na(ctcae_grade), "irAE/SAE", group)) %>%
  dplyr::filter(cleaned_visit_num == 1 | is.na(cleaned_visit_num) & group %in% c("AID_Patient", "Healthy_Control")) %>%
  select(patient_id, group, ctcae_grade, specific_group, cleaned_visit_num, Batch, age, irae_ex, days_to_irae, thyroid_cat, starts_with("pct_")) %>%
  pivot_longer(
    cols = starts_with("pct_"), 
    names_to = "sort",
    values_to = "freq") %>%
  mutate(parent_population = gsub(".*_of_", "", sort),
         parent_population = gsub("_", " ", parent_population),
         parent_parent_population = str_extract(parent_population, "[^ ]+$"),
         sort = gsub("pct_", "", sort),
         sort = gsub("_", " ", sort)
  ) %>%
  dplyr::filter(freq > 0) %>%
  dplyr::filter(!(sort %in% c("granulocytes of live", "PD1pos of DN Bcells", "PD1pos of naive Bcells", "PD1pos of swMem Bcells", "PD1pos of unswMem Bcells", "basophils of nonGrans", "EMRA of Tconv Tcells", "CXCR6pos of NN CD8 Tcells", "CXCR6posGrzmBpos of NN CD8 Tcells"))) %>%
  mutate(irae_severity_based_on_ctcae = case_when(
    group == "irAE/SAE" & ctcae_grade > 2 ~ "Serious irAE/SAE",
    group == "irAE/SAE" & ctcae_grade < 3 ~ "Non-serious irAE/SAE",
    group == "non-irAE" ~ "Non-irAE",
    TRUE ~ NA),
    irae_ex = if_else(is.na(irae_ex), "None", irae_ex),
    thyroid_cat = if_else(is.na(thyroid_cat), "None", thyroid_cat),
    thyroid_irae_including_oor = if_else(str_detect(irae_ex, regex("thyroid", ignore_case = TRUE)) | str_detect(thyroid_cat, regex("Abnormal", ignore_case = TRUE)),
                                "Thyroid irAE", 
                                "No thyroid irAE"),
    thyroid_irae = if_else(str_detect(irae_ex, regex("thyroid", ignore_case = TRUE)),
                                "Thyroid irAE", 
                                "No thyroid irAE"),
    skin_irae = if_else(str_detect(irae_ex, regex("rash|Rash|Pruritus", ignore_case = TRUE)),
                                "Skin irAE", 
                                "No skin irAE"))
    
# only 2 patients with serious (grade > 2) irAEs

baseline_flow_data

```

# Define logit transform func

```{r}

logitNorm <- function(v){
  newVals <- v
  # Check to see if it's 0 to 1 or 0 to 100, and then switch it to 0 to 1
  if( any(v>1) & all(v<=100) ){
    newVals <- v/100
  }
  # if there are 0s or 1s, add/subtract a small value
  # so the logit norm is defined
  epsilon <- min(newVals[newVals!=0])/2
  newVals[newVals==0] <- epsilon
  newVals[newVals==1] <- 1-epsilon
  # Do the logit norm
  newVals <- log2(newVals/(1-newVals))
  if( any(is.na(newVals))){
    print(head(data.frame(v,newVals)))
  }
  return(newVals)
}

```

# Look at DP (feature lost in regressing out covars)

```{r}

plot_data <- baseline_flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  dplyr::filter(sort == "DP of Tcells")

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  #facet_wrap(~ sort, ncol = 3) +
  geom_jitter(color = "grey", size = 0.5) +
  labs(x = "", y = "DP of Tcells freq (logit-\ntransformed % of parent)") +
  scale_fill_manual(values = c("Healthy_Control" = "purple", "AID_Patient" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

```

# Try mixed effects modeling (linear first, then GAMs if nonlinear) like in https://www.biorxiv.org/content/10.1101/2022.06.05.494592v1.full.pdf from longitudinal data

 - need to reduce correlating variables? group and visit likely don't correlate so no worries

```{r}

mixed_effects_model_df <- read_excel("../raw_data/2024_10_17_flow_data.xlsx") %>%
  mutate(cleaned_visit_num = str_extract(`Visit Descriptor`, "\\d+")) %>%
  # CTCAE Grade (Highest) is the column for (ir)AE grade
  rename(patient_id = `Subject ID`, ctcae_grade = `CTCAE Grade (Highest)`, group = `General irAE Classification`, specific_group = `Patient Type`, age = `Age at Draw`, visit_info = `Visit Descriptor`) %>%
  # if CTCAE grade is not-NA, group should be irAE... (some grade 1-2 ctcae were in non-irAE group before using updated category 9/6/24, using `General irAE Classification` as its cleaner metadata though otherwise
  mutate(group = if_else(!is.na(ctcae_grade), "irAE/SAE", group)) %>%
  mutate(irae_severity_based_on_ctcae = case_when(
    group == "irAE/SAE" & ctcae_grade > 2 ~ "Serious irAE/SAE",
    group == "irAE/SAE" & ctcae_grade < 3 ~ "Non-serious irAE/SAE",
    group == "non-irAE" ~ "Non-irAE",
    TRUE ~ NA
  )) %>%
  select(patient_id, group, specific_group, irae_severity_based_on_ctcae, visit_info, ctcae_grade, Batch, starts_with("pct_")) %>%
  pivot_longer(
    cols = starts_with("pct_"), 
    names_to = "sort",
    values_to = "freq") %>%
  mutate(parent_population = gsub(".*_of_", "", sort),
         parent_population = gsub("_", " ", parent_population),
         parent_parent_population = str_extract(parent_population, "[^ ]+$"),
         sort = gsub("pct_", "", sort),
         sort = gsub("_", " ", sort)
  ) %>%
  mutate(visit_info = case_when(
          str_detect(visit_info, "1") | visit_info %in% c("AID_Patient", "Healthy_Control") ~ 1,
          visit_info %in% c("other", "Other") ~ 6,
          visit_info %in% c("Visit 2", "Visit 2, irAE") ~ 2,
          visit_info %in% c("Visit 3", "Visit 3, irAE", "Visit 3, irAE F/U") ~ 3,
          visit_info != "irAE F/U" & str_detect(visit_info, "irAE") ~ 4,
          visit_info == "irAE F/U" ~ 5
    )) %>%
  filter(!(sort %in% c("granulocytes of live", "PD1pos of DN Bcells", "PD1pos of naive Bcells", "PD1pos of swMem Bcells", "PD1pos of unswMem Bcells", "basophils of nonGrans", "EMRA of Tconv Tcells", "CXCR6pos of NN CD8 Tcells", "CXCR6posGrzmBpos of NN CD8 Tcells")),
         !str_detect(sort, "PD")) %>%
  filter(freq > 0,
         visit_info != 6) %>%
  # getting rid of any sorts with any NA freqs gets rid of some sorts
  mutate(freq = logitNorm(freq)) %>%
  filter(!(is.na(patient_id))) %>%
  # give ctcae grade of 0 for HC, AID, non-irAE
  mutate(ctcae_grade = if_else(is.na(ctcae_grade), 0, ctcae_grade)) %>%
  # filter for cancer patients if doing CTCAE-grade based approach (want 0 score ref to only be cancer patients)
  filter(group %in% c("non-irAE", "irAE/SAE"))

unique(mixed_effects_model_df$visit_info)

visit_levels <- c(1, 2, 3, 4, 5)
ctcae_levels <- c(0, 1, 2, 3)
#group_levels <- c("non-irAE", "irAE/SAE", "Healthy_Control", "AID_Patient")

mixed_effects_model_df$visit_info <- factor(mixed_effects_model_df$visit_info, levels = visit_levels)
#mixed_effects_model_df$group <- factor(mixed_effects_model_df$group, levels = group_levels)
mixed_effects_model_df$ctcae_grade <- factor(mixed_effects_model_df$ctcae_grade, levels = ctcae_levels)

# mixed effects model, allow for variation between subjects in ref, 1|patient_id doesn't account for variation b/w subjects in response but group*time does (variation between irAE groups in response to ICI over time)

sorts <- unique(mixed_effects_model_df$sort)

results <- list()
residuals_combined <- list()

library(broom.mixed)

for (s in sorts) {
  subset_data <- mixed_effects_model_df %>% filter(sort == s)
  
  # Get unique combinations of patient_id and visit_info to combine as metadata w/ residuals df
  unique_combinations <- subset_data %>%
    select(patient_id, visit_info, ctcae_grade)
  
  # Fit the mixed-effects model
  fit <- lmer(freq ~ visit_info*ctcae_grade + Batch + (1 | patient_id), data = subset_data)
  # visit_info + visit_info:ctcae_grade to allow ctcae_grade as main effect (for baseline temporally stable effects)
  # visit_info*ctcae_grade otherwise
  
  # Extract residuals
  residuals_data <- residuals(fit)
  
  # Combine residuals with unique_combinations
  residuals_df <- cbind(unique_combinations, residuals = residuals_data)
  
  # Store in the list
  residuals_combined[[s]] <- residuals_df
  
  # Capture the model summary using broom.mixed
  model_summary <- tidy(fit, effects = "fixed")
  
  # Store the summary in the results list
  results[[s]] <- model_summary
}

combined_residuals_df <- bind_rows(lapply(names(residuals_combined), function(s) {
  residuals_combined[[s]] %>%
    mutate(sort = s)

}))

combined_results_df <- bind_rows(results, .id = "sort")

```

# Look for baseline effects subtracting group/time effects, observe 1 hit (SCM of Tconv Tcells)
 - for this, important to NOT include group in model specification, only visit_info, batch, and donorID

```{r}

combined_residuals_df %>%
  filter(visit_info == 1) %>%
  group_by(sort) %>%
  summarize(pval = wilcox.test(residuals[ctcae_grade == "0"], residuals[ctcae_grade %in% c("1", "2", "3")], paired = FALSE, exact = FALSE)$p.value) %>%
  mutate(adj_pval = p.adjust(pval, method = "BH")) %>%
  arrange(adj_pval) %>%
  print()

```

# Plot significant results from LM

```{r}

# CCR6pos of NN Tconv Tcells & swMem of Bcells for possible ctcae level effects, others for possible interaction effects

"yes vs. no irAE over time
CD56bright of NKcells"

p <- ggplot(mixed_effects_model_df %>% filter(sort %in% c("CCR6pos of NN Tconv Tcells", "swMem of Bcells")), aes(x = interaction(visit_info, ctcae_grade), y = (freq), color = ctcae_grade)) +
  geom_boxplot(aes(group = interaction(visit_info, ctcae_grade)), outlier.shape = NA, position = position_dodge(width = 0.75)) +  # Boxplots dodge by group
  geom_point(size = 0.5, alpha = 0.5) +
  geom_line(aes(group = interaction(patient_id, ctcae_grade)), color = "grey", alpha = 0.25) +
  geom_smooth(aes(group = ctcae_grade, color = ctcae_grade), method = "lm", se = FALSE, linetype = "dashed") +
  facet_wrap(~ sort, ncol = 2) +
  labs(x = "Visit Information", y = "Percent of parent (logit)", color = "CTCAE grade") +
  theme(axis.text.x = element_blank(),
        axis.title.x = element_blank(),
        strip.text = element_text(size = 12)) +
  scale_color_manual(values = c("0" = "#440154FF", "1" = "#31688EFF", "2" = "#35B779FF", "3" = "#FDE725FF"))

p

#ggsave("../figures/mixed_modeling_hits.png", plot = p, width = 8, height = 5)

```

# Regress out confounding batch in baseline data

```{r}

# lose some features because of NA (don't drop patients, drop features) due to 0 freq in parent

regressing_out_confounders_df <- baseline_flow_data %>%
  mutate(freq = logitNorm(freq)) %>%
  select(-c(parent_population, parent_parent_population, cleaned_visit_num, irae_severity_based_on_ctcae)) %>%
  pivot_wider(names_from = sort, values_from = freq) %>%
  # don't drop NA rows, instead remove features (cols) with an NA
  mutate(Batch = as.factor(Batch),
         age = as.factor(age)) %>%
  dplyr::filter(!(is.na(patient_id)))

metadata_cols <- regressing_out_confounders_df[, 1:12]
feature_cols <- regressing_out_confounders_df[, 13:ncol(regressing_out_confounders_df)] %>%
  # Z-score normalize across patients for each feature
  mutate(across(where(is.numeric), ~ scale(.)))

# remove 15/71 features with NAs
na_count_per_feature <- colSums(is.na(feature_cols))
feature_cols_filtered <- feature_cols[, na_count_per_feature == 0]

# Function to regress out confounders (batch) for each feature
regress_out_confounders <- function(feature, batch) {
  # Build the linear model and get residuals
  model <- lm(feature ~ batch)
  residuals(model)
}

adjusted_features <- as.data.frame(lapply(feature_cols_filtered, 
                                          regress_out_confounders, 
                                          batch = regressing_out_confounders_df$Batch))

adjusted_data <- cbind(metadata_cols, adjusted_features) %>%
  filter(group %in% c("irAE/SAE", "non-irAE"))

adjusted_data

```

# Re-do stats now with batch-corrected data

```{r}

stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, specific_group, Batch, age, irae_ex, thyroid_irae, thyroid_irae_including_oor, skin_irae, days_to_irae, thyroid_cat), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[group == "non-irAE"])$p.value > 0.05,
                       shapiro.test(value[group == "irAE/SAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ group)$p.value else wilcox.test(value ~ group)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  filter(pval < 0.1)

stats_df

```

# Try module approach from "top" features

```{r}

wide_baseline_flow_data_confounders_regressed_out <- adjusted_data %>%
  # take "top" features
  select("patient_id", "group", stats_df$sort) %>%
  rowwise() %>%
  mutate(mean_value = mean(c_across(starts_with("CCR6pos.of.NN.Tconv.Tcells"):last_col()), na.rm = TRUE)) %>%
  ungroup() %>%
  select(patient_id, group, mean_value)

wide_baseline_flow_data_confounders_regressed_out %>%
  summarize(
    # Perform Shapiro-Wilk test for normality in each group
    shapiro_non_irae = shapiro.test(mean_value[group == "non-irAE"])$p.value,
    shapiro_irae = shapiro.test(mean_value[group == "irAE/SAE"])$p.value,
    
    # Choose between t-test and Wilcoxon test based on normality
    pval = ifelse(
      shapiro_non_irae > 0.05 & shapiro_irae > 0.05,
      t.test(mean_value[group == "non-irAE"], 
             mean_value[group == "irAE/SAE"], 
             paired = FALSE)$p.value,
      wilcox.test(mean_value[group == "non-irAE"], 
                  mean_value[group == "irAE/SAE"], 
                  paired = FALSE, exact = FALSE)$p.value
    )
  ) %>%
  print()

ggplot(wide_baseline_flow_data_confounders_regressed_out, aes(x = group, y = mean_value, color = group)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.6) +
  labs(y = "Top features module score", x = "")

```

# Plot PCA results for baseline data with batch (+/- age) regressed out

```{r}

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:12] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- (adjusted_data)[, 13:ncol(adjusted_data)] %>% select(stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1 <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1) %>%
    head(10)

top_contributing_features_PC2 <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2) %>%
    head(10)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = group), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = group), size = 1, linetype = 2) +
  #scale_color_manual(values = c("HC" = "purple", "AID" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  #scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = median(pcaData$age, na.rm = TRUE), limits = c(min(pcaData$age), max(pcaData$age))) +  # Blue-White-Red gradient with median age as white
  #xlim(-limits[1], limits[1]) +
  #ylim(-limits[2], limits[2]) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      group = pcaData$group)
res <- compareGroups(group ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# using "top" features, PC1 pops out as differential:

p <- ggplot(pcaData, aes(x = group, y = PC1, color = group)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.6) +
  labs(y = "PC1", x = "")

p

ggsave("../figures/baseline_pc1_boxplot_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 5, height = 3.5)

```

# Plot PCA results for baseline data with batch (+/- age) regressed out, thyroid irAEs specifically

```{r}

thyroid_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, specific_group, Batch, age, irae_ex, thyroid_irae, thyroid_irae_including_oor, skin_irae, days_to_irae, thyroid_cat), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[thyroid_irae == "Thyroid irAE"])$p.value > 0.05,
                       shapiro.test(value[thyroid_irae == "No thyroid irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ group)$p.value else wilcox.test(value ~ group)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  filter(pval < 0.1)

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:12] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- (adjusted_data)[, 13:ncol(adjusted_data)] #%>% select(thyroid_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1 <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1) %>%
    head(10)

top_contributing_features_PC2 <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2) %>%
    head(10)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = thyroid_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = thyroid_irae), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_thyroid_irae_groups_all_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      thyroid_irae = pcaData$thyroid_irae)
res <- compareGroups(thyroid_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# using "top" features, PC1 pops out as differential:

p <- ggplot(pcaData, aes(x = thyroid_irae, y = PC1, color = thyroid_irae)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.6) +
  labs(y = "PC1", x = "")

p

ggsave("../figures/baseline_pc1_boxplot_thyroid_irae_groups_all_features_batch_regressed_out.png", plot = p, width = 5, height = 3.5)

```

# Plot PCA results for baseline data with batch (+/- age) regressed out, thyroid irAEs (including OOR) specifically

```{r}

thyroid_with_oor_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, specific_group, Batch, age, irae_ex, thyroid_irae, thyroid_irae_including_oor, skin_irae, days_to_irae, thyroid_cat), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[thyroid_irae_including_oor == "Thyroid irAE"])$p.value > 0.05,
                       shapiro.test(value[thyroid_irae_including_oor == "No thyroid irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ group)$p.value else wilcox.test(value ~ group)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  filter(pval < 0.1)

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:12] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- (adjusted_data)[, 13:ncol(adjusted_data)] %>% select(thyroid_with_oor_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1 <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1) %>%
    head(10)

top_contributing_features_PC2 <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2) %>%
    head(10)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = thyroid_irae_including_oor), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = thyroid_irae_including_oor), size = 1, linetype = 2) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_thyroid_irae_with_oor_groups_all_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      thyroid_irae_including_oor = pcaData$thyroid_irae_including_oor)
res <- compareGroups(thyroid_irae_including_oor ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# using "top" features, PC1 pops out as differential:

p <- ggplot(pcaData, aes(x = thyroid_irae_including_oor, y = PC1, color = thyroid_irae_including_oor)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.6) +
  labs(y = "PC1", x = "")

p

ggsave("../figures/baseline_pc1_boxplot_thyroid_irae_with_oor_groups_all_features_batch_regressed_out.png", plot = p, width = 5, height = 3.5)

```

# Plot PCA results for baseline data with batch (+/- age) regressed out, skin irAEs specifically

```{r}

skin_stats_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, specific_group, Batch, age, irae_ex, thyroid_irae, thyroid_irae_including_oor, skin_irae, days_to_irae, thyroid_cat), names_to = "sort", values_to = "value") %>%
  group_by(sort) %>%
  summarize(
    Test_Type = if(all(shapiro.test(value[skin_irae == "Skin irAE"])$p.value > 0.05,
                       shapiro.test(value[skin_irae == "No skin irAE"])$p.value > 0.05)) "t-test" else "Wilcoxon",
    pval = if(Test_Type == "t-test") t.test(value ~ group)$p.value else wilcox.test(value ~ group)$p.value,
    .groups = "drop"
  ) %>%
  mutate(padj = p.adjust(pval, method = "BH")) %>%
  filter(pval < 0.1)

skin_stats_df

wide_baseline_flow_metadata_confounders_regressed_out <- adjusted_data[, 1:12] %>%
  mutate(patient_id_simple = row_number())

wide_baseline_flow_num_data_confounders_regressed_out <- (adjusted_data)[, 13:ncol(adjusted_data)] %>% select(skin_stats_df$sort)

#dim(wide_baseline_flow_num_data_confounders_regressed_out)

pca = prcomp(as.data.frame((na.omit(wide_baseline_flow_num_data_confounders_regressed_out)), center=TRUE, scale=FALSE))

var = get_pca_var(pca)

#head(var$coord)

pca_contributions = as.data.frame((var$contrib))

sumPCA = summary(pca)

#summary(pca)

pca_variance = as.data.frame(t(sumPCA$importance))
pca_variance$pc = factor(row.names(pca_variance), levels = row.names(pca_variance))

pcaScores = as.data.frame(pca$x) %>%
  mutate(patient_id_simple = row_number())

pcaLabels_ = paste0("PC", 1:ncol(pcaScores), " (", round(100*pca_variance$`Proportion of Variance`, 2), "%)")

pcaData = merge(wide_baseline_flow_metadata_confounders_regressed_out, pcaScores, by = "patient_id_simple")

pcas = list()
pcas[["fullData"]] = pcaData

pcaLabels = list()
pcaLabels[["fullData"]] = pcaLabels_

pcaCorrelations = list()

limits = c(max(abs(pcaData$PC1)), max(abs(pcaData$PC2)))

# find features contributing most to variation

top_contributing_features_PC1 <- pca_contributions %>%
    arrange(desc(Dim.1)) %>%
    select(Dim.1) %>%
    head(10)

top_contributing_features_PC2 <- pca_contributions %>%
    arrange(desc(Dim.2)) %>%
    select(Dim.2) %>%
    head(10)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = skin_irae), size = 2, alpha = 0.8) + 
  stat_ellipse(aes(x = PC1, y = PC2, color = skin_irae), size = 1, linetype = 2) +
  #scale_color_manual(values = c("HC" = "purple", "AID" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  #scale_color_gradient2(low = "blue", mid = "grey", high = "red", midpoint = median(pcaData$age, na.rm = TRUE), limits = c(min(pcaData$age), max(pcaData$age))) +  # Blue-White-Red gradient with median age as white
  #xlim(-limits[1], limits[1]) +
  #ylim(-limits[2], limits[2]) +
  labs(color = "") +
  theme_bw() +
  theme(
    legend.position = "bottom", 
    legend.text = element_text(size = 7),  # Adjust legend text size
    #legend.title = element_blank(),  # Adjust legend title size
    legend.spacing.y = unit(0.1, 'cm'),    # Reduce vertical spacing
    legend.spacing.x = unit(0.3, 'cm')     # Reduce horizontal spacing
  ) +
  guides(
    color = guide_legend(nrow = 2, byrow = TRUE),  # Use 2 rows for color legend
  ) +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

ggsave("../figures/baseline_pca_skin_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 3, height = 3.5)

compVar <- data.frame(PC1 = pcaData$PC1,
                      PC2 = pcaData$PC2,
                      PC3 = pcaData$PC3,
                      skin_irae = pcaData$skin_irae)
res <- compareGroups(skin_irae ~ PC1 + PC2 + PC3, data = compVar, p.corrected = TRUE, method = 1)
res

# using "top" features, PC1 pops out as differential:

p <- ggplot(pcaData, aes(x = skin_irae, y = PC1, color = skin_irae)) +
  geom_boxplot() +
  geom_jitter(width = 0.2, alpha = 0.6) +
  labs(y = "PC1", x = "")

p

ggsave("../figures/baseline_pc1_boxplot_skin_irae_groups_top_features_batch_regressed_out.png", plot = p, width = 5, height = 3.5)

```

# Look for correlation b/w irAE grade (and also try time to irAE) and freq for each feature/subset (baseline)

```{r}

ctcae_cor_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, specific_group, Batch, age, irae_ex, thyroid_irae, thyroid_irae_including_oor, skin_irae, days_to_irae, thyroid_cat), names_to = "sort", values_to = "freq") %>%
  filter(!(is.na(ctcae_grade))) %>%
  group_by(sort) %>%
  summarize(cor_result = list(cor.test(ctcae_grade, freq, method = "spearman")), .groups = 'drop') %>%
  mutate(
    estimate = map_dbl(cor_result, ~ .x$estimate),
    p.value = map_dbl(cor_result, ~ .x$p.value)
  ) %>%
  mutate(p.adj = p.adjust(p.value, method = "BH")) %>%
  select(sort, estimate, p.adj) %>%
  arrange(p.adj) %>%
  print()

ggplot(adjusted_data %>% pivot_longer(cols = -c(patient_id, group, ctcae_grade, specific_group, Batch, age, irae_ex, thyroid_irae, thyroid_irae_including_oor, skin_irae, days_to_irae, thyroid_cat), names_to = "sort", values_to = "freq") %>% filter(sort == "swMem.of.Bcells"), aes(x = ctcae_grade, y = freq)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(
    x = "CTCAE Grade",
    y = "swMem of Bcells (residuals)")

time_to_irae_df <- adjusted_data %>%
  pivot_longer(cols = -c(patient_id, group, ctcae_grade, specific_group, Batch, age, irae_ex, thyroid_irae, thyroid_irae_including_oor, skin_irae, days_to_irae, thyroid_cat), names_to = "sort", values_to = "freq") %>%
  filter(group == "irAE/SAE") %>%
  group_by(sort) %>%
  summarize(cor_result = list(cor.test(days_to_irae, freq, method = "spearman")), .groups = 'drop') %>%
  mutate(
    estimate = map_dbl(cor_result, ~ .x$estimate),
    p.value = map_dbl(cor_result, ~ .x$p.value)
  ) %>%
  mutate(p.adj = p.adjust(p.value, method = "BH")) %>%
  select(sort, estimate, p.adj) %>%
  arrange(p.adj) %>%
  print()

```

# Determine clusters in PCA space, then test for enrichment of study groups in clusters

```{r}

# Elbow method to determine optimal number of clusters
set.seed(123)
wss <- sapply(1:10, function(k) {
  kmeans(pcaData[, c("PC1", "PC2", "PC3")], centers = k, nstart = 25)$tot.withinss
})

# Plot the Elbow curve
plot(1:10, wss, type = "b", pch = 19, frame = FALSE, xlab = "Number of clusters", ylab = "Total within-cluster sum of squares")

kmeans_result <- kmeans(pcaData[, c("PC1", "PC2", "PC3")], centers = 10, nstart = 25)

# Add cluster assignments to the data
pcaData$cluster <- factor(kmeans_result$cluster)

p <- ggplot(data = pcaData) +
  geom_hline(yintercept = 1, linetype = 2, color = "grey") +
  geom_vline(xintercept = 0, linetype = 2, color = "grey") +
  geom_point(aes(x = PC1, y = PC2, color = cluster), size = 2, alpha = 0.8) +  # Color by cluster
  labs(color = "Cluster") +
  labs(x = pcaLabels_[1], y = pcaLabels_[2])

p

table_result <- table(pcaData$cluster, pcaData$group)

chisq_test <- chisq.test(table_result)
chisq_test
fisher_test <- fisher.test(table_result)
fisher_test

```

# Make VP of changes between irAE and no irAE groups

```{r}

df <- adjusted_data

irae_group <- df %>% dplyr::filter(group == "irAE/SAE")
no_irae_group <- df %>% dplyr::filter(group == "non-irAE")

non_feature_cols <- c("patient_id", "group", "specific_group", "irae_ex", "Batch", 
                      "age", "ctcae_grade", "thyroid_irae", "thyroid_irae_including_oor", "skin_irae", "days_to_irae", "thyroid_cat")
feature_columns <- setdiff(colnames(df), non_feature_cols)

# Calculate mean residuals for each feature
irae_means <- (irae_group %>% select(all_of(feature_columns)) %>% summarise_all(mean))
no_irae_means <- no_irae_group %>% select(all_of(feature_columns)) %>% summarise_all(mean)

abs_diff <- (as.numeric(irae_means) - as.numeric(no_irae_means))
#log2_fc <- sign(fc) * log2(abs(fc))

pvals <- sapply(feature_columns, function(feature) {
  wilcox.test(irae_group[[feature]], no_irae_group[[feature]])$p.value
})

padj <- p.adjust(pvals, method = "BH")

volcano_df <- data.frame(
  feature = feature_columns,
  abs_diff = abs_diff,
  padj = padj,
  neg_log10_padj = -log10(padj)
)

ggplot(volcano_df, aes(x = abs_diff, y = neg_log10_padj)) +
  geom_point(aes(color = padj < 0.1)) +
  theme_minimal() +
  labs(x = "irAE/SAE vs. no irAE (absolute difference in mean of residuals)", y = "-log10(padj)") +
  geom_vline(xintercept = 0, linetype = "dashed") + # Vertical line at 0 fold change +
  geom_hline(yintercept = -log10(0.1), linetype = "dashed") + # horizontal line at sig threshold
  geom_text_repel(data = subset(volcano_df, padj < 0.35), 
                  aes(label = feature), size = 3, box.padding = 0.5, max.overlaps = 10)

```

# Make a boxplot for features of interest after regressing out batch

```{r}

# features of interest from literature
# DN of Bcells"                    "CD8 of Tcells"                   "CD38hiCD127neg of NN CD8 Tcells"

plot_data <- adjusted_data %>% select(group, DN.of.Bcells, CD8.of.Tcells, CD38hiCD127neg.of.NN.CD8.Tcells) %>%
  pivot_longer(cols = c(DN.of.Bcells, CD8.of.Tcells, CD38hiCD127neg.of.NN.CD8.Tcells), names_to = "sort", values_to = "freq") %>%
  mutate(sort = case_when(
    sort == "CD8.of.Tcells" ~ "CD8 of Tcells",
    sort == "CD38hiCD127neg.of.NN.CD8.Tcells" ~ "CD38hiCD127-\nof NN CD8s",
    sort == "DN.of.Bcells" ~ "DN of Bcells"
  ))

p <- plot_data %>%
  ggplot(aes(x = group, y = freq, fill = group)) +
  geom_boxplot(outlier.shape = NA) +
  facet_wrap(~ sort, ncol = 3) +
  geom_jitter(color = "grey", size = 0.5) +
  labs(x = "", y = "Residuals (batch\nregressed out)") +
  scale_fill_manual(values = c("Healthy_Control" = "purple", "AID_Patient" = "blue", "non-irAE" = "black", "irAE/SAE" = "red")) +
  theme(axis.text.x = element_blank(),
        strip.text = element_text(size = 8))

p

ggsave("../figures/batch_regressed_out_residuals_by_feature_hits.png", plot = p, width = 7, height = 3.5)

```

# Find optimal number of components for ICA

```{r}

### Show example of one splitting iteration
# Split the features into 2 ~equal sets
## Set seed for reproducibility
feats1 <- sample(colnames(wide_baseline_flow_num_data_confounders_regressed_out),round(ncol(wide_baseline_flow_num_data_confounders_regressed_out)/2) )
feats2 <- colnames(wide_baseline_flow_num_data_confounders_regressed_out)[!colnames(wide_baseline_flow_num_data_confounders_regressed_out) %in% feats1]
print( paste0("Num features: ", length(feats1), ", ", length(feats2)) )

# Generate 2 ICA models with the split genes with 8 components
ncomps <- 6
ica1 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats1], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
print(paste0("Sample ICA Weight Matrix Dimensions: ", nrow(ica1$S)," by ", ncol(ica1$S)) )
ica2 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats2], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)

## Correlate the components together
cormat <- cor(ica1$S, ica2$S,method="spearman")
rowMaxes <- apply(abs(cormat),1,max)
rownames(cormat) <- as.character( signif(rowMaxes,3))
Heatmap(abs(cormat), name="Pearson\nCorrelation",column_title="Pairwise Correlations Between Split ICA Models")
# Get the worst best correlation
minMaxR <- min( apply(abs(cormat),1,max) )
print( paste0("Worst best component correlation: ",minMaxR) )

## Function to compute worst best component correlation for a sequence of component numbers
getSplitMinMaxR <- function(nCompsSequence, data.tmp=wide_baseline_flow_num_data_confounders_regressed_out){ # get the minimum spearman correlation between the ICA components from the two splits
  
  # Split the features into 2 equal sets
  feats1 <- sample(colnames(wide_baseline_flow_num_data_confounders_regressed_out),round(ncol(wide_baseline_flow_num_data_confounders_regressed_out)/2) )
  feats2 <- colnames(wide_baseline_flow_num_data_confounders_regressed_out)[!colnames(wide_baseline_flow_num_data_confounders_regressed_out) %in% feats1]
  
  getMinMaxR <- function(ncomps){
    print(ncomps)
    ica1 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats1], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
    ica2 <- icafast(wide_baseline_flow_num_data_confounders_regressed_out[,feats2], ncomps, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(ncomps), alg = "par", fun = "logcosh", alpha = 1)
    cormat <- cor(ica1$S, ica2$S,method="spearman")
    vals <- c( minMaxR = min( apply(abs(cormat),2,max)), ncomps=ncomps )
  }
  
  minMaxRs <- data.frame( t(sapply( nCompsSequence, getMinMaxR)) )
  return(minMaxRs)
}

# Do two splits
nCompsSequence <- 2:15
numShuffles <- 2
minMaxRs <- lapply(1:numShuffles, function(i) getSplitMinMaxR(nCompsSequence, wide_baseline_flow_num_data_confounders_regressed_out) )
for( i in 1:length(minMaxRs) ){
  minMaxRs[[i]]$shuffleNumber <- i
}
print("Min Max Rs: ")
print(minMaxRs)
numShuffles <- length(minMaxRs)

getCorDiffs <- function( minMaxR ){
  corDiffs <- minMaxR$minMaxR[2:nrow(minMaxR)] - minMaxR$minMaxR[1:(nrow(minMaxR)-1) ]
  biggestDecline <- minMaxR$ncomps[ which( corDiffs == min(corDiffs)) ]
  print( paste0("Biggest Correlation Decline: ", biggestDecline, " to ", biggestDecline+1 ) )
  return(biggestDecline)
}

biggestDeclines <- sapply(minMaxRs,getCorDiffs)
biggestDeclineTab <- table(biggestDeclines)
ggplot() + geom_histogram( aes(x=biggestDeclines)) + labs(x="# of components before the largest decline")
optimalCompNum <- as.numeric( names(biggestDeclineTab)[biggestDeclineTab==max(biggestDeclineTab)] )
print(optimalCompNum)

## Make boxplot of results of correlations for all 50 subsamples
minMaxRsLong <- do.call(rbind,minMaxRs)
ggplot(minMaxRsLong,aes(x=ncomps,y=minMaxR)) + geom_boxplot(aes(group=ncomps)) + geom_line(aes(group=shuffleNumber), alpha=0.1,color="red") + labs(x="number of ICA components",y="Lowest Component\nSpearman Correlation",title=paste0( numShuffles," Feature 2-Way Splits\nMinMax Component Correlation")) + geom_vline(xintercept = optimalCompNum, linetype="dashed",color="blue")

```

# Run ICA with optimal num of components

```{r}

optimalCompNum <- 6  # or set to your identified number of components
ica_model <- icafast(wide_baseline_flow_num_data_confounders_regressed_out, optimalCompNum, center = FALSE, maxit = 5000, tol = 1e-6, Rmat = diag(optimalCompNum), alg = "par", fun = "logcosh", alpha = 1)

# Extract the ICA components
ica_components <- ica_model$S

wide_baseline_flow_metadata_confounders_regressed_out$patient_id_simple <- as.character(wide_baseline_flow_metadata_confounders_regressed_out$patient_id_simple)

# Create a data frame with the first 2 or 3 components for visualization
ica_df <- data.frame(Comp1 = ica_components[,1], Comp2 = ica_components[,2], patient_id_simple = as.character(rownames(wide_baseline_flow_num_data_confounders_regressed_out))) %>%
  left_join(wide_baseline_flow_metadata_confounders_regressed_out, by = "patient_id_simple") %>%
  # just look at cancer patients (baseline)
  filter(!(is.na(group)))

# Plot the first 2 components
ggplot(ica_df, aes(x=Comp1, y=Comp2)) +
  geom_point(aes(color=group), size=2) + 
  labs(x="ICA Component 1", y="ICA Component 2")

```

# Cluster baseline cancer samples in ICA space, test for enrichment of irAE groups

```{r}

wss <- sapply(1:10, function(k) {
  kmeans(ica_df[, c("Comp1", "Comp2")], centers = k, nstart = 25)$tot.withinss
})

# Plot the Elbow curve
plot(1:10, wss, type = "b", pch = 19, frame = FALSE, xlab = "Number of clusters", ylab = "Total within-cluster sum of squares")

kmeans_result <- kmeans(ica_df[, c("Comp1", "Comp2")], centers = 6, nstart = 25)

# Add cluster assignments to the data
ica_df$cluster <- factor(kmeans_result$cluster)

ggplot(ica_df, aes(x = Comp1, y = Comp2, color = cluster)) +
  geom_point(size = 2, alpha = 0.8) +
  labs(x = "ICA Component 1", y = "ICA Component 2", color = "Cluster") +
  theme_minimal()

# Create contingency table for clusters vs. group
table_result <- table(ica_df$cluster, ica_df$group)

# Perform Chi-square and Fisher's Exact tests
chisq_test <- chisq.test(table_result)
fisher_test <- fisher.test(table_result)

# Display results
chisq_test
fisher_test

```

# Find features associating with age in HC/AID groups (to see if those who develop irAEs have older immunotypes)

```{r}

non_cancer_data <- adjusted_data %>%
  mutate(age = as.numeric(as.character(age))) %>%
  filter(group %in% c("AID_Patient", "Healthy_Control"))

immune_features <- non_cancer_data[, 10:ncol(non_cancer_data)]

correlation_results <- immune_features %>%
  summarise(across(everything(), ~ cor.test(.x, non_cancer_data$age, method = "spearman")$estimate)) %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "correlation")

p_values <- immune_features %>%
  summarise(across(everything(), ~ cor.test(.x, non_cancer_data$age, method = "spearman")$p.value)) %>%
  pivot_longer(cols = everything(), names_to = "feature", values_to = "p_value")

correlation_summary <- left_join(correlation_results, p_values, by = "feature") %>%
  mutate(padj = p.adjust(p_value, method = "BH")) %>%
  arrange(padj) %>%
  filter(padj < 0.05)

correlation_summary

ggplot(non_cancer_data, aes(x = age, y = naive.of.CD8.Tcells, color = group)) +
  geom_point(alpha = 0.6) +  # Scatter points
  geom_smooth(method = "lm", color = "black", se = FALSE)

```

# Use LMs from non-cancer group (with age as factor) on cancer data to predict immunotype scores for features associating with age in non-cancer group

```{r}

# Fit a linear model for each age-correlated feature
models <- lapply(correlation_summary$feature, function(feature) {
  lm(as.formula(paste(feature, "~ age")), data = non_cancer_data)
})
names(models) <- correlation_summary$feature  # Name each model with its corresponding feature

models

cancer_data <- adjusted_data %>%
  mutate(age = as.numeric(as.character(age))) %>%
  filter(!(group %in% c("AID_Patient", "Healthy_Control")))

predict_immunotype_score <- function(model, age) {
  intercept <- coef(model)[1]
  slope <- coef(model)[2]
  return(intercept + slope * age)
}

predicted_scores <- data.frame(patient_id = cancer_data$patient_id)

# Loop through each model and predict scores for cancer patients
for (feature in names(models)) {
  predicted_scores[[feature]] <- sapply(cancer_data$age, function(age) predict_immunotype_score(models[[feature]], age))
}

# Rename the scores column to a more descriptive name
colnames(predicted_scores)[-1] <- paste0("immunotype_age_score_", names(models))

predicted_scores_with_metadata <- left_join(cancer_data %>% select(patient_id, group), predicted_scores, by = "patient_id")

predicted_scores_with_metadata

# Reshape data to long format for ggplot
predicted_scores_with_metadata_long <- predicted_scores_with_metadata %>%
  pivot_longer(cols = starts_with("immunotype_age_score"), 
               names_to = "immunotype", 
               values_to = "score") %>%
  mutate(immunotype = gsub("immunotype_age_score_", "", immunotype))

ggplot(predicted_scores_with_metadata_long, aes(x = immunotype, y = score, color = group)) +
  geom_point(position = position_jitter(width = 0.2), size = 1) +  # Add jitter for better visibility
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8)) +
  labs(x = "", y = "Predicted score based\non HC/AID data")

```